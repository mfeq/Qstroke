/* automatically generated by rust-bindgen 0.57.0 */
#![allow(warnings, unused)]
#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const FONTFORGE_VERSION: &'static [u8; 9usize] = b"20201107\0";
pub const FONTFORGE_INSTALL_PREFIX: &'static [u8; 5usize] = b"/opt\0";
pub const HAVE_EXECINFO_H: u32 = 1;
pub const HAVE_ICONV_H: u32 = 1;
pub const HAVE_LIBINTL_H: u32 = 1;
pub const HAVE_LANGINFO_H: u32 = 1;
pub const HAVE_NL_LANGINFO: u32 = 1;
pub const FONTFORGE_CONFIG_USE_DOUBLE: u32 = 1;
pub const _NO_XKB: u32 = 1;
pub const _NO_XINPUT: u32 = 1;
pub const X_DISPLAY_MISSING: u32 = 1;
pub const FONTFORGE_CAN_USE_GDK: u32 = 1;
pub const FONTFORGE_CAN_USE_WOFF2: u32 = 1;
pub const _NO_LIBUNICODENAMES: u32 = 1;
pub const _LIBSPIRO_FUN: u32 = 2;
pub const _LIBUNINAMESLIST_FUN: u32 = 5;
pub const _INTTYPES_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 33;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const __PRIPTR_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const PRId8: &'static [u8; 2usize] = b"d\0";
pub const PRId16: &'static [u8; 2usize] = b"d\0";
pub const PRId32: &'static [u8; 2usize] = b"d\0";
pub const PRId64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIi8: &'static [u8; 2usize] = b"i\0";
pub const PRIi16: &'static [u8; 2usize] = b"i\0";
pub const PRIi32: &'static [u8; 2usize] = b"i\0";
pub const PRIi64: &'static [u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiFAST16: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST32: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIo8: &'static [u8; 2usize] = b"o\0";
pub const PRIo16: &'static [u8; 2usize] = b"o\0";
pub const PRIo32: &'static [u8; 2usize] = b"o\0";
pub const PRIo64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIu8: &'static [u8; 2usize] = b"u\0";
pub const PRIu16: &'static [u8; 2usize] = b"u\0";
pub const PRIu32: &'static [u8; 2usize] = b"u\0";
pub const PRIu64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIx8: &'static [u8; 2usize] = b"x\0";
pub const PRIx16: &'static [u8; 2usize] = b"x\0";
pub const PRIx32: &'static [u8; 2usize] = b"x\0";
pub const PRIx64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIX8: &'static [u8; 2usize] = b"X\0";
pub const PRIX16: &'static [u8; 2usize] = b"X\0";
pub const PRIX32: &'static [u8; 2usize] = b"X\0";
pub const PRIX64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXFAST16: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST32: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIdMAX: &'static [u8; 3usize] = b"ld\0";
pub const PRIiMAX: &'static [u8; 3usize] = b"li\0";
pub const PRIoMAX: &'static [u8; 3usize] = b"lo\0";
pub const PRIuMAX: &'static [u8; 3usize] = b"lu\0";
pub const PRIxMAX: &'static [u8; 3usize] = b"lx\0";
pub const PRIXMAX: &'static [u8; 3usize] = b"lX\0";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\0";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\0";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\0";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\0";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\0";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\0";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNd16: &'static [u8; 3usize] = b"hd\0";
pub const SCNd32: &'static [u8; 2usize] = b"d\0";
pub const SCNd64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNi16: &'static [u8; 3usize] = b"hi\0";
pub const SCNi32: &'static [u8; 2usize] = b"i\0";
pub const SCNi64: &'static [u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST32: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNu16: &'static [u8; 3usize] = b"hu\0";
pub const SCNu32: &'static [u8; 2usize] = b"u\0";
pub const SCNu64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNo8: &'static [u8; 4usize] = b"hho\0";
pub const SCNo16: &'static [u8; 3usize] = b"ho\0";
pub const SCNo32: &'static [u8; 2usize] = b"o\0";
pub const SCNo64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNx16: &'static [u8; 3usize] = b"hx\0";
pub const SCNx32: &'static [u8; 2usize] = b"x\0";
pub const SCNx64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNdMAX: &'static [u8; 3usize] = b"ld\0";
pub const SCNiMAX: &'static [u8; 3usize] = b"li\0";
pub const SCNoMAX: &'static [u8; 3usize] = b"lo\0";
pub const SCNuMAX: &'static [u8; 3usize] = b"lu\0";
pub const SCNxMAX: &'static [u8; 3usize] = b"lx\0";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\0";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\0";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\0";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\0";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\0";
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const _MEMORY_H: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const FF_PI: f64 = 3.141592653589793;
pub const _ICONV_H: u32 = 1;
pub const UTF8IDPB_NOZERO: u32 = 1;
pub const UTF8IDPB_OLDLIMIT: u32 = 2;
pub const UTF8IDPB_UCS2: u32 = 8;
pub const UTF8IDPB_UTF16: u32 = 16;
pub const UTF8IDPB_UTF32: u32 = 32;
pub const _LOCALE_H: u32 = 1;
pub const _BITS_LOCALE_H: u32 = 1;
pub const __LC_CTYPE: u32 = 0;
pub const __LC_NUMERIC: u32 = 1;
pub const __LC_TIME: u32 = 2;
pub const __LC_COLLATE: u32 = 3;
pub const __LC_MONETARY: u32 = 4;
pub const __LC_MESSAGES: u32 = 5;
pub const __LC_ALL: u32 = 6;
pub const __LC_PAPER: u32 = 7;
pub const __LC_NAME: u32 = 8;
pub const __LC_ADDRESS: u32 = 9;
pub const __LC_TELEPHONE: u32 = 10;
pub const __LC_MEASUREMENT: u32 = 11;
pub const __LC_IDENTIFICATION: u32 = 12;
pub const LC_CTYPE: u32 = 0;
pub const LC_NUMERIC: u32 = 1;
pub const LC_TIME: u32 = 2;
pub const LC_COLLATE: u32 = 3;
pub const LC_MONETARY: u32 = 4;
pub const LC_MESSAGES: u32 = 5;
pub const LC_ALL: u32 = 6;
pub const LC_PAPER: u32 = 7;
pub const LC_NAME: u32 = 8;
pub const LC_ADDRESS: u32 = 9;
pub const LC_TELEPHONE: u32 = 10;
pub const LC_MEASUREMENT: u32 = 11;
pub const LC_IDENTIFICATION: u32 = 12;
pub const LC_CTYPE_MASK: u32 = 1;
pub const LC_NUMERIC_MASK: u32 = 2;
pub const LC_TIME_MASK: u32 = 4;
pub const LC_COLLATE_MASK: u32 = 8;
pub const LC_MONETARY_MASK: u32 = 16;
pub const LC_MESSAGES_MASK: u32 = 32;
pub const LC_PAPER_MASK: u32 = 128;
pub const LC_NAME_MASK: u32 = 256;
pub const LC_ADDRESS_MASK: u32 = 512;
pub const LC_TELEPHONE_MASK: u32 = 1024;
pub const LC_MEASUREMENT_MASK: u32 = 2048;
pub const LC_IDENTIFICATION_MASK: u32 = 4096;
pub const LC_ALL_MASK: u32 = 8127;
pub const SPIRO_CORNER: u8 = 118u8;
pub const SPIRO_G4: u8 = 111u8;
pub const SPIRO_G2: u8 = 99u8;
pub const SPIRO_LEFT: u8 = 91u8;
pub const SPIRO_RIGHT: u8 = 93u8;
pub const SPIRO_END: u8 = 122u8;
pub const SPIRO_OPEN_CONTOUR: u8 = 123u8;
pub const SPIRO_END_OPEN_CONTOUR: u8 = 125u8;
pub const SPIRO_ANCHOR: u8 = 97u8;
pub const SPIRO_HANDLE: u8 = 104u8;
pub const SPIRO_INCLUDE_LAST_KNOT: u32 = 256;
pub const SPIRO_RETRO_VER1: u32 = 1024;
pub const SPIRO_REVERSE_SRC: u32 = 2048;
pub const SPIRO_ARC_CUB_QUAD_CLR: u32 = 32767;
pub const SPIRO_ARC_CUB_QUAD_MASK: u32 = 28672;
pub const SPIRO_CUBIC_TO_BEZIER: u32 = 0;
pub const SPIRO_CUBIC_MIN_MAYBE: u32 = 4096;
pub const SPIRO_ARC_MAYBE: u32 = 8192;
pub const SPIRO_ARC_MIN_MAYBE: u32 = 12288;
pub const SPIRO_QUAD0_TO_BEZIER: u32 = 16384;
pub const MmMax: u32 = 16;
pub const AppleMmMax: u32 = 26;
pub const BACK_LAYER_MAX: u32 = 256;
pub const COLOR_INHERITED: u32 = 4294967294;
pub const WIDTH_INHERITED: i32 = -1;
pub const DASH_INHERITED: u32 = 255;
pub const DASH_MAX: u32 = 8;
pub const JLIMIT_INHERITED: i32 = -1;
pub const MAX_LANG: u32 = 4;
pub const FF_KERNCLASS_FLAG_NATIVE: u32 = 2;
pub const FF_KERNCLASS_FLAG_FEATURE: u32 = 4;
pub const FF_KERNCLASS_FLAG_NAMETYPE: u32 = 8;
pub const FF_KERNCLASS_FLAG_NAMELEGACY: u32 = 16;
pub const FF_KERNCLASS_FLAG_VIRTUAL: u32 = 32;
pub const FF_KERNCLASS_FLAG_FLATTEN: u32 = 64;
pub const FF_KERNCLASS_FLAG_SINGLECHAR: u32 = 96;
pub const UNDO_LAYER_UNKNOWN: i32 = -1;
pub const HntMax: u32 = 96;
pub const TEX_UNDEF: u32 = 32767;
pub const sfntRevisionUnset: u32 = 1145328981;
pub const woffUnset: u32 = 17493;
pub const GROUP_NAME_KERNING_UFO: u32 = 1;
pub const GROUP_NAME_KERNING_FEATURE: u32 = 2;
pub const GROUP_NAME_VERTICAL: u32 = 4;
pub const GROUP_NAME_RIGHT: u32 = 8;
pub const UNDEFINED_WIDTH: i32 = -999999;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type size_t = ::std::os::raw::c_ulong;
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
        __l: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: size_t,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: size_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: size_t);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type off_t = __off_t;
pub type ssize_t = __ssize_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: size_t,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: size_t);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_slist>())).__next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__once_flag>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).fptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_deg as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_sep as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).end_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__old_x as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__c as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__init as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__a as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: size_t, __size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        __pwcs: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstombs(
        __s: *mut ::std::os::raw::c_char,
        __pwcs: *const wchar_t,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
pub type int32 = i32;
pub type uint32 = u32;
pub type int16 = i16;
pub type uint16 = u16;
pub type int8 = i8;
pub type uint8 = u8;
pub type intpt = isize;
pub type unichar_t = uint32;
extern "C" {
    pub fn NoMoreMemMessage();
}
#[doc = " Doubly linked list abstraction. Putting a full member of this"]
#[doc = " struct first in another struct means you can treat it as a"]
#[doc = " dlinkedlist. You can have a struct in many lists simply by"]
#[doc = " embedding another dlistnode member and handing a pointer to that"]
#[doc = " member to the dlist() helper functions. Double linking has big"]
#[doc = " advantages in removal of single elements where you do not need to"]
#[doc = " rescan to find removeme->prev;"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dlistnode {
    pub next: *mut dlistnode,
    pub prev: *mut dlistnode,
}
#[test]
fn bindgen_test_layout_dlistnode() {
    assert_eq!(
        ::std::mem::size_of::<dlistnode>(),
        16usize,
        concat!("Size of: ", stringify!(dlistnode))
    );
    assert_eq!(
        ::std::mem::align_of::<dlistnode>(),
        8usize,
        concat!("Alignment of ", stringify!(dlistnode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dlistnode>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dlistnode),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dlistnode>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dlistnode),
            "::",
            stringify!(prev)
        )
    );
}
#[doc = " DEVELOPERS: make sure the start of this struct is compatible with"]
#[doc = " dlistnode. While I could use the dlistnode as a first member, using"]
#[doc = " a copy of the members in the same order as dlistnode has them"]
#[doc = " allows callers using this struct a bit simpler access."]
#[doc = ""]
#[doc = " While one can embed a dlistnode member into a struct to create"]
#[doc = " linked lists, sometimes you want to return a splice of one of those"]
#[doc = " lists. For example, if you have a double linked list of all your"]
#[doc = " hotkeys, you might like to return only the ones that have a"]
#[doc = " modifier of the Control key. You want to leave the hotkey structs"]
#[doc = " in their original list, but create a new kust that references just"]
#[doc = " a desired selection of objects."]
#[doc = ""]
#[doc = " In other words, if you have some data you want to return in a"]
#[doc = " double linked list, then use this node type. You can build one up"]
#[doc = " using dlist_pushfront_external() and the caller can free that list"]
#[doc = " using dlist_free_external(). Any of the foreach() functions will"]
#[doc = " work to iterate a list of dlistnodeExternal as this list is"]
#[doc = " identical to a dlistnode with an extra ptr payload."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dlistnodeExternal {
    pub next: *mut dlistnode,
    pub prev: *mut dlistnode,
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_dlistnodeExternal() {
    assert_eq!(
        ::std::mem::size_of::<dlistnodeExternal>(),
        24usize,
        concat!("Size of: ", stringify!(dlistnodeExternal))
    );
    assert_eq!(
        ::std::mem::align_of::<dlistnodeExternal>(),
        8usize,
        concat!("Alignment of ", stringify!(dlistnodeExternal))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dlistnodeExternal>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dlistnodeExternal),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dlistnodeExternal>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dlistnodeExternal),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dlistnodeExternal>())).ptr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dlistnodeExternal),
            "::",
            stringify!(ptr)
        )
    );
}
extern "C" {
    #[doc = " Push the node onto the head of the list"]
    pub fn dlist_pushfront(list: *mut *mut dlistnode, node: *mut dlistnode);
}
extern "C" {
    #[doc = " Take the last node off the list and return it. If the list is empty, return 0."]
    pub fn dlist_popback(list: *mut *mut dlistnode) -> *mut dlistnode;
}
extern "C" {
    #[doc = " the number of nodes in the list"]
    pub fn dlist_size(list: *mut *mut dlistnode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " is the list empty"]
    pub fn dlist_isempty(list: *mut *mut dlistnode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove the node from the list. The node itself is not free()ed."]
    #[doc = " That is still up to the caller. All this function does is preserve"]
    #[doc = " the list structure without the node being in it."]
    pub fn dlist_erase(list: *mut *mut dlistnode, node: *mut dlistnode);
}
pub type dlist_foreach_func_type =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut dlistnode)>;
extern "C" {
    #[doc = " Call func for every node in the list. This is a defensive"]
    #[doc = "  implementation, if you want to remove a node from the list inside"]
    #[doc = "  func() that is perfectly fine."]
    pub fn dlist_foreach(list: *mut *mut dlistnode, func: dlist_foreach_func_type);
}
pub type dlist_foreach_udata_func_type = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut dlistnode, udata: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " Like dlist_foreach(), defensive coding still, but the udata pointer"]
    #[doc = " is passed back to your visitor function."]
    pub fn dlist_foreach_udata(
        list: *mut *mut dlistnode,
        func: dlist_foreach_udata_func_type,
        udata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Like dlist_foreach_udata() but nodes are visited in reverse order."]
    pub fn dlist_foreach_reverse_udata(
        list: *mut *mut dlistnode,
        func: dlist_foreach_udata_func_type,
        udata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Assuming list is an externalNode list, push a newly allocated list node with"]
    #[doc = " a dlistnodeExternal.ptr = ptr passed."]
    pub fn dlist_pushfront_external(list: *mut *mut dlistnode, ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Free a list of externalNode type. The externalNode memory is"]
    #[doc = " free()ed, whatever externalNode.ptr is pointing to is not free()ed."]
    pub fn dlist_free_external(list: *mut *mut dlistnode);
}
pub type dlist_visitor_func_type =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut dlistnode)>;
extern "C" {
    #[doc = " To create a list of bounded length, use this function. Limit is the"]
    #[doc = " maximum length the list can reach. If list nodes have to be removed"]
    #[doc = " to be under this limit then \"f\" is used as a callback to free list"]
    #[doc = " nodes. This allows application specific freeing of a list node, and"]
    #[doc = " the ability to maintain a limit on the length of a list as a simple"]
    #[doc = " one line call."]
    #[doc = ""]
    #[doc = " The current implementation expects you to only be trimming one or"]
    #[doc = " two entries at a time. It will still work for trimming 100 entries"]
    #[doc = " at a single time, but might not be quite as optimized for that case"]
    #[doc = " as it could be."]
    pub fn dlist_trim_to_limit(
        list: *mut *mut dlistnode,
        limit: ::std::os::raw::c_int,
        f: dlist_visitor_func_type,
    );
}
pub type iconv_t = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn iconv_open(
        __tocode: *const ::std::os::raw::c_char,
        __fromcode: *const ::std::os::raw::c_char,
    ) -> iconv_t;
}
extern "C" {
    pub fn iconv(
        __cd: iconv_t,
        __inbuf: *mut *mut ::std::os::raw::c_char,
        __inbytesleft: *mut size_t,
        __outbuf: *mut *mut ::std::os::raw::c_char,
        __outbytesleft: *mut size_t,
    ) -> size_t;
}
extern "C" {
    pub fn iconv_close(__cd: iconv_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut iconv_local_encoding_name: *mut ::std::os::raw::c_char;
}
pub const encoding_e_usascii: encoding = 0;
pub const encoding_e_iso646_no: encoding = 1;
pub const encoding_e_iso646_se: encoding = 2;
pub const encoding_e_iso8859_1: encoding = 3;
pub const encoding_e_iso8859_2: encoding = 4;
pub const encoding_e_iso8859_3: encoding = 5;
pub const encoding_e_iso8859_4: encoding = 6;
pub const encoding_e_iso8859_5: encoding = 7;
pub const encoding_e_iso8859_6: encoding = 8;
pub const encoding_e_iso8859_7: encoding = 9;
pub const encoding_e_iso8859_8: encoding = 10;
pub const encoding_e_iso8859_9: encoding = 11;
pub const encoding_e_iso8859_10: encoding = 12;
pub const encoding_e_iso8859_11: encoding = 13;
pub const encoding_e_iso8859_13: encoding = 14;
pub const encoding_e_iso8859_14: encoding = 15;
pub const encoding_e_iso8859_15: encoding = 16;
pub const encoding_e_iso8859_16: encoding = 17;
pub const encoding_e_koi8_r: encoding = 18;
pub const encoding_e_jis201: encoding = 19;
pub const encoding_e_win: encoding = 20;
pub const encoding_e_mac: encoding = 21;
pub const encoding_e_user: encoding = 22;
pub const encoding_e_jis: encoding = 23;
pub const encoding_e_jis2: encoding = 24;
pub const encoding_e_jiskorean: encoding = 25;
pub const encoding_e_jisgb: encoding = 26;
pub const encoding_e_sjis: encoding = 27;
pub const encoding_e_euc: encoding = 28;
pub const encoding_e_euckorean: encoding = 29;
pub const encoding_e_eucgb: encoding = 30;
pub const encoding_e_wansung: encoding = 31;
pub const encoding_e_johab: encoding = 32;
pub const encoding_e_big5: encoding = 33;
pub const encoding_e_big5hkscs: encoding = 34;
pub const encoding_e_unicode: encoding = 35;
pub const encoding_e_unicode_backwards: encoding = 36;
pub const encoding_e_utf7: encoding = 37;
pub const encoding_e_utf8: encoding = 38;
pub const encoding_e_ucs4: encoding = 39;
pub const encoding_e_notrans: encoding = 40;
pub const encoding_e_encodingmax: encoding = 41;
pub const encoding_e_unknown: encoding = -1;
pub const encoding_e_first2byte: encoding = 23;
pub type encoding = ::std::os::raw::c_int;
pub const charset_em_none: charset = -1;
pub const charset_em_iso8859_1: charset = 0;
pub const charset_em_iso8859_2: charset = 1;
pub const charset_em_iso8859_3: charset = 2;
pub const charset_em_iso8859_4: charset = 3;
pub const charset_em_iso8859_5: charset = 4;
pub const charset_em_iso8859_6: charset = 5;
pub const charset_em_iso8859_7: charset = 6;
pub const charset_em_iso8859_8: charset = 7;
pub const charset_em_iso8859_9: charset = 8;
pub const charset_em_iso8859_10: charset = 9;
pub const charset_em_iso8859_11: charset = 10;
pub const charset_em_iso8859_13: charset = 11;
pub const charset_em_iso8859_14: charset = 12;
pub const charset_em_iso8859_15: charset = 13;
pub const charset_em_iso8859_16: charset = 14;
pub const charset_em_koi8_r: charset = 15;
pub const charset_em_jis201: charset = 16;
pub const charset_em_win: charset = 17;
pub const charset_em_mac: charset = 18;
pub const charset_em_symbol: charset = 19;
pub const charset_em_zapfding: charset = 20;
pub const charset_em_user: charset = 21;
pub const charset_em_adobestandard: charset = 21;
pub const charset_em_jis208: charset = 22;
pub const charset_em_jis212: charset = 23;
pub const charset_em_ksc5601: charset = 24;
pub const charset_em_gb2312: charset = 25;
pub const charset_em_big5: charset = 26;
pub const charset_em_big5hkscs: charset = 27;
pub const charset_em_johab: charset = 28;
pub const charset_em_unicode: charset = 29;
pub const charset_em_unicode4: charset = 30;
pub const charset_em_gb18030: charset = 31;
pub const charset_em_max: charset = 32;
pub const charset_em_first2byte: charset = 22;
pub const charset_em_last94x94: charset = 25;
pub type charset = ::std::os::raw::c_int;
extern "C" {
    pub static mut local_encoding: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct namemap {
    pub name: *const ::std::os::raw::c_char,
    pub map: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_namemap() {
    assert_eq!(
        ::std::mem::size_of::<namemap>(),
        16usize,
        concat!("Size of: ", stringify!(namemap))
    );
    assert_eq!(
        ::std::mem::align_of::<namemap>(),
        8usize,
        concat!("Alignment of ", stringify!(namemap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<namemap>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(namemap),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<namemap>())).map as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(namemap),
            "::",
            stringify!(map)
        )
    );
}
extern "C" {
    pub static mut encodingnames: [namemap; 0usize];
}
extern "C" {
    pub fn copy(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn copyn(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_copy(arg1: *const unichar_t) -> *mut unichar_t;
}
extern "C" {
    pub fn u_copyn(arg1: *const unichar_t, arg2: ::std::os::raw::c_long) -> *mut unichar_t;
}
extern "C" {
    pub fn u_copynallocm(
        pt: *const unichar_t,
        n: ::std::os::raw::c_long,
        m: ::std::os::raw::c_long,
    ) -> *mut unichar_t;
}
extern "C" {
    pub fn uc_copyn(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut unichar_t;
}
extern "C" {
    pub fn uc_copy(arg1: *const ::std::os::raw::c_char) -> *mut unichar_t;
}
extern "C" {
    pub fn u_concat(arg1: *const unichar_t, arg2: *const unichar_t) -> *mut unichar_t;
}
extern "C" {
    pub fn cu_copyn(
        pt: *const unichar_t,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cu_copy(arg1: *const unichar_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn vsmprintf(
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn smprintf(fmt: *const ::std::os::raw::c_char, ...) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn uc_strcmp(
        arg1: *const unichar_t,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn u_strcmp(arg1: *const unichar_t, arg2: *const unichar_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn uc_strncmp(
        arg1: *const unichar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn u_strncmp(
        arg1: *const unichar_t,
        arg2: *const unichar_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn uc_strmatch(
        arg1: *const unichar_t,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn uc_strnmatch(
        arg1: *const unichar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn u_strnmatch(
        str1: *const unichar_t,
        str2: *const unichar_t,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn u_strmatch(arg1: *const unichar_t, arg2: *const unichar_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strmatch(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strnmatch(
        str1: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uc_strcpy(arg1: *mut unichar_t, arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn cu_strcpy(arg1: *mut ::std::os::raw::c_char, arg2: *const unichar_t);
}
extern "C" {
    pub fn u_strcpy(arg1: *mut unichar_t, arg2: *const unichar_t);
}
extern "C" {
    pub fn u_strncpy(arg1: *mut unichar_t, arg2: *const unichar_t, arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn cu_strncpy(
        to: *mut ::std::os::raw::c_char,
        from: *const unichar_t,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn uc_strncpy(
        to: *mut unichar_t,
        from: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Like strncpy but passing a null 'from' will simply null terminate"]
    #[doc = " to[0] to give a blank result rather than a crash."]
    pub fn cc_strncpy(
        to: *mut ::std::os::raw::c_char,
        from: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn uc_strcat(arg1: *mut unichar_t, arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn uc_strncat(
        arg1: *mut unichar_t,
        arg2: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cu_strcat(arg1: *mut ::std::os::raw::c_char, arg2: *const unichar_t);
}
extern "C" {
    pub fn cu_strncat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const unichar_t,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn u_strcat(arg1: *mut unichar_t, arg2: *const unichar_t);
}
extern "C" {
    pub fn u_strncat(arg1: *mut unichar_t, arg2: *const unichar_t, len: ::std::os::raw::c_int);
}
extern "C" {
    pub fn u_strlen(arg1: *const unichar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Like strlen() but passing a null pointer gets a 0 length"]
    pub fn c_strlen(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn u_strchr(arg1: *const unichar_t, arg2: unichar_t) -> *mut unichar_t;
}
extern "C" {
    pub fn u_strrchr(arg1: *const unichar_t, arg2: unichar_t) -> *mut unichar_t;
}
extern "C" {
    pub fn uc_strstr(arg1: *const unichar_t, arg2: *const ::std::os::raw::c_char)
        -> *mut unichar_t;
}
extern "C" {
    pub fn u_strstr(arg1: *const unichar_t, arg2: *const unichar_t) -> *mut unichar_t;
}
extern "C" {
    pub fn uc_strstrmatch(
        arg1: *const unichar_t,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut unichar_t;
}
extern "C" {
    pub fn u_strstrmatch(arg1: *const unichar_t, arg2: *const unichar_t) -> *mut unichar_t;
}
extern "C" {
    pub fn strstrmatch(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_to_c(arg1: *const unichar_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn c_to_u(arg1: *const ::std::os::raw::c_char) -> *mut unichar_t;
}
extern "C" {
    pub fn u_strtoul(
        arg1: *const unichar_t,
        arg2: *mut *mut unichar_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn u_strtol(
        arg1: *const unichar_t,
        arg2: *mut *mut unichar_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn u_strtod(arg1: *const unichar_t, arg2: *mut *mut unichar_t) -> f64;
}
extern "C" {
    pub fn c_itostr(v: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstart(
        initial: *const ::std::os::raw::c_char,
        full: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstartmatch(
        initial: *const ::std::os::raw::c_char,
        full: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_strstartmatch(initial: *const unichar_t, full: *const unichar_t) -> *mut unichar_t;
}
extern "C" {
    pub fn cu_strstartmatch(
        initial: *const ::std::os::raw::c_char,
        full: *const unichar_t,
    ) -> *mut unichar_t;
}
extern "C" {
    pub fn utf8_ildb(utf8_text: *mut *const ::std::os::raw::c_char) -> int32;
}
extern "C" {
    pub fn utf8_idpb(
        utf8_text: *mut ::std::os::raw::c_char,
        ch: uint32,
        flags: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn utf8_db(utf8_text: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn utf8_ib(utf8_text: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn utf8_valid(str_: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utf8_truncatevalid(str_: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn latin1_2_utf8_strcpy(
        utf8buf: *mut ::std::os::raw::c_char,
        lbuf: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn latin1_2_utf8_copy(lbuf: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn utf8_2_latin1_copy(
        utf8buf: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn utf8_strlen(utf8_str: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn utf82u_strlen(utf8_str: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn utf8_strncpy(
        to: *mut ::std::os::raw::c_char,
        from: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn def2utf8_copy(from: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn utf82def_copy(ufrom: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn utf8_strchr(
        utf8_str: *const ::std::os::raw::c_char,
        search_char: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn utf82U_strncpy(
        ubuf: *mut unichar_t,
        utf8buf: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut unichar_t;
}
extern "C" {
    pub fn utf82u_strcpy(
        ubuf: *mut unichar_t,
        utf8buf: *const ::std::os::raw::c_char,
    ) -> *mut unichar_t;
}
extern "C" {
    pub fn utf82u_strcat(ubuf: *mut unichar_t, utf8buf: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn utf82u_copyn(
        utf8buf: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut unichar_t;
}
extern "C" {
    pub fn utf82u_copy(utf8buf: *const ::std::os::raw::c_char) -> *mut unichar_t;
}
extern "C" {
    pub fn u2utf8_strcpy(
        utf8buf: *mut ::std::os::raw::c_char,
        ubuf: *const unichar_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn u2utf8_strncpy(
        utf8buf: *mut ::std::os::raw::c_char,
        ubuf: *const unichar_t,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn u2utf8_copy(ubuf: *const unichar_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn u2utf8_copyn(
        ubuf: *const unichar_t,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn encoding2u_strncpy(
        uto: *mut unichar_t,
        from: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
        cs: encoding,
    ) -> *mut unichar_t;
}
extern "C" {
    pub fn u2encoding_strncpy(
        to: *mut ::std::os::raw::c_char,
        ufrom: *const unichar_t,
        n: size_t,
        cs: encoding,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn def2u_strncpy(
        uto: *mut unichar_t,
        from: *const ::std::os::raw::c_char,
        n: size_t,
    ) -> *mut unichar_t;
}
extern "C" {
    pub fn u2def_strncpy(
        to: *mut ::std::os::raw::c_char,
        ufrom: *const unichar_t,
        n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn def2u_copy(from: *const ::std::os::raw::c_char) -> *mut unichar_t;
}
extern "C" {
    pub fn u2def_copy(ufrom: *const unichar_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn uAllAscii(str_: *const unichar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AllAscii(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn StripToASCII(utf8_str: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn copytolower(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return true if the haystack plain string ends with the string"]
    #[doc = " needle. Return 0 otherwise."]
    #[doc = ""]
    #[doc = " Needles which are larger than the haystack are handled."]
    #[doc = ""]
    #[doc = " No new strings are allocated, freed, or returned."]
    pub fn endswith(
        haystack: *const ::std::os::raw::c_char,
        needle: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn endswithi(
        haystack: *const ::std::os::raw::c_char,
        needle: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn endswithi_partialExtension(
        haystack: *const ::std::os::raw::c_char,
        needle: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove trailing \\n or \\r from the given string. No memory"]
    #[doc = " allocations are performed, null is injected over these terminators"]
    #[doc = " to trim the string."]
    #[doc = ""]
    #[doc = " This function is designed to be impotent if called with a string"]
    #[doc = " that does not end with \\n or \\r. ie, you don't need to redundantly"]
    #[doc = " check if there is a newline at the end of string and not call here"]
    #[doc = " if there is no newline. You can just call here with any string and"]
    #[doc = " be assured that afterwards there will be no trailing newline or"]
    #[doc = " carrage return character found at the end of the string pointed to"]
    #[doc = " by 'p'."]
    pub fn chomp(p: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return true if the haystack unicode string ends with the string needle."]
    #[doc = " Return 0 otherwise."]
    #[doc = ""]
    #[doc = " Needles which are larger than the haystack are handled."]
    #[doc = ""]
    #[doc = " No new strings are allocated, freed, or returned."]
    pub fn u_endswith(
        haystack: *const unichar_t,
        needle: *const unichar_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn u_startswith(
        haystack: *const unichar_t,
        needle: *const unichar_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uc_startswith(
        haystack: *const unichar_t,
        needle: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " In the string 's' replace all occurances of 'orig' with 'replacement'."]
    #[doc = " If you set free_s to true then the string 's' will be freed by this function."]
    #[doc = " Normally you want to set free_s to 0 to avoid that. The case you will want to"]
    #[doc = " use free_s to 1 is chaining many calls like:"]
    #[doc = ""]
    #[doc = " char* s = copy( input );"]
    #[doc = " s = str_replace_all( s, \"foo\", \"bar\", 1 );"]
    #[doc = " s = str_replace_all( s, \"baz\", \"gah\", 1 );"]
    #[doc = " // use s"]
    #[doc = " free(s);"]
    #[doc = " // no leaks in the above."]
    #[doc = ""]
    #[doc = " Note that 's' is first copied before the first call to replace_all in the above"]
    #[doc = " so it can be freed without concern. This also allows the ordering of replace_all"]
    #[doc = " in the above to be changed without having to worry about the free_s flag."]
    pub fn str_replace_all(
        s: *mut ::std::os::raw::c_char,
        orig: *mut ::std::os::raw::c_char,
        replacement: *mut ::std::os::raw::c_char,
        free_s: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn toint(v: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tostr(v: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lconv {
    pub decimal_point: *mut ::std::os::raw::c_char,
    pub thousands_sep: *mut ::std::os::raw::c_char,
    pub grouping: *mut ::std::os::raw::c_char,
    pub int_curr_symbol: *mut ::std::os::raw::c_char,
    pub currency_symbol: *mut ::std::os::raw::c_char,
    pub mon_decimal_point: *mut ::std::os::raw::c_char,
    pub mon_thousands_sep: *mut ::std::os::raw::c_char,
    pub mon_grouping: *mut ::std::os::raw::c_char,
    pub positive_sign: *mut ::std::os::raw::c_char,
    pub negative_sign: *mut ::std::os::raw::c_char,
    pub int_frac_digits: ::std::os::raw::c_char,
    pub frac_digits: ::std::os::raw::c_char,
    pub p_cs_precedes: ::std::os::raw::c_char,
    pub p_sep_by_space: ::std::os::raw::c_char,
    pub n_cs_precedes: ::std::os::raw::c_char,
    pub n_sep_by_space: ::std::os::raw::c_char,
    pub p_sign_posn: ::std::os::raw::c_char,
    pub n_sign_posn: ::std::os::raw::c_char,
    pub int_p_cs_precedes: ::std::os::raw::c_char,
    pub int_p_sep_by_space: ::std::os::raw::c_char,
    pub int_n_cs_precedes: ::std::os::raw::c_char,
    pub int_n_sep_by_space: ::std::os::raw::c_char,
    pub int_p_sign_posn: ::std::os::raw::c_char,
    pub int_n_sign_posn: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_lconv() {
    assert_eq!(
        ::std::mem::size_of::<lconv>(),
        96usize,
        concat!("Size of: ", stringify!(lconv))
    );
    assert_eq!(
        ::std::mem::align_of::<lconv>(),
        8usize,
        concat!("Alignment of ", stringify!(lconv))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).decimal_point as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(decimal_point)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).thousands_sep as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(thousands_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).grouping as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(grouping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_curr_symbol as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_curr_symbol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).currency_symbol as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(currency_symbol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).mon_decimal_point as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(mon_decimal_point)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).mon_thousands_sep as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(mon_thousands_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).mon_grouping as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(mon_grouping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).positive_sign as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(positive_sign)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).negative_sign as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(negative_sign)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_frac_digits as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_frac_digits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).frac_digits as *const _ as usize },
        81usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(frac_digits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).p_cs_precedes as *const _ as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(p_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).p_sep_by_space as *const _ as usize },
        83usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(p_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).n_cs_precedes as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(n_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).n_sep_by_space as *const _ as usize },
        85usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(n_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).p_sign_posn as *const _ as usize },
        86usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(p_sign_posn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).n_sign_posn as *const _ as usize },
        87usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(n_sign_posn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_p_cs_precedes as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_p_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_p_sep_by_space as *const _ as usize },
        89usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_p_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_n_cs_precedes as *const _ as usize },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_n_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_n_sep_by_space as *const _ as usize },
        91usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_n_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_p_sign_posn as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_p_sign_posn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_n_sign_posn as *const _ as usize },
        93usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_n_sign_posn)
        )
    );
}
extern "C" {
    pub fn setlocale(
        __category: ::std::os::raw::c_int,
        __locale: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn localeconv() -> *mut lconv;
}
extern "C" {
    pub fn newlocale(
        __category_mask: ::std::os::raw::c_int,
        __locale: *const ::std::os::raw::c_char,
        __base: locale_t,
    ) -> locale_t;
}
extern "C" {
    pub fn duplocale(__dataset: locale_t) -> locale_t;
}
extern "C" {
    pub fn freelocale(__dataset: locale_t);
}
extern "C" {
    pub fn uselocale(__dataset: locale_t) -> locale_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bezctx {
    _unused: [u8; 0],
}
pub type bezctx = _bezctx;
extern "C" {
    pub fn new_bezctx() -> *mut bezctx;
}
extern "C" {
    pub fn bezctx_moveto(bc: *mut bezctx, x: f64, y: f64, is_open: ::std::os::raw::c_int);
}
extern "C" {
    pub fn bezctx_lineto(bc: *mut bezctx, x: f64, y: f64);
}
extern "C" {
    pub fn bezctx_quadto(bc: *mut bezctx, x1: f64, y1: f64, x2: f64, y2: f64);
}
extern "C" {
    pub fn bezctx_curveto(bc: *mut bezctx, x1: f64, y1: f64, x2: f64, y2: f64, x3: f64, y3: f64);
}
extern "C" {
    pub fn bezctx_mark_knot(bc: *mut bezctx, knot_idx: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spiro_cp {
    pub x: f64,
    pub y: f64,
    pub ty: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_spiro_cp() {
    assert_eq!(
        ::std::mem::size_of::<spiro_cp>(),
        24usize,
        concat!("Size of: ", stringify!(spiro_cp))
    );
    assert_eq!(
        ::std::mem::align_of::<spiro_cp>(),
        8usize,
        concat!("Alignment of ", stringify!(spiro_cp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiro_cp>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spiro_cp),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiro_cp>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spiro_cp),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiro_cp>())).ty as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spiro_cp),
            "::",
            stringify!(ty)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spiro_seg_s {
    pub x: f64,
    pub y: f64,
    pub ty: ::std::os::raw::c_char,
    pub bend_th: f64,
    pub ks: [f64; 4usize],
    pub seg_ch: f64,
    pub seg_th: f64,
    pub l: f64,
}
#[test]
fn bindgen_test_layout_spiro_seg_s() {
    assert_eq!(
        ::std::mem::size_of::<spiro_seg_s>(),
        88usize,
        concat!("Size of: ", stringify!(spiro_seg_s))
    );
    assert_eq!(
        ::std::mem::align_of::<spiro_seg_s>(),
        8usize,
        concat!("Alignment of ", stringify!(spiro_seg_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiro_seg_s>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spiro_seg_s),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiro_seg_s>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spiro_seg_s),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiro_seg_s>())).ty as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spiro_seg_s),
            "::",
            stringify!(ty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiro_seg_s>())).bend_th as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spiro_seg_s),
            "::",
            stringify!(bend_th)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiro_seg_s>())).ks as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spiro_seg_s),
            "::",
            stringify!(ks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiro_seg_s>())).seg_ch as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(spiro_seg_s),
            "::",
            stringify!(seg_ch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiro_seg_s>())).seg_th as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(spiro_seg_s),
            "::",
            stringify!(seg_th)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiro_seg_s>())).l as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(spiro_seg_s),
            "::",
            stringify!(l)
        )
    );
}
pub type spiro_seg = spiro_seg_s;
extern "C" {
    pub fn run_spiro(src: *const spiro_cp, n: ::std::os::raw::c_int) -> *mut spiro_seg;
}
extern "C" {
    pub fn free_spiro(s: *mut spiro_seg);
}
extern "C" {
    pub fn spiro_to_bpath(s: *const spiro_seg, n: ::std::os::raw::c_int, bc: *mut bezctx);
}
extern "C" {
    pub fn get_knot_th(s: *const spiro_seg, i: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn run_spiro0(
        src: *const spiro_cp,
        dm: *mut f64,
        ncq: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
    ) -> *mut spiro_seg;
}
extern "C" {
    pub fn spiro_to_bpath0(
        src: *const spiro_cp,
        s: *const spiro_seg,
        dm: *mut f64,
        ncq: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        bc: *mut bezctx,
    );
}
extern "C" {
    pub fn spiroreverse(src: *mut spiro_cp, n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LibSpiroVersion() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn TaggedSpiroCPsToBezier(spiros: *mut spiro_cp, bc: *mut bezctx);
}
extern "C" {
    pub fn SpiroCPsToBezier(
        spiros: *mut spiro_cp,
        n: ::std::os::raw::c_int,
        isclosed: ::std::os::raw::c_int,
        bc: *mut bezctx,
    );
}
extern "C" {
    pub fn TaggedSpiroCPsToBezier0(spiros: *mut spiro_cp, bc: *mut bezctx)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SpiroCPsToBezier0(
        spiros: *mut spiro_cp,
        n: ::std::os::raw::c_int,
        isclosed: ::std::os::raw::c_int,
        bc: *mut bezctx,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TaggedSpiroCPsToBezier1(
        spiros: *mut spiro_cp,
        bc: *mut bezctx,
        done: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SpiroCPsToBezier1(
        spiros: *mut spiro_cp,
        n: ::std::os::raw::c_int,
        isclosed: ::std::os::raw::c_int,
        bc: *mut bezctx,
        done: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn TaggedSpiroCPsToBezier2(
        spiros: *mut spiro_cp,
        ncq: ::std::os::raw::c_int,
        bc: *mut bezctx,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SpiroCPsToBezier2(
        spiros: *mut spiro_cp,
        n: ::std::os::raw::c_int,
        ncq: ::std::os::raw::c_int,
        isclosed: ::std::os::raw::c_int,
        bc: *mut bezctx,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipoint {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ipoint() {
    assert_eq!(
        ::std::mem::size_of::<ipoint>(),
        8usize,
        concat!("Size of: ", stringify!(ipoint))
    );
    assert_eq!(
        ::std::mem::align_of::<ipoint>(),
        4usize,
        concat!("Alignment of ", stringify!(ipoint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipoint>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ipoint), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipoint>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(ipoint), "::", stringify!(y))
    );
}
pub type IPoint = ipoint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct basepoint {
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout_basepoint() {
    assert_eq!(
        ::std::mem::size_of::<basepoint>(),
        16usize,
        concat!("Size of: ", stringify!(basepoint))
    );
    assert_eq!(
        ::std::mem::align_of::<basepoint>(),
        8usize,
        concat!("Alignment of ", stringify!(basepoint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<basepoint>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(basepoint),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<basepoint>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(basepoint),
            "::",
            stringify!(y)
        )
    );
}
pub type BasePoint = basepoint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dbasepoint {
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout_dbasepoint() {
    assert_eq!(
        ::std::mem::size_of::<dbasepoint>(),
        16usize,
        concat!("Size of: ", stringify!(dbasepoint))
    );
    assert_eq!(
        ::std::mem::align_of::<dbasepoint>(),
        8usize,
        concat!("Alignment of ", stringify!(dbasepoint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dbasepoint>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dbasepoint),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dbasepoint>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dbasepoint),
            "::",
            stringify!(y)
        )
    );
}
pub type DBasePoint = dbasepoint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dbounds {
    pub minx: f64,
    pub maxx: f64,
    pub miny: f64,
    pub maxy: f64,
}
#[test]
fn bindgen_test_layout_dbounds() {
    assert_eq!(
        ::std::mem::size_of::<dbounds>(),
        32usize,
        concat!("Size of: ", stringify!(dbounds))
    );
    assert_eq!(
        ::std::mem::align_of::<dbounds>(),
        8usize,
        concat!("Alignment of ", stringify!(dbounds))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dbounds>())).minx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dbounds),
            "::",
            stringify!(minx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dbounds>())).maxx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dbounds),
            "::",
            stringify!(maxx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dbounds>())).miny as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dbounds),
            "::",
            stringify!(miny)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dbounds>())).maxy as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dbounds),
            "::",
            stringify!(maxy)
        )
    );
}
pub type DBounds = dbounds;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibounds {
    pub minx: ::std::os::raw::c_int,
    pub maxx: ::std::os::raw::c_int,
    pub miny: ::std::os::raw::c_int,
    pub maxy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ibounds() {
    assert_eq!(
        ::std::mem::size_of::<ibounds>(),
        16usize,
        concat!("Size of: ", stringify!(ibounds))
    );
    assert_eq!(
        ::std::mem::align_of::<ibounds>(),
        4usize,
        concat!("Alignment of ", stringify!(ibounds))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibounds>())).minx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibounds),
            "::",
            stringify!(minx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibounds>())).maxx as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibounds),
            "::",
            stringify!(maxx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibounds>())).miny as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibounds),
            "::",
            stringify!(miny)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibounds>())).maxy as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibounds),
            "::",
            stringify!(maxy)
        )
    );
}
pub type IBounds = ibounds;
pub const val_type_v_int: val_type = 0;
pub const val_type_v_real: val_type = 1;
pub const val_type_v_str: val_type = 2;
pub const val_type_v_unicode: val_type = 3;
pub const val_type_v_lval: val_type = 4;
pub const val_type_v_arr: val_type = 5;
pub const val_type_v_arrfree: val_type = 6;
pub const val_type_v_void: val_type = 7;
pub type val_type = ::std::os::raw::c_uint;
pub const val_flags_vf_none: val_flags = 0;
pub const val_flags_vf_dontfree: val_flags = 2;
pub type val_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct val {
    pub type_: val_type,
    pub flags: val_flags,
    pub u: val__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union val__bindgen_ty_1 {
    pub ival: ::std::os::raw::c_int,
    pub fval: f64,
    pub sval: *mut ::std::os::raw::c_char,
    pub lval: *mut val,
    pub aval: *mut array,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_val__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<val__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(val__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<val__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(val__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<val__bindgen_ty_1>())).ival as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(val__bindgen_ty_1),
            "::",
            stringify!(ival)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<val__bindgen_ty_1>())).fval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(val__bindgen_ty_1),
            "::",
            stringify!(fval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<val__bindgen_ty_1>())).sval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(val__bindgen_ty_1),
            "::",
            stringify!(sval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<val__bindgen_ty_1>())).lval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(val__bindgen_ty_1),
            "::",
            stringify!(lval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<val__bindgen_ty_1>())).aval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(val__bindgen_ty_1),
            "::",
            stringify!(aval)
        )
    );
}
#[test]
fn bindgen_test_layout_val() {
    assert_eq!(
        ::std::mem::size_of::<val>(),
        16usize,
        concat!("Size of: ", stringify!(val))
    );
    assert_eq!(
        ::std::mem::align_of::<val>(),
        8usize,
        concat!("Alignment of ", stringify!(val))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<val>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(val),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<val>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(val),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<val>())).u as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(val), "::", stringify!(u))
    );
}
pub type Val = val;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psdict {
    pub cnt: ::std::os::raw::c_int,
    pub next: ::std::os::raw::c_int,
    pub keys: *mut *mut ::std::os::raw::c_char,
    pub values: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_psdict() {
    assert_eq!(
        ::std::mem::size_of::<psdict>(),
        24usize,
        concat!("Size of: ", stringify!(psdict))
    );
    assert_eq!(
        ::std::mem::align_of::<psdict>(),
        8usize,
        concat!("Alignment of ", stringify!(psdict))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<psdict>())).cnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(psdict),
            "::",
            stringify!(cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<psdict>())).next as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(psdict),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<psdict>())).keys as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(psdict),
            "::",
            stringify!(keys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<psdict>())).values as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(psdict),
            "::",
            stringify!(values)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pschars {
    pub cnt: ::std::os::raw::c_int,
    pub next: ::std::os::raw::c_int,
    pub keys: *mut *mut ::std::os::raw::c_char,
    pub values: *mut *mut uint8,
    pub lens: *mut ::std::os::raw::c_int,
    pub bias: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pschars() {
    assert_eq!(
        ::std::mem::size_of::<pschars>(),
        40usize,
        concat!("Size of: ", stringify!(pschars))
    );
    assert_eq!(
        ::std::mem::align_of::<pschars>(),
        8usize,
        concat!("Alignment of ", stringify!(pschars))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pschars>())).cnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pschars),
            "::",
            stringify!(cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pschars>())).next as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pschars),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pschars>())).keys as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pschars),
            "::",
            stringify!(keys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pschars>())).values as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pschars),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pschars>())).lens as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pschars),
            "::",
            stringify!(lens)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pschars>())).bias as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pschars),
            "::",
            stringify!(bias)
        )
    );
}
pub const linejoin_lj_miter: linejoin = 0;
pub const linejoin_lj_round: linejoin = 1;
pub const linejoin_lj_bevel: linejoin = 2;
pub const linejoin_lj_miterclip: linejoin = 3;
pub const linejoin_lj_nib: linejoin = 4;
pub const linejoin_lj_arcs: linejoin = 5;
pub const linejoin_lj_inherited: linejoin = 6;
pub type linejoin = ::std::os::raw::c_uint;
pub const linecap_lc_butt: linecap = 0;
pub const linecap_lc_round: linecap = 1;
pub const linecap_lc_square: linecap = 2;
pub const linecap_lc_nib: linecap = 3;
pub const linecap_lc_bevel: linecap = 4;
pub const linecap_lc_inherited: linecap = 5;
pub type linecap = ::std::os::raw::c_uint;
pub const stroke_rmov_srmov_layer: stroke_rmov = 0;
pub const stroke_rmov_srmov_contour: stroke_rmov = 1;
pub const stroke_rmov_srmov_none: stroke_rmov = 2;
pub type stroke_rmov = ::std::os::raw::c_uint;
pub const stroke_arclimit_sal_auto: stroke_arclimit = 0;
pub const stroke_arclimit_sal_svg2: stroke_arclimit = 1;
pub const stroke_arclimit_sal_ratio: stroke_arclimit = 2;
pub type stroke_arclimit = ::std::os::raw::c_uint;
pub const spreadMethod_sm_pad: spreadMethod = 0;
pub const spreadMethod_sm_reflect: spreadMethod = 1;
pub const spreadMethod_sm_repeat: spreadMethod = 2;
pub type spreadMethod = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grad_stops {
    pub offset: f64,
    pub col: uint32,
    pub opacity: f64,
}
#[test]
fn bindgen_test_layout_grad_stops() {
    assert_eq!(
        ::std::mem::size_of::<grad_stops>(),
        24usize,
        concat!("Size of: ", stringify!(grad_stops))
    );
    assert_eq!(
        ::std::mem::align_of::<grad_stops>(),
        8usize,
        concat!("Alignment of ", stringify!(grad_stops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<grad_stops>())).offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(grad_stops),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<grad_stops>())).col as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(grad_stops),
            "::",
            stringify!(col)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<grad_stops>())).opacity as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(grad_stops),
            "::",
            stringify!(opacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gradient {
    pub start: BasePoint,
    pub stop: BasePoint,
    pub radius: f64,
    pub sm: spreadMethod,
    pub stop_cnt: ::std::os::raw::c_int,
    pub grad_stops: *mut grad_stops,
}
#[test]
fn bindgen_test_layout_gradient() {
    assert_eq!(
        ::std::mem::size_of::<gradient>(),
        56usize,
        concat!("Size of: ", stringify!(gradient))
    );
    assert_eq!(
        ::std::mem::align_of::<gradient>(),
        8usize,
        concat!("Alignment of ", stringify!(gradient))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gradient>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gradient),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gradient>())).stop as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gradient),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gradient>())).radius as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gradient),
            "::",
            stringify!(radius)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gradient>())).sm as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(gradient),
            "::",
            stringify!(sm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gradient>())).stop_cnt as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(gradient),
            "::",
            stringify!(stop_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gradient>())).grad_stops as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(gradient),
            "::",
            stringify!(grad_stops)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pattern {
    pub pattern: *mut ::std::os::raw::c_char,
    pub width: f64,
    pub height: f64,
    pub transform: [f64; 6usize],
    pub pat: *mut bdfchar,
    pub invtrans: [f64; 6usize],
    pub bminx: ::std::os::raw::c_int,
    pub bminy: ::std::os::raw::c_int,
    pub bwidth: ::std::os::raw::c_int,
    pub bheight: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pattern() {
    assert_eq!(
        ::std::mem::size_of::<pattern>(),
        144usize,
        concat!("Size of: ", stringify!(pattern))
    );
    assert_eq!(
        ::std::mem::align_of::<pattern>(),
        8usize,
        concat!("Alignment of ", stringify!(pattern))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pattern>())).pattern as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pattern),
            "::",
            stringify!(pattern)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pattern>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pattern),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pattern>())).height as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pattern),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pattern>())).transform as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pattern),
            "::",
            stringify!(transform)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pattern>())).pat as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(pattern),
            "::",
            stringify!(pat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pattern>())).invtrans as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(pattern),
            "::",
            stringify!(invtrans)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pattern>())).bminx as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(pattern),
            "::",
            stringify!(bminx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pattern>())).bminy as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(pattern),
            "::",
            stringify!(bminy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pattern>())).bwidth as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(pattern),
            "::",
            stringify!(bwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pattern>())).bheight as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(pattern),
            "::",
            stringify!(bheight)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct brush {
    pub col: uint32,
    pub opacity: f32,
    pub pattern: *mut pattern,
    pub gradient: *mut gradient,
}
#[test]
fn bindgen_test_layout_brush() {
    assert_eq!(
        ::std::mem::size_of::<brush>(),
        24usize,
        concat!("Size of: ", stringify!(brush))
    );
    assert_eq!(
        ::std::mem::align_of::<brush>(),
        8usize,
        concat!("Alignment of ", stringify!(brush))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<brush>())).col as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(brush),
            "::",
            stringify!(col)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<brush>())).opacity as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(brush),
            "::",
            stringify!(opacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<brush>())).pattern as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(brush),
            "::",
            stringify!(pattern)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<brush>())).gradient as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(brush),
            "::",
            stringify!(gradient)
        )
    );
}
pub type DashType = ::std::os::raw::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pen {
    pub brush: brush,
    pub linejoin: uint8,
    pub linecap: uint8,
    pub width: f32,
    pub trans: [f64; 4usize],
    pub dashes: [DashType; 8usize],
}
#[test]
fn bindgen_test_layout_pen() {
    assert_eq!(
        ::std::mem::size_of::<pen>(),
        72usize,
        concat!("Size of: ", stringify!(pen))
    );
    assert_eq!(
        ::std::mem::align_of::<pen>(),
        8usize,
        concat!("Alignment of ", stringify!(pen))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pen>())).brush as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pen),
            "::",
            stringify!(brush)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pen>())).linejoin as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pen),
            "::",
            stringify!(linejoin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pen>())).linecap as *const _ as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(pen),
            "::",
            stringify!(linecap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pen>())).width as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(pen),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pen>())).trans as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pen),
            "::",
            stringify!(trans)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pen>())).dashes as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pen),
            "::",
            stringify!(dashes)
        )
    );
}
pub const si_type_si_round: si_type = 0;
pub const si_type_si_calligraphic: si_type = 1;
pub const si_type_si_nib: si_type = 2;
pub const si_type_si_centerline: si_type = 3;
pub type si_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct strokeinfo {
    pub width: f64,
    pub join: linejoin,
    pub cap: linecap,
    pub stroke_type: si_type,
    pub rmov: stroke_rmov,
    pub al: stroke_arclimit,
    pub removeinternal: ::std::os::raw::c_int,
    pub removeexternal: ::std::os::raw::c_int,
    pub simplify: ::std::os::raw::c_int,
    pub extrema: ::std::os::raw::c_int,
    pub leave_users_center: ::std::os::raw::c_int,
    pub jlrelative: ::std::os::raw::c_int,
    pub ecrelative: ::std::os::raw::c_int,
    pub penangle: f64,
    pub height: f64,
    pub extendcap: f64,
    pub joinlimit: f64,
    pub accuracy_target: f64,
    pub nib: *mut splinepointlist,
    pub radius2: f64,
    pub pressure1: ::std::os::raw::c_int,
    pub pressure2: ::std::os::raw::c_int,
    pub data: *mut ::std::os::raw::c_void,
    pub factor: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, spline: *mut spline, t: f64) -> f64,
    >,
}
#[test]
fn bindgen_test_layout_strokeinfo() {
    assert_eq!(
        ::std::mem::size_of::<strokeinfo>(),
        136usize,
        concat!("Size of: ", stringify!(strokeinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<strokeinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(strokeinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strokeinfo>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(strokeinfo),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strokeinfo>())).join as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(strokeinfo),
            "::",
            stringify!(join)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strokeinfo>())).cap as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(strokeinfo),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strokeinfo>())).stroke_type as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(strokeinfo),
            "::",
            stringify!(stroke_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strokeinfo>())).rmov as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(strokeinfo),
            "::",
            stringify!(rmov)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strokeinfo>())).al as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(strokeinfo),
            "::",
            stringify!(al)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strokeinfo>())).removeinternal as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(strokeinfo),
            "::",
            stringify!(removeinternal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strokeinfo>())).removeexternal as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(strokeinfo),
            "::",
            stringify!(removeexternal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strokeinfo>())).simplify as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(strokeinfo),
            "::",
            stringify!(simplify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strokeinfo>())).extrema as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(strokeinfo),
            "::",
            stringify!(extrema)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strokeinfo>())).leave_users_center as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(strokeinfo),
            "::",
            stringify!(leave_users_center)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strokeinfo>())).jlrelative as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(strokeinfo),
            "::",
            stringify!(jlrelative)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strokeinfo>())).ecrelative as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(strokeinfo),
            "::",
            stringify!(ecrelative)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strokeinfo>())).penangle as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(strokeinfo),
            "::",
            stringify!(penangle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strokeinfo>())).height as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(strokeinfo),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strokeinfo>())).extendcap as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(strokeinfo),
            "::",
            stringify!(extendcap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strokeinfo>())).joinlimit as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(strokeinfo),
            "::",
            stringify!(joinlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strokeinfo>())).accuracy_target as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(strokeinfo),
            "::",
            stringify!(accuracy_target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strokeinfo>())).nib as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(strokeinfo),
            "::",
            stringify!(nib)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strokeinfo>())).radius2 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(strokeinfo),
            "::",
            stringify!(radius2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strokeinfo>())).pressure1 as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(strokeinfo),
            "::",
            stringify!(pressure1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strokeinfo>())).pressure2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(strokeinfo),
            "::",
            stringify!(pressure2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strokeinfo>())).data as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(strokeinfo),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strokeinfo>())).factor as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(strokeinfo),
            "::",
            stringify!(factor)
        )
    );
}
pub type StrokeInfo = strokeinfo;
extern "C" {
    pub fn InitializeStrokeInfo(sip: *mut StrokeInfo) -> *mut StrokeInfo;
}
extern "C" {
    pub fn SITranslatePSArgs(sip: *mut StrokeInfo, lj: linejoin, lc: linecap);
}
pub const overlap_type_over_remove: overlap_type = 0;
pub const overlap_type_over_rmselected: overlap_type = 1;
pub const overlap_type_over_intersect: overlap_type = 2;
pub const overlap_type_over_intersel: overlap_type = 3;
pub const overlap_type_over_exclude: overlap_type = 4;
pub const overlap_type_over_findinter: overlap_type = 5;
pub const overlap_type_over_fisel: overlap_type = 6;
pub type overlap_type = ::std::os::raw::c_uint;
pub const simpify_flags_sf_cleanup: simpify_flags = -1;
pub const simpify_flags_sf_normal: simpify_flags = 0;
pub const simpify_flags_sf_ignoreslopes: simpify_flags = 1;
pub const simpify_flags_sf_ignoreextremum: simpify_flags = 2;
pub const simpify_flags_sf_smoothcurves: simpify_flags = 4;
pub const simpify_flags_sf_choosehv: simpify_flags = 8;
pub const simpify_flags_sf_forcelines: simpify_flags = 16;
pub const simpify_flags_sf_nearlyhvlines: simpify_flags = 32;
pub const simpify_flags_sf_mergelines: simpify_flags = 64;
pub const simpify_flags_sf_setstart2extremum: simpify_flags = 128;
pub const simpify_flags_sf_rmsingletonpoints: simpify_flags = 256;
pub type simpify_flags = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct simplifyinfo {
    pub flags: ::std::os::raw::c_int,
    pub err: f64,
    pub tan_bounds: f64,
    pub linefixup: f64,
    pub linelenmax: f64,
    pub set_as_default: ::std::os::raw::c_int,
    pub check_selected_contours: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_simplifyinfo() {
    assert_eq!(
        ::std::mem::size_of::<simplifyinfo>(),
        48usize,
        concat!("Size of: ", stringify!(simplifyinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<simplifyinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(simplifyinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<simplifyinfo>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simplifyinfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<simplifyinfo>())).err as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(simplifyinfo),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<simplifyinfo>())).tan_bounds as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(simplifyinfo),
            "::",
            stringify!(tan_bounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<simplifyinfo>())).linefixup as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(simplifyinfo),
            "::",
            stringify!(linefixup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<simplifyinfo>())).linelenmax as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(simplifyinfo),
            "::",
            stringify!(linelenmax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<simplifyinfo>())).set_as_default as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(simplifyinfo),
            "::",
            stringify!(set_as_default)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<simplifyinfo>())).check_selected_contours as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(simplifyinfo),
            "::",
            stringify!(check_selected_contours)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsquash {
    pub lsb_percent: f64,
    pub stem_percent: f64,
    pub counter_percent: f64,
    pub rsb_percent: f64,
}
#[test]
fn bindgen_test_layout_hsquash() {
    assert_eq!(
        ::std::mem::size_of::<hsquash>(),
        32usize,
        concat!("Size of: ", stringify!(hsquash))
    );
    assert_eq!(
        ::std::mem::align_of::<hsquash>(),
        8usize,
        concat!("Alignment of ", stringify!(hsquash))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hsquash>())).lsb_percent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hsquash),
            "::",
            stringify!(lsb_percent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hsquash>())).stem_percent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hsquash),
            "::",
            stringify!(stem_percent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hsquash>())).counter_percent as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hsquash),
            "::",
            stringify!(counter_percent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hsquash>())).rsb_percent as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hsquash),
            "::",
            stringify!(rsb_percent)
        )
    );
}
pub const serif_type_srf_flat: serif_type = 0;
pub const serif_type_srf_simpleslant: serif_type = 1;
pub const serif_type_srf_complexslant: serif_type = 2;
pub type serif_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct italicinfo {
    pub italic_angle: f64,
    pub xheight_percent: f64,
    pub lc: hsquash,
    pub uc: hsquash,
    pub neither: hsquash,
    pub secondary_serif: serif_type,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub tan_ia: f64,
    pub x_height: f64,
    pub pq_depth: f64,
    pub ascender_height: f64,
    pub emsize: f64,
    pub order2: ::std::os::raw::c_int,
    pub sf: *mut splinefont,
    pub layer: ::std::os::raw::c_int,
    pub serif_extent: f64,
    pub serif_height: f64,
    pub f_start: *mut splinepoint,
    pub f_end: *mut splinepoint,
    pub ff_start1: *mut splinepoint,
    pub ff_end1: *mut splinepoint,
    pub ff_start2: *mut splinepoint,
    pub ff_end2: *mut splinepoint,
    pub f_height: f64,
    pub ff_height: f64,
}
#[test]
fn bindgen_test_layout_italicinfo() {
    assert_eq!(
        ::std::mem::size_of::<italicinfo>(),
        264usize,
        concat!("Size of: ", stringify!(italicinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<italicinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(italicinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<italicinfo>())).italic_angle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(italicinfo),
            "::",
            stringify!(italic_angle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<italicinfo>())).xheight_percent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(italicinfo),
            "::",
            stringify!(xheight_percent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<italicinfo>())).lc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(italicinfo),
            "::",
            stringify!(lc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<italicinfo>())).uc as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(italicinfo),
            "::",
            stringify!(uc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<italicinfo>())).neither as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(italicinfo),
            "::",
            stringify!(neither)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<italicinfo>())).secondary_serif as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(italicinfo),
            "::",
            stringify!(secondary_serif)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<italicinfo>())).tan_ia as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(italicinfo),
            "::",
            stringify!(tan_ia)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<italicinfo>())).x_height as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(italicinfo),
            "::",
            stringify!(x_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<italicinfo>())).pq_depth as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(italicinfo),
            "::",
            stringify!(pq_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<italicinfo>())).ascender_height as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(italicinfo),
            "::",
            stringify!(ascender_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<italicinfo>())).emsize as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(italicinfo),
            "::",
            stringify!(emsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<italicinfo>())).order2 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(italicinfo),
            "::",
            stringify!(order2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<italicinfo>())).sf as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(italicinfo),
            "::",
            stringify!(sf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<italicinfo>())).layer as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(italicinfo),
            "::",
            stringify!(layer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<italicinfo>())).serif_extent as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(italicinfo),
            "::",
            stringify!(serif_extent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<italicinfo>())).serif_height as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(italicinfo),
            "::",
            stringify!(serif_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<italicinfo>())).f_start as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(italicinfo),
            "::",
            stringify!(f_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<italicinfo>())).f_end as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(italicinfo),
            "::",
            stringify!(f_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<italicinfo>())).ff_start1 as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(italicinfo),
            "::",
            stringify!(ff_start1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<italicinfo>())).ff_end1 as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(italicinfo),
            "::",
            stringify!(ff_end1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<italicinfo>())).ff_start2 as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(italicinfo),
            "::",
            stringify!(ff_start2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<italicinfo>())).ff_end2 as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(italicinfo),
            "::",
            stringify!(ff_end2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<italicinfo>())).f_height as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(italicinfo),
            "::",
            stringify!(f_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<italicinfo>())).ff_height as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(italicinfo),
            "::",
            stringify!(ff_height)
        )
    );
}
impl italicinfo {
    #[inline]
    pub fn transform_bottom_serifs(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transform_bottom_serifs(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transform_top_xh_serifs(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transform_top_xh_serifs(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transform_top_as_serifs(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transform_top_as_serifs(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transform_diagon_serifs(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transform_diagon_serifs(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn a_from_d(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_a_from_d(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn f_long_tail(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_f_long_tail(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn f_rotate_top(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_f_rotate_top(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pq_deserif(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pq_deserif(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cyrl_phi(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cyrl_phi(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cyrl_i(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cyrl_i(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cyrl_pi(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cyrl_pi(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cyrl_te(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cyrl_te(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cyrl_sha(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cyrl_sha(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cyrl_dje(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cyrl_dje(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cyrl_dzhe(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cyrl_dzhe(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        transform_bottom_serifs: ::std::os::raw::c_uint,
        transform_top_xh_serifs: ::std::os::raw::c_uint,
        transform_top_as_serifs: ::std::os::raw::c_uint,
        transform_diagon_serifs: ::std::os::raw::c_uint,
        a_from_d: ::std::os::raw::c_uint,
        f_long_tail: ::std::os::raw::c_uint,
        f_rotate_top: ::std::os::raw::c_uint,
        pq_deserif: ::std::os::raw::c_uint,
        cyrl_phi: ::std::os::raw::c_uint,
        cyrl_i: ::std::os::raw::c_uint,
        cyrl_pi: ::std::os::raw::c_uint,
        cyrl_te: ::std::os::raw::c_uint,
        cyrl_sha: ::std::os::raw::c_uint,
        cyrl_dje: ::std::os::raw::c_uint,
        cyrl_dzhe: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let transform_bottom_serifs: u32 =
                unsafe { ::std::mem::transmute(transform_bottom_serifs) };
            transform_bottom_serifs as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let transform_top_xh_serifs: u32 =
                unsafe { ::std::mem::transmute(transform_top_xh_serifs) };
            transform_top_xh_serifs as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let transform_top_as_serifs: u32 =
                unsafe { ::std::mem::transmute(transform_top_as_serifs) };
            transform_top_as_serifs as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let transform_diagon_serifs: u32 =
                unsafe { ::std::mem::transmute(transform_diagon_serifs) };
            transform_diagon_serifs as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let a_from_d: u32 = unsafe { ::std::mem::transmute(a_from_d) };
            a_from_d as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let f_long_tail: u32 = unsafe { ::std::mem::transmute(f_long_tail) };
            f_long_tail as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let f_rotate_top: u32 = unsafe { ::std::mem::transmute(f_rotate_top) };
            f_rotate_top as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let pq_deserif: u32 = unsafe { ::std::mem::transmute(pq_deserif) };
            pq_deserif as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let cyrl_phi: u32 = unsafe { ::std::mem::transmute(cyrl_phi) };
            cyrl_phi as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let cyrl_i: u32 = unsafe { ::std::mem::transmute(cyrl_i) };
            cyrl_i as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let cyrl_pi: u32 = unsafe { ::std::mem::transmute(cyrl_pi) };
            cyrl_pi as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let cyrl_te: u32 = unsafe { ::std::mem::transmute(cyrl_te) };
            cyrl_te as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let cyrl_sha: u32 = unsafe { ::std::mem::transmute(cyrl_sha) };
            cyrl_sha as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let cyrl_dje: u32 = unsafe { ::std::mem::transmute(cyrl_dje) };
            cyrl_dje as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let cyrl_dzhe: u32 = unsafe { ::std::mem::transmute(cyrl_dzhe) };
            cyrl_dzhe as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ItalicInfo = italicinfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bluedata {
    pub xheight: f64,
    pub xheighttop: f64,
    pub caph: f64,
    pub caphtop: f64,
    pub base: f64,
    pub basebelow: f64,
    pub ascent: f64,
    pub descent: f64,
    pub numh: f64,
    pub numhtop: f64,
    pub bluecnt: ::std::os::raw::c_int,
    pub blues: [[f64; 2usize]; 12usize],
}
#[test]
fn bindgen_test_layout_bluedata() {
    assert_eq!(
        ::std::mem::size_of::<bluedata>(),
        280usize,
        concat!("Size of: ", stringify!(bluedata))
    );
    assert_eq!(
        ::std::mem::align_of::<bluedata>(),
        8usize,
        concat!("Alignment of ", stringify!(bluedata))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bluedata>())).xheight as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bluedata),
            "::",
            stringify!(xheight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bluedata>())).xheighttop as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bluedata),
            "::",
            stringify!(xheighttop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bluedata>())).caph as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bluedata),
            "::",
            stringify!(caph)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bluedata>())).caphtop as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bluedata),
            "::",
            stringify!(caphtop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bluedata>())).base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bluedata),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bluedata>())).basebelow as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bluedata),
            "::",
            stringify!(basebelow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bluedata>())).ascent as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bluedata),
            "::",
            stringify!(ascent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bluedata>())).descent as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(bluedata),
            "::",
            stringify!(descent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bluedata>())).numh as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(bluedata),
            "::",
            stringify!(numh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bluedata>())).numhtop as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(bluedata),
            "::",
            stringify!(numhtop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bluedata>())).bluecnt as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(bluedata),
            "::",
            stringify!(bluecnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bluedata>())).blues as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(bluedata),
            "::",
            stringify!(blues)
        )
    );
}
pub type BlueData = bluedata;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bdffloat {
    pub xmin: int16,
    pub xmax: int16,
    pub ymin: int16,
    pub ymax: int16,
    pub bytes_per_line: int16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub depth: uint8,
    pub bitmap: *mut uint8,
}
#[test]
fn bindgen_test_layout_bdffloat() {
    assert_eq!(
        ::std::mem::size_of::<bdffloat>(),
        24usize,
        concat!("Size of: ", stringify!(bdffloat))
    );
    assert_eq!(
        ::std::mem::align_of::<bdffloat>(),
        8usize,
        concat!("Alignment of ", stringify!(bdffloat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdffloat>())).xmin as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bdffloat),
            "::",
            stringify!(xmin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdffloat>())).xmax as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(bdffloat),
            "::",
            stringify!(xmax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdffloat>())).ymin as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bdffloat),
            "::",
            stringify!(ymin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdffloat>())).ymax as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(bdffloat),
            "::",
            stringify!(ymax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdffloat>())).bytes_per_line as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bdffloat),
            "::",
            stringify!(bytes_per_line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdffloat>())).depth as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(bdffloat),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdffloat>())).bitmap as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bdffloat),
            "::",
            stringify!(bitmap)
        )
    );
}
impl bdffloat {
    #[inline]
    pub fn byte_data(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_byte_data(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        byte_data: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let byte_data: u32 = unsafe { ::std::mem::transmute(byte_data) };
            byte_data as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type BDFFloat = bdffloat;
pub const otlookup_type_ot_undef: otlookup_type = 0;
pub const otlookup_type_gsub_start: otlookup_type = 0;
pub const otlookup_type_gsub_single: otlookup_type = 1;
pub const otlookup_type_gsub_multiple: otlookup_type = 2;
pub const otlookup_type_gsub_alternate: otlookup_type = 3;
pub const otlookup_type_gsub_ligature: otlookup_type = 4;
pub const otlookup_type_gsub_context: otlookup_type = 5;
pub const otlookup_type_gsub_contextchain: otlookup_type = 6;
pub const otlookup_type_gsub_reversecchain: otlookup_type = 8;
pub const otlookup_type_morx_indic: otlookup_type = 253;
pub const otlookup_type_morx_context: otlookup_type = 254;
pub const otlookup_type_morx_insert: otlookup_type = 255;
pub const otlookup_type_gpos_start: otlookup_type = 256;
pub const otlookup_type_gpos_single: otlookup_type = 257;
pub const otlookup_type_gpos_pair: otlookup_type = 258;
pub const otlookup_type_gpos_cursive: otlookup_type = 259;
pub const otlookup_type_gpos_mark2base: otlookup_type = 260;
pub const otlookup_type_gpos_mark2ligature: otlookup_type = 261;
pub const otlookup_type_gpos_mark2mark: otlookup_type = 262;
pub const otlookup_type_gpos_context: otlookup_type = 263;
pub const otlookup_type_gpos_contextchain: otlookup_type = 264;
pub const otlookup_type_kern_statemachine: otlookup_type = 511;
pub type otlookup_type = ::std::os::raw::c_uint;
pub const otlookup_typemasks_gsub_single_mask: otlookup_typemasks = 1;
pub const otlookup_typemasks_gsub_multiple_mask: otlookup_typemasks = 2;
pub const otlookup_typemasks_gsub_alternate_mask: otlookup_typemasks = 4;
pub const otlookup_typemasks_gsub_ligature_mask: otlookup_typemasks = 8;
pub const otlookup_typemasks_gsub_context_mask: otlookup_typemasks = 16;
pub const otlookup_typemasks_gsub_contextchain_mask: otlookup_typemasks = 32;
pub const otlookup_typemasks_gsub_reversecchain_mask: otlookup_typemasks = 64;
pub const otlookup_typemasks_morx_indic_mask: otlookup_typemasks = 128;
pub const otlookup_typemasks_morx_context_mask: otlookup_typemasks = 256;
pub const otlookup_typemasks_morx_insert_mask: otlookup_typemasks = 512;
pub const otlookup_typemasks_gpos_single_mask: otlookup_typemasks = 1024;
pub const otlookup_typemasks_gpos_pair_mask: otlookup_typemasks = 2048;
pub const otlookup_typemasks_gpos_cursive_mask: otlookup_typemasks = 4096;
pub const otlookup_typemasks_gpos_mark2base_mask: otlookup_typemasks = 8192;
pub const otlookup_typemasks_gpos_mark2ligature_mask: otlookup_typemasks = 16384;
pub const otlookup_typemasks_gpos_mark2mark_mask: otlookup_typemasks = 32768;
pub const otlookup_typemasks_gpos_context_mask: otlookup_typemasks = 65536;
pub const otlookup_typemasks_gpos_contextchain_mask: otlookup_typemasks = 131072;
pub const otlookup_typemasks_kern_statemachine_mask: otlookup_typemasks = 262144;
pub type otlookup_typemasks = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scriptlanglist {
    pub script: uint32,
    pub langs: [uint32; 4usize],
    pub morelangs: *mut uint32,
    pub lang_cnt: ::std::os::raw::c_int,
    pub next: *mut scriptlanglist,
}
#[test]
fn bindgen_test_layout_scriptlanglist() {
    assert_eq!(
        ::std::mem::size_of::<scriptlanglist>(),
        48usize,
        concat!("Size of: ", stringify!(scriptlanglist))
    );
    assert_eq!(
        ::std::mem::align_of::<scriptlanglist>(),
        8usize,
        concat!("Alignment of ", stringify!(scriptlanglist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scriptlanglist>())).script as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scriptlanglist),
            "::",
            stringify!(script)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scriptlanglist>())).langs as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(scriptlanglist),
            "::",
            stringify!(langs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scriptlanglist>())).morelangs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(scriptlanglist),
            "::",
            stringify!(morelangs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scriptlanglist>())).lang_cnt as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(scriptlanglist),
            "::",
            stringify!(lang_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scriptlanglist>())).next as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(scriptlanglist),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opentype_feature_friendlynames {
    pub tag: uint32,
    pub tagstr: *mut ::std::os::raw::c_char,
    pub friendlyname: *mut ::std::os::raw::c_char,
    pub masks: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_opentype_feature_friendlynames() {
    assert_eq!(
        ::std::mem::size_of::<opentype_feature_friendlynames>(),
        32usize,
        concat!("Size of: ", stringify!(opentype_feature_friendlynames))
    );
    assert_eq!(
        ::std::mem::align_of::<opentype_feature_friendlynames>(),
        8usize,
        concat!("Alignment of ", stringify!(opentype_feature_friendlynames))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opentype_feature_friendlynames>())).tag as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(opentype_feature_friendlynames),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opentype_feature_friendlynames>())).tagstr as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(opentype_feature_friendlynames),
            "::",
            stringify!(tagstr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opentype_feature_friendlynames>())).friendlyname as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(opentype_feature_friendlynames),
            "::",
            stringify!(friendlyname)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opentype_feature_friendlynames>())).masks as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(opentype_feature_friendlynames),
            "::",
            stringify!(masks)
        )
    );
}
extern "C" {
    pub static mut friendlies: [opentype_feature_friendlynames; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct featurescriptlanglist {
    pub featuretag: uint32,
    pub scripts: *mut scriptlanglist,
    pub next: *mut featurescriptlanglist,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_featurescriptlanglist() {
    assert_eq!(
        ::std::mem::size_of::<featurescriptlanglist>(),
        32usize,
        concat!("Size of: ", stringify!(featurescriptlanglist))
    );
    assert_eq!(
        ::std::mem::align_of::<featurescriptlanglist>(),
        8usize,
        concat!("Alignment of ", stringify!(featurescriptlanglist))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<featurescriptlanglist>())).featuretag as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(featurescriptlanglist),
            "::",
            stringify!(featuretag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<featurescriptlanglist>())).scripts as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(featurescriptlanglist),
            "::",
            stringify!(scripts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<featurescriptlanglist>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(featurescriptlanglist),
            "::",
            stringify!(next)
        )
    );
}
impl featurescriptlanglist {
    #[inline]
    pub fn ismac(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ismac(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ismac: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ismac: u32 = unsafe { ::std::mem::transmute(ismac) };
            ismac as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type FeatureScriptLangList = featurescriptlanglist;
pub const pst_flags_pst_r2l: pst_flags = 1;
pub const pst_flags_pst_ignorebaseglyphs: pst_flags = 2;
pub const pst_flags_pst_ignoreligatures: pst_flags = 4;
pub const pst_flags_pst_ignorecombiningmarks: pst_flags = 8;
pub const pst_flags_pst_usemarkfilteringset: pst_flags = 16;
pub const pst_flags_pst_markclass: pst_flags = 65280;
pub const pst_flags_pst_markset: pst_flags = 4294901760;
pub type pst_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lookup_subtable {
    pub subtable_name: *mut ::std::os::raw::c_char,
    pub suffix: *mut ::std::os::raw::c_char,
    pub separation: int16,
    pub minkern: int16,
    pub lookup: *mut otlookup,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub kc: *mut kernclass,
    pub fpst: *mut generic_fpst,
    pub sm: *mut generic_asm,
    pub next: *mut lookup_subtable,
    pub subtable_offset: int32,
    pub extra_subtables: *mut int32,
}
#[test]
fn bindgen_test_layout_lookup_subtable() {
    assert_eq!(
        ::std::mem::size_of::<lookup_subtable>(),
        88usize,
        concat!("Size of: ", stringify!(lookup_subtable))
    );
    assert_eq!(
        ::std::mem::align_of::<lookup_subtable>(),
        8usize,
        concat!("Alignment of ", stringify!(lookup_subtable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lookup_subtable>())).subtable_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lookup_subtable),
            "::",
            stringify!(subtable_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lookup_subtable>())).suffix as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lookup_subtable),
            "::",
            stringify!(suffix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lookup_subtable>())).separation as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lookup_subtable),
            "::",
            stringify!(separation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lookup_subtable>())).minkern as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(lookup_subtable),
            "::",
            stringify!(minkern)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lookup_subtable>())).lookup as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lookup_subtable),
            "::",
            stringify!(lookup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lookup_subtable>())).kc as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lookup_subtable),
            "::",
            stringify!(kc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lookup_subtable>())).fpst as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lookup_subtable),
            "::",
            stringify!(fpst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lookup_subtable>())).sm as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lookup_subtable),
            "::",
            stringify!(sm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lookup_subtable>())).next as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lookup_subtable),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lookup_subtable>())).subtable_offset as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lookup_subtable),
            "::",
            stringify!(subtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lookup_subtable>())).extra_subtables as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lookup_subtable),
            "::",
            stringify!(extra_subtables)
        )
    );
}
impl lookup_subtable {
    #[inline]
    pub fn unused(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn per_glyph_pst_or_kern(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_per_glyph_pst_or_kern(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn anchor_classes(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_anchor_classes(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vertical_kerning(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vertical_kerning(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ticked(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ticked(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn kerning_by_touch(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_kerning_by_touch(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn onlyCloser(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_onlyCloser(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dontautokern(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dontautokern(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        unused: ::std::os::raw::c_uint,
        per_glyph_pst_or_kern: ::std::os::raw::c_uint,
        anchor_classes: ::std::os::raw::c_uint,
        vertical_kerning: ::std::os::raw::c_uint,
        ticked: ::std::os::raw::c_uint,
        kerning_by_touch: ::std::os::raw::c_uint,
        onlyCloser: ::std::os::raw::c_uint,
        dontautokern: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let unused: u32 = unsafe { ::std::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let per_glyph_pst_or_kern: u32 =
                unsafe { ::std::mem::transmute(per_glyph_pst_or_kern) };
            per_glyph_pst_or_kern as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let anchor_classes: u32 = unsafe { ::std::mem::transmute(anchor_classes) };
            anchor_classes as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let vertical_kerning: u32 = unsafe { ::std::mem::transmute(vertical_kerning) };
            vertical_kerning as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ticked: u32 = unsafe { ::std::mem::transmute(ticked) };
            ticked as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let kerning_by_touch: u32 = unsafe { ::std::mem::transmute(kerning_by_touch) };
            kerning_by_touch as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let onlyCloser: u32 = unsafe { ::std::mem::transmute(onlyCloser) };
            onlyCloser as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let dontautokern: u32 = unsafe { ::std::mem::transmute(dontautokern) };
            dontautokern as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otlookup {
    pub next: *mut otlookup,
    pub lookup_type: otlookup_type,
    pub lookup_flags: uint32,
    pub lookup_name: *mut ::std::os::raw::c_char,
    pub features: *mut FeatureScriptLangList,
    pub subtables: *mut lookup_subtable,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub subcnt: int16,
    pub lookup_index: ::std::os::raw::c_int,
    pub lookup_offset: uint32,
    pub lookup_length: uint32,
    pub tempname: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_otlookup() {
    assert_eq!(
        ::std::mem::size_of::<otlookup>(),
        64usize,
        concat!("Size of: ", stringify!(otlookup))
    );
    assert_eq!(
        ::std::mem::align_of::<otlookup>(),
        8usize,
        concat!("Alignment of ", stringify!(otlookup))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<otlookup>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(otlookup),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<otlookup>())).lookup_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(otlookup),
            "::",
            stringify!(lookup_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<otlookup>())).lookup_flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(otlookup),
            "::",
            stringify!(lookup_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<otlookup>())).lookup_name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(otlookup),
            "::",
            stringify!(lookup_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<otlookup>())).features as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(otlookup),
            "::",
            stringify!(features)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<otlookup>())).subtables as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(otlookup),
            "::",
            stringify!(subtables)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<otlookup>())).subcnt as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(otlookup),
            "::",
            stringify!(subcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<otlookup>())).lookup_index as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(otlookup),
            "::",
            stringify!(lookup_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<otlookup>())).lookup_offset as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(otlookup),
            "::",
            stringify!(lookup_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<otlookup>())).lookup_length as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(otlookup),
            "::",
            stringify!(lookup_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<otlookup>())).tempname as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(otlookup),
            "::",
            stringify!(tempname)
        )
    );
}
impl otlookup {
    #[inline]
    pub fn unused(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn empty(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_empty(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn store_in_afm(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_store_in_afm(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn needs_extension(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_needs_extension(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn temporary_kern(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_temporary_kern(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn def_lang_checked(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_def_lang_checked(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn def_lang_found(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_def_lang_found(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ticked(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ticked(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_gpos(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_gpos(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_jstf(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_jstf(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn only_jstf(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_only_jstf(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        unused: ::std::os::raw::c_uint,
        empty: ::std::os::raw::c_uint,
        store_in_afm: ::std::os::raw::c_uint,
        needs_extension: ::std::os::raw::c_uint,
        temporary_kern: ::std::os::raw::c_uint,
        def_lang_checked: ::std::os::raw::c_uint,
        def_lang_found: ::std::os::raw::c_uint,
        ticked: ::std::os::raw::c_uint,
        in_gpos: ::std::os::raw::c_uint,
        in_jstf: ::std::os::raw::c_uint,
        only_jstf: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let unused: u32 = unsafe { ::std::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let empty: u32 = unsafe { ::std::mem::transmute(empty) };
            empty as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let store_in_afm: u32 = unsafe { ::std::mem::transmute(store_in_afm) };
            store_in_afm as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let needs_extension: u32 = unsafe { ::std::mem::transmute(needs_extension) };
            needs_extension as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let temporary_kern: u32 = unsafe { ::std::mem::transmute(temporary_kern) };
            temporary_kern as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let def_lang_checked: u32 = unsafe { ::std::mem::transmute(def_lang_checked) };
            def_lang_checked as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let def_lang_found: u32 = unsafe { ::std::mem::transmute(def_lang_found) };
            def_lang_found as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ticked: u32 = unsafe { ::std::mem::transmute(ticked) };
            ticked as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let in_gpos: u32 = unsafe { ::std::mem::transmute(in_gpos) };
            in_gpos as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let in_jstf: u32 = unsafe { ::std::mem::transmute(in_jstf) };
            in_jstf as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let only_jstf: u32 = unsafe { ::std::mem::transmute(only_jstf) };
            only_jstf as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type OTLookup = otlookup;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devicetab {
    pub first_pixel_size: uint16,
    pub last_pixel_size: uint16,
    pub corrections: *mut int8,
}
#[test]
fn bindgen_test_layout_devicetab() {
    assert_eq!(
        ::std::mem::size_of::<devicetab>(),
        16usize,
        concat!("Size of: ", stringify!(devicetab))
    );
    assert_eq!(
        ::std::mem::align_of::<devicetab>(),
        8usize,
        concat!("Alignment of ", stringify!(devicetab))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<devicetab>())).first_pixel_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(devicetab),
            "::",
            stringify!(first_pixel_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<devicetab>())).last_pixel_size as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(devicetab),
            "::",
            stringify!(last_pixel_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<devicetab>())).corrections as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(devicetab),
            "::",
            stringify!(corrections)
        )
    );
}
pub type DeviceTable = devicetab;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct valdev {
    pub xadjust: DeviceTable,
    pub yadjust: DeviceTable,
    pub xadv: DeviceTable,
    pub yadv: DeviceTable,
}
#[test]
fn bindgen_test_layout_valdev() {
    assert_eq!(
        ::std::mem::size_of::<valdev>(),
        64usize,
        concat!("Size of: ", stringify!(valdev))
    );
    assert_eq!(
        ::std::mem::align_of::<valdev>(),
        8usize,
        concat!("Alignment of ", stringify!(valdev))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<valdev>())).xadjust as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(valdev),
            "::",
            stringify!(xadjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<valdev>())).yadjust as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(valdev),
            "::",
            stringify!(yadjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<valdev>())).xadv as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(valdev),
            "::",
            stringify!(xadv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<valdev>())).yadv as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(valdev),
            "::",
            stringify!(yadv)
        )
    );
}
pub type ValDevTab = valdev;
pub const anchorclass_type_act_mark: anchorclass_type = 0;
pub const anchorclass_type_act_mkmk: anchorclass_type = 1;
pub const anchorclass_type_act_curs: anchorclass_type = 2;
pub const anchorclass_type_act_mklg: anchorclass_type = 3;
pub const anchorclass_type_act_unknown: anchorclass_type = 4;
pub type anchorclass_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct anchorclass {
    pub name: *mut ::std::os::raw::c_char,
    pub subtable: *mut lookup_subtable,
    pub type_: uint8,
    pub has_base: uint8,
    pub processed: uint8,
    pub has_mark: uint8,
    pub matches: uint8,
    pub ac_num: uint8,
    pub ticked: uint8,
    pub next: *mut anchorclass,
}
#[test]
fn bindgen_test_layout_anchorclass() {
    assert_eq!(
        ::std::mem::size_of::<anchorclass>(),
        32usize,
        concat!("Size of: ", stringify!(anchorclass))
    );
    assert_eq!(
        ::std::mem::align_of::<anchorclass>(),
        8usize,
        concat!("Alignment of ", stringify!(anchorclass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<anchorclass>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(anchorclass),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<anchorclass>())).subtable as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(anchorclass),
            "::",
            stringify!(subtable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<anchorclass>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(anchorclass),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<anchorclass>())).has_base as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(anchorclass),
            "::",
            stringify!(has_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<anchorclass>())).processed as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(anchorclass),
            "::",
            stringify!(processed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<anchorclass>())).has_mark as *const _ as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(anchorclass),
            "::",
            stringify!(has_mark)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<anchorclass>())).matches as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(anchorclass),
            "::",
            stringify!(matches)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<anchorclass>())).ac_num as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(anchorclass),
            "::",
            stringify!(ac_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<anchorclass>())).ticked as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(anchorclass),
            "::",
            stringify!(ticked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<anchorclass>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(anchorclass),
            "::",
            stringify!(next)
        )
    );
}
pub type AnchorClass = anchorclass;
pub const anchor_type_at_mark: anchor_type = 0;
pub const anchor_type_at_basechar: anchor_type = 1;
pub const anchor_type_at_baselig: anchor_type = 2;
pub const anchor_type_at_basemark: anchor_type = 3;
pub const anchor_type_at_centry: anchor_type = 4;
pub const anchor_type_at_cexit: anchor_type = 5;
pub const anchor_type_at_max: anchor_type = 6;
pub type anchor_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct anchorpoint {
    pub anchor: *mut AnchorClass,
    pub me: BasePoint,
    pub xadjust: DeviceTable,
    pub yadjust: DeviceTable,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub ttf_pt_index: uint16,
    pub lig_index: int16,
    pub next: *mut anchorpoint,
}
#[test]
fn bindgen_test_layout_anchorpoint() {
    assert_eq!(
        ::std::mem::size_of::<anchorpoint>(),
        72usize,
        concat!("Size of: ", stringify!(anchorpoint))
    );
    assert_eq!(
        ::std::mem::align_of::<anchorpoint>(),
        8usize,
        concat!("Alignment of ", stringify!(anchorpoint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<anchorpoint>())).anchor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(anchorpoint),
            "::",
            stringify!(anchor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<anchorpoint>())).me as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(anchorpoint),
            "::",
            stringify!(me)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<anchorpoint>())).xadjust as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(anchorpoint),
            "::",
            stringify!(xadjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<anchorpoint>())).yadjust as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(anchorpoint),
            "::",
            stringify!(yadjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<anchorpoint>())).ttf_pt_index as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(anchorpoint),
            "::",
            stringify!(ttf_pt_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<anchorpoint>())).lig_index as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(anchorpoint),
            "::",
            stringify!(lig_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<anchorpoint>())).next as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(anchorpoint),
            "::",
            stringify!(next)
        )
    );
}
impl anchorpoint {
    #[inline]
    pub fn type_(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn selected(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_selected(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ticked(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ticked(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_ttf_pt(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_ttf_pt(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: ::std::os::raw::c_uint,
        selected: ::std::os::raw::c_uint,
        ticked: ::std::os::raw::c_uint,
        has_ttf_pt: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let selected: u32 = unsafe { ::std::mem::transmute(selected) };
            selected as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ticked: u32 = unsafe { ::std::mem::transmute(ticked) };
            ticked as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let has_ttf_pt: u32 = unsafe { ::std::mem::transmute(has_ttf_pt) };
            has_ttf_pt as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type AnchorPoint = anchorpoint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernpair {
    pub subtable: *mut lookup_subtable,
    pub sc: *mut splinechar,
    pub off: int16,
    pub kcid: uint16,
    pub adjust: *mut DeviceTable,
    pub next: *mut kernpair,
}
#[test]
fn bindgen_test_layout_kernpair() {
    assert_eq!(
        ::std::mem::size_of::<kernpair>(),
        40usize,
        concat!("Size of: ", stringify!(kernpair))
    );
    assert_eq!(
        ::std::mem::align_of::<kernpair>(),
        8usize,
        concat!("Alignment of ", stringify!(kernpair))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernpair>())).subtable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernpair),
            "::",
            stringify!(subtable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernpair>())).sc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernpair),
            "::",
            stringify!(sc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernpair>())).off as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kernpair),
            "::",
            stringify!(off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernpair>())).kcid as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(kernpair),
            "::",
            stringify!(kcid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernpair>())).adjust as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kernpair),
            "::",
            stringify!(adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernpair>())).next as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kernpair),
            "::",
            stringify!(next)
        )
    );
}
pub type KernPair = kernpair;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernclass {
    pub first_cnt: ::std::os::raw::c_int,
    pub second_cnt: ::std::os::raw::c_int,
    pub firsts: *mut *mut ::std::os::raw::c_char,
    pub seconds: *mut *mut ::std::os::raw::c_char,
    pub firsts_names: *mut *mut ::std::os::raw::c_char,
    pub seconds_names: *mut *mut ::std::os::raw::c_char,
    pub firsts_flags: *mut ::std::os::raw::c_int,
    pub seconds_flags: *mut ::std::os::raw::c_int,
    pub subtable: *mut lookup_subtable,
    pub kcid: uint16,
    pub offsets: *mut int16,
    pub offsets_flags: *mut ::std::os::raw::c_int,
    pub adjusts: *mut DeviceTable,
    pub next: *mut kernclass,
    pub feature: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_kernclass() {
    assert_eq!(
        ::std::mem::size_of::<kernclass>(),
        112usize,
        concat!("Size of: ", stringify!(kernclass))
    );
    assert_eq!(
        ::std::mem::align_of::<kernclass>(),
        8usize,
        concat!("Alignment of ", stringify!(kernclass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernclass>())).first_cnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernclass),
            "::",
            stringify!(first_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernclass>())).second_cnt as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kernclass),
            "::",
            stringify!(second_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernclass>())).firsts as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernclass),
            "::",
            stringify!(firsts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernclass>())).seconds as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kernclass),
            "::",
            stringify!(seconds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernclass>())).firsts_names as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kernclass),
            "::",
            stringify!(firsts_names)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernclass>())).seconds_names as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kernclass),
            "::",
            stringify!(seconds_names)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernclass>())).firsts_flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kernclass),
            "::",
            stringify!(firsts_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernclass>())).seconds_flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(kernclass),
            "::",
            stringify!(seconds_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernclass>())).subtable as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(kernclass),
            "::",
            stringify!(subtable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernclass>())).kcid as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(kernclass),
            "::",
            stringify!(kcid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernclass>())).offsets as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(kernclass),
            "::",
            stringify!(offsets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernclass>())).offsets_flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(kernclass),
            "::",
            stringify!(offsets_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernclass>())).adjusts as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(kernclass),
            "::",
            stringify!(adjusts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernclass>())).next as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(kernclass),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernclass>())).feature as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(kernclass),
            "::",
            stringify!(feature)
        )
    );
}
pub type KernClass = kernclass;
pub const possub_type_pst_null: possub_type = 0;
pub const possub_type_pst_position: possub_type = 1;
pub const possub_type_pst_pair: possub_type = 2;
pub const possub_type_pst_substitution: possub_type = 3;
pub const possub_type_pst_alternate: possub_type = 4;
pub const possub_type_pst_multiple: possub_type = 5;
pub const possub_type_pst_ligature: possub_type = 6;
pub const possub_type_pst_lcaret: possub_type = 7;
pub const possub_type_pst_max: possub_type = 8;
pub const possub_type_pst_kerning: possub_type = 8;
pub const possub_type_pst_vkerning: possub_type = 9;
pub const possub_type_pst_anchors: possub_type = 10;
pub const possub_type_pst_contextpos: possub_type = 11;
pub const possub_type_pst_contextsub: possub_type = 12;
pub const possub_type_pst_chainpos: possub_type = 13;
pub const possub_type_pst_chainsub: possub_type = 14;
pub const possub_type_pst_reversesub: possub_type = 15;
pub const possub_type_fpst_max: possub_type = 16;
pub const possub_type_pst_kernback: possub_type = 17;
pub const possub_type_pst_vkernback: possub_type = 18;
pub type possub_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vr {
    pub xoff: int16,
    pub yoff: int16,
    pub h_adv_off: int16,
    pub v_adv_off: int16,
    pub adjust: *mut ValDevTab,
}
#[test]
fn bindgen_test_layout_vr() {
    assert_eq!(
        ::std::mem::size_of::<vr>(),
        16usize,
        concat!("Size of: ", stringify!(vr))
    );
    assert_eq!(
        ::std::mem::align_of::<vr>(),
        8usize,
        concat!("Alignment of ", stringify!(vr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vr>())).xoff as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(vr), "::", stringify!(xoff))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vr>())).yoff as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(vr), "::", stringify!(yoff))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vr>())).h_adv_off as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vr),
            "::",
            stringify!(h_adv_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vr>())).v_adv_off as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(vr),
            "::",
            stringify!(v_adv_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vr>())).adjust as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vr),
            "::",
            stringify!(adjust)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct generic_pst {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub type_: uint8,
    pub subtable: *mut lookup_subtable,
    pub next: *mut generic_pst,
    pub u: generic_pst__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union generic_pst__bindgen_ty_1 {
    pub pos: vr,
    pub pair: generic_pst__bindgen_ty_1__bindgen_ty_1,
    pub subs: generic_pst__bindgen_ty_1__bindgen_ty_2,
    pub mult: generic_pst__bindgen_ty_1__bindgen_ty_3,
    pub alt: generic_pst__bindgen_ty_1__bindgen_ty_3,
    pub lig: generic_pst__bindgen_ty_1__bindgen_ty_4,
    pub lcaret: generic_pst__bindgen_ty_1__bindgen_ty_5,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct generic_pst__bindgen_ty_1__bindgen_ty_1 {
    pub paired: *mut ::std::os::raw::c_char,
    pub vr: *mut vr,
}
#[test]
fn bindgen_test_layout_generic_pst__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<generic_pst__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(generic_pst__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<generic_pst__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(generic_pst__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<generic_pst__bindgen_ty_1__bindgen_ty_1>())).paired as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_pst__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(paired)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<generic_pst__bindgen_ty_1__bindgen_ty_1>())).vr as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_pst__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(vr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct generic_pst__bindgen_ty_1__bindgen_ty_2 {
    pub variant: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_generic_pst__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<generic_pst__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(generic_pst__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<generic_pst__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(generic_pst__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<generic_pst__bindgen_ty_1__bindgen_ty_2>())).variant as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_pst__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(variant)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct generic_pst__bindgen_ty_1__bindgen_ty_3 {
    pub components: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_generic_pst__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<generic_pst__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(generic_pst__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<generic_pst__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(generic_pst__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<generic_pst__bindgen_ty_1__bindgen_ty_3>())).components
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_pst__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(components)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct generic_pst__bindgen_ty_1__bindgen_ty_4 {
    pub components: *mut ::std::os::raw::c_char,
    pub lig: *mut splinechar,
}
#[test]
fn bindgen_test_layout_generic_pst__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<generic_pst__bindgen_ty_1__bindgen_ty_4>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(generic_pst__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<generic_pst__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(generic_pst__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<generic_pst__bindgen_ty_1__bindgen_ty_4>())).components
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_pst__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(components)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<generic_pst__bindgen_ty_1__bindgen_ty_4>())).lig as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_pst__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(lig)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct generic_pst__bindgen_ty_1__bindgen_ty_5 {
    pub carets: *mut int16,
    pub cnt: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_generic_pst__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<generic_pst__bindgen_ty_1__bindgen_ty_5>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(generic_pst__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<generic_pst__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(generic_pst__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<generic_pst__bindgen_ty_1__bindgen_ty_5>())).carets as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_pst__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(carets)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<generic_pst__bindgen_ty_1__bindgen_ty_5>())).cnt as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_pst__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(cnt)
        )
    );
}
#[test]
fn bindgen_test_layout_generic_pst__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<generic_pst__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(generic_pst__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<generic_pst__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(generic_pst__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_pst__bindgen_ty_1>())).pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_pst__bindgen_ty_1),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_pst__bindgen_ty_1>())).pair as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_pst__bindgen_ty_1),
            "::",
            stringify!(pair)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_pst__bindgen_ty_1>())).subs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_pst__bindgen_ty_1),
            "::",
            stringify!(subs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_pst__bindgen_ty_1>())).mult as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_pst__bindgen_ty_1),
            "::",
            stringify!(mult)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_pst__bindgen_ty_1>())).alt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_pst__bindgen_ty_1),
            "::",
            stringify!(alt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_pst__bindgen_ty_1>())).lig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_pst__bindgen_ty_1),
            "::",
            stringify!(lig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<generic_pst__bindgen_ty_1>())).lcaret as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_pst__bindgen_ty_1),
            "::",
            stringify!(lcaret)
        )
    );
}
#[test]
fn bindgen_test_layout_generic_pst() {
    assert_eq!(
        ::std::mem::size_of::<generic_pst>(),
        40usize,
        concat!("Size of: ", stringify!(generic_pst))
    );
    assert_eq!(
        ::std::mem::align_of::<generic_pst>(),
        8usize,
        concat!("Alignment of ", stringify!(generic_pst))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_pst>())).type_ as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_pst),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_pst>())).subtable as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_pst),
            "::",
            stringify!(subtable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_pst>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_pst),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_pst>())).u as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_pst),
            "::",
            stringify!(u)
        )
    );
}
impl generic_pst {
    #[inline]
    pub fn ticked(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ticked(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn temporary(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_temporary(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ticked: ::std::os::raw::c_uint,
        temporary: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ticked: u32 = unsafe { ::std::mem::transmute(ticked) };
            ticked as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let temporary: u32 = unsafe { ::std::mem::transmute(temporary) };
            temporary as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PST = generic_pst;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct liglist {
    pub lig: *mut PST,
    pub first: *mut splinechar,
    pub components: *mut splinecharlist,
    pub next: *mut liglist,
    pub ccnt: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_liglist() {
    assert_eq!(
        ::std::mem::size_of::<liglist>(),
        40usize,
        concat!("Size of: ", stringify!(liglist))
    );
    assert_eq!(
        ::std::mem::align_of::<liglist>(),
        8usize,
        concat!("Alignment of ", stringify!(liglist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<liglist>())).lig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(liglist),
            "::",
            stringify!(lig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<liglist>())).first as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(liglist),
            "::",
            stringify!(first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<liglist>())).components as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(liglist),
            "::",
            stringify!(components)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<liglist>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(liglist),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<liglist>())).ccnt as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(liglist),
            "::",
            stringify!(ccnt)
        )
    );
}
pub type LigList = liglist;
pub const fpossub_format_pst_glyphs: fpossub_format = 0;
pub const fpossub_format_pst_class: fpossub_format = 1;
pub const fpossub_format_pst_coverage: fpossub_format = 2;
pub const fpossub_format_pst_reversecoverage: fpossub_format = 3;
pub const fpossub_format_pst_formatmax: fpossub_format = 4;
pub type fpossub_format = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seqlookup {
    pub seq: ::std::os::raw::c_int,
    pub lookup: *mut otlookup,
}
#[test]
fn bindgen_test_layout_seqlookup() {
    assert_eq!(
        ::std::mem::size_of::<seqlookup>(),
        16usize,
        concat!("Size of: ", stringify!(seqlookup))
    );
    assert_eq!(
        ::std::mem::align_of::<seqlookup>(),
        8usize,
        concat!("Alignment of ", stringify!(seqlookup))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seqlookup>())).seq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seqlookup),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seqlookup>())).lookup as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seqlookup),
            "::",
            stringify!(lookup)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpg {
    pub names: *mut ::std::os::raw::c_char,
    pub back: *mut ::std::os::raw::c_char,
    pub fore: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_fpg() {
    assert_eq!(
        ::std::mem::size_of::<fpg>(),
        24usize,
        concat!("Size of: ", stringify!(fpg))
    );
    assert_eq!(
        ::std::mem::align_of::<fpg>(),
        8usize,
        concat!("Alignment of ", stringify!(fpg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpg>())).names as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpg),
            "::",
            stringify!(names)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpg>())).back as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(fpg), "::", stringify!(back))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpg>())).fore as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(fpg), "::", stringify!(fore))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpc {
    pub ncnt: ::std::os::raw::c_int,
    pub bcnt: ::std::os::raw::c_int,
    pub fcnt: ::std::os::raw::c_int,
    pub nclasses: *mut uint16,
    pub bclasses: *mut uint16,
    pub fclasses: *mut uint16,
    pub allclasses: *mut uint16,
}
#[test]
fn bindgen_test_layout_fpc() {
    assert_eq!(
        ::std::mem::size_of::<fpc>(),
        48usize,
        concat!("Size of: ", stringify!(fpc))
    );
    assert_eq!(
        ::std::mem::align_of::<fpc>(),
        8usize,
        concat!("Alignment of ", stringify!(fpc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpc>())).ncnt as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(fpc), "::", stringify!(ncnt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpc>())).bcnt as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(fpc), "::", stringify!(bcnt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpc>())).fcnt as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(fpc), "::", stringify!(fcnt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpc>())).nclasses as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fpc),
            "::",
            stringify!(nclasses)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpc>())).bclasses as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fpc),
            "::",
            stringify!(bclasses)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpc>())).fclasses as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fpc),
            "::",
            stringify!(fclasses)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpc>())).allclasses as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(fpc),
            "::",
            stringify!(allclasses)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpv {
    pub ncnt: ::std::os::raw::c_int,
    pub bcnt: ::std::os::raw::c_int,
    pub fcnt: ::std::os::raw::c_int,
    pub ncovers: *mut *mut ::std::os::raw::c_char,
    pub bcovers: *mut *mut ::std::os::raw::c_char,
    pub fcovers: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_fpv() {
    assert_eq!(
        ::std::mem::size_of::<fpv>(),
        40usize,
        concat!("Size of: ", stringify!(fpv))
    );
    assert_eq!(
        ::std::mem::align_of::<fpv>(),
        8usize,
        concat!("Alignment of ", stringify!(fpv))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpv>())).ncnt as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(fpv), "::", stringify!(ncnt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpv>())).bcnt as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(fpv), "::", stringify!(bcnt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpv>())).fcnt as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(fpv), "::", stringify!(fcnt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpv>())).ncovers as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fpv),
            "::",
            stringify!(ncovers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpv>())).bcovers as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fpv),
            "::",
            stringify!(bcovers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpv>())).fcovers as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fpv),
            "::",
            stringify!(fcovers)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpr {
    pub always1: ::std::os::raw::c_int,
    pub bcnt: ::std::os::raw::c_int,
    pub fcnt: ::std::os::raw::c_int,
    pub ncovers: *mut *mut ::std::os::raw::c_char,
    pub bcovers: *mut *mut ::std::os::raw::c_char,
    pub fcovers: *mut *mut ::std::os::raw::c_char,
    pub replacements: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_fpr() {
    assert_eq!(
        ::std::mem::size_of::<fpr>(),
        48usize,
        concat!("Size of: ", stringify!(fpr))
    );
    assert_eq!(
        ::std::mem::align_of::<fpr>(),
        8usize,
        concat!("Alignment of ", stringify!(fpr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpr>())).always1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpr),
            "::",
            stringify!(always1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpr>())).bcnt as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(fpr), "::", stringify!(bcnt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpr>())).fcnt as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(fpr), "::", stringify!(fcnt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpr>())).ncovers as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fpr),
            "::",
            stringify!(ncovers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpr>())).bcovers as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fpr),
            "::",
            stringify!(bcovers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpr>())).fcovers as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fpr),
            "::",
            stringify!(fcovers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpr>())).replacements as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(fpr),
            "::",
            stringify!(replacements)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fpst_rule {
    pub u: fpst_rule__bindgen_ty_1,
    pub lookup_cnt: ::std::os::raw::c_int,
    pub lookups: *mut seqlookup,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fpst_rule__bindgen_ty_1 {
    pub glyph: fpg,
    pub class: fpc,
    pub coverage: fpv,
    pub rcoverage: fpr,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_fpst_rule__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<fpst_rule__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(fpst_rule__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<fpst_rule__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(fpst_rule__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpst_rule__bindgen_ty_1>())).glyph as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpst_rule__bindgen_ty_1),
            "::",
            stringify!(glyph)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpst_rule__bindgen_ty_1>())).class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpst_rule__bindgen_ty_1),
            "::",
            stringify!(class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fpst_rule__bindgen_ty_1>())).coverage as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpst_rule__bindgen_ty_1),
            "::",
            stringify!(coverage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fpst_rule__bindgen_ty_1>())).rcoverage as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpst_rule__bindgen_ty_1),
            "::",
            stringify!(rcoverage)
        )
    );
}
#[test]
fn bindgen_test_layout_fpst_rule() {
    assert_eq!(
        ::std::mem::size_of::<fpst_rule>(),
        64usize,
        concat!("Size of: ", stringify!(fpst_rule))
    );
    assert_eq!(
        ::std::mem::align_of::<fpst_rule>(),
        8usize,
        concat!("Alignment of ", stringify!(fpst_rule))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpst_rule>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpst_rule),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpst_rule>())).lookup_cnt as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(fpst_rule),
            "::",
            stringify!(lookup_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpst_rule>())).lookups as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(fpst_rule),
            "::",
            stringify!(lookups)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct generic_fpst {
    pub type_: uint16,
    pub format: uint16,
    pub subtable: *mut lookup_subtable,
    pub next: *mut generic_fpst,
    pub nccnt: uint16,
    pub bccnt: uint16,
    pub fccnt: uint16,
    pub rule_cnt: uint16,
    pub nclass: *mut *mut ::std::os::raw::c_char,
    pub bclass: *mut *mut ::std::os::raw::c_char,
    pub fclass: *mut *mut ::std::os::raw::c_char,
    pub rules: *mut fpst_rule,
    pub ticked: uint8,
    pub effectively_by_glyphs: uint8,
    pub nclassnames: *mut *mut ::std::os::raw::c_char,
    pub bclassnames: *mut *mut ::std::os::raw::c_char,
    pub fclassnames: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_generic_fpst() {
    assert_eq!(
        ::std::mem::size_of::<generic_fpst>(),
        96usize,
        concat!("Size of: ", stringify!(generic_fpst))
    );
    assert_eq!(
        ::std::mem::align_of::<generic_fpst>(),
        8usize,
        concat!("Alignment of ", stringify!(generic_fpst))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_fpst>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_fpst),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_fpst>())).format as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_fpst),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_fpst>())).subtable as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_fpst),
            "::",
            stringify!(subtable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_fpst>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_fpst),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_fpst>())).nccnt as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_fpst),
            "::",
            stringify!(nccnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_fpst>())).bccnt as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_fpst),
            "::",
            stringify!(bccnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_fpst>())).fccnt as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_fpst),
            "::",
            stringify!(fccnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_fpst>())).rule_cnt as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_fpst),
            "::",
            stringify!(rule_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_fpst>())).nclass as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_fpst),
            "::",
            stringify!(nclass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_fpst>())).bclass as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_fpst),
            "::",
            stringify!(bclass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_fpst>())).fclass as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_fpst),
            "::",
            stringify!(fclass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_fpst>())).rules as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_fpst),
            "::",
            stringify!(rules)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_fpst>())).ticked as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_fpst),
            "::",
            stringify!(ticked)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<generic_fpst>())).effectively_by_glyphs as *const _ as usize
        },
        65usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_fpst),
            "::",
            stringify!(effectively_by_glyphs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_fpst>())).nclassnames as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_fpst),
            "::",
            stringify!(nclassnames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_fpst>())).bclassnames as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_fpst),
            "::",
            stringify!(bclassnames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_fpst>())).fclassnames as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_fpst),
            "::",
            stringify!(fclassnames)
        )
    );
}
pub type FPST = generic_fpst;
pub const asm_type_asm_indic: asm_type = 0;
pub const asm_type_asm_context: asm_type = 1;
pub const asm_type_asm_lig: asm_type = 2;
pub const asm_type_asm_simple: asm_type = 4;
pub const asm_type_asm_insert: asm_type = 5;
pub const asm_type_asm_kern: asm_type = 17;
pub type asm_type = ::std::os::raw::c_uint;
pub const asm_flags_asm_vert: asm_flags = 32768;
pub const asm_flags_asm_descending: asm_flags = 16384;
pub const asm_flags_asm_always: asm_flags = 8192;
pub type asm_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct asm_state {
    pub next_state: uint16,
    pub flags: uint16,
    pub u: asm_state__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union asm_state__bindgen_ty_1 {
    pub context: asm_state__bindgen_ty_1__bindgen_ty_1,
    pub insert: asm_state__bindgen_ty_1__bindgen_ty_2,
    pub kern: asm_state__bindgen_ty_1__bindgen_ty_3,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asm_state__bindgen_ty_1__bindgen_ty_1 {
    pub mark_lookup: *mut otlookup,
    pub cur_lookup: *mut otlookup,
}
#[test]
fn bindgen_test_layout_asm_state__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<asm_state__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(asm_state__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<asm_state__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(asm_state__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asm_state__bindgen_ty_1__bindgen_ty_1>())).mark_lookup
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asm_state__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(mark_lookup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asm_state__bindgen_ty_1__bindgen_ty_1>())).cur_lookup as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(asm_state__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(cur_lookup)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asm_state__bindgen_ty_1__bindgen_ty_2 {
    pub mark_ins: *mut ::std::os::raw::c_char,
    pub cur_ins: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_asm_state__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<asm_state__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(asm_state__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<asm_state__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(asm_state__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asm_state__bindgen_ty_1__bindgen_ty_2>())).mark_ins as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asm_state__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(mark_ins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asm_state__bindgen_ty_1__bindgen_ty_2>())).cur_ins as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(asm_state__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(cur_ins)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asm_state__bindgen_ty_1__bindgen_ty_3 {
    pub kerns: *mut int16,
    pub kcnt: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_asm_state__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<asm_state__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(asm_state__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<asm_state__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(asm_state__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asm_state__bindgen_ty_1__bindgen_ty_3>())).kerns as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asm_state__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(kerns)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asm_state__bindgen_ty_1__bindgen_ty_3>())).kcnt as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(asm_state__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(kcnt)
        )
    );
}
#[test]
fn bindgen_test_layout_asm_state__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<asm_state__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(asm_state__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<asm_state__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(asm_state__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asm_state__bindgen_ty_1>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asm_state__bindgen_ty_1),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asm_state__bindgen_ty_1>())).insert as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asm_state__bindgen_ty_1),
            "::",
            stringify!(insert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asm_state__bindgen_ty_1>())).kern as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asm_state__bindgen_ty_1),
            "::",
            stringify!(kern)
        )
    );
}
#[test]
fn bindgen_test_layout_asm_state() {
    assert_eq!(
        ::std::mem::size_of::<asm_state>(),
        24usize,
        concat!("Size of: ", stringify!(asm_state))
    );
    assert_eq!(
        ::std::mem::align_of::<asm_state>(),
        8usize,
        concat!("Alignment of ", stringify!(asm_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asm_state>())).next_state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asm_state),
            "::",
            stringify!(next_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asm_state>())).flags as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(asm_state),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asm_state>())).u as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(asm_state),
            "::",
            stringify!(u)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct generic_asm {
    pub next: *mut generic_asm,
    pub type_: uint16,
    pub subtable: *mut lookup_subtable,
    pub flags: uint16,
    pub ticked: uint8,
    pub class_cnt: uint16,
    pub state_cnt: uint16,
    pub classes: *mut *mut ::std::os::raw::c_char,
    pub state: *mut asm_state,
}
#[test]
fn bindgen_test_layout_generic_asm() {
    assert_eq!(
        ::std::mem::size_of::<generic_asm>(),
        48usize,
        concat!("Size of: ", stringify!(generic_asm))
    );
    assert_eq!(
        ::std::mem::align_of::<generic_asm>(),
        8usize,
        concat!("Alignment of ", stringify!(generic_asm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_asm>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_asm),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_asm>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_asm),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_asm>())).subtable as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_asm),
            "::",
            stringify!(subtable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_asm>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_asm),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_asm>())).ticked as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_asm),
            "::",
            stringify!(ticked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_asm>())).class_cnt as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_asm),
            "::",
            stringify!(class_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_asm>())).state_cnt as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_asm),
            "::",
            stringify!(state_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_asm>())).classes as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_asm),
            "::",
            stringify!(classes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generic_asm>())).state as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(generic_asm),
            "::",
            stringify!(state)
        )
    );
}
pub type ASM = generic_asm;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jstf_prio {
    pub enableShrink: *mut *mut OTLookup,
    pub disableShrink: *mut *mut OTLookup,
    pub maxShrink: *mut *mut OTLookup,
    pub enableExtend: *mut *mut OTLookup,
    pub disableExtend: *mut *mut OTLookup,
    pub maxExtend: *mut *mut OTLookup,
}
#[test]
fn bindgen_test_layout_jstf_prio() {
    assert_eq!(
        ::std::mem::size_of::<jstf_prio>(),
        48usize,
        concat!("Size of: ", stringify!(jstf_prio))
    );
    assert_eq!(
        ::std::mem::align_of::<jstf_prio>(),
        8usize,
        concat!("Alignment of ", stringify!(jstf_prio))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jstf_prio>())).enableShrink as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jstf_prio),
            "::",
            stringify!(enableShrink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jstf_prio>())).disableShrink as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jstf_prio),
            "::",
            stringify!(disableShrink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jstf_prio>())).maxShrink as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(jstf_prio),
            "::",
            stringify!(maxShrink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jstf_prio>())).enableExtend as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(jstf_prio),
            "::",
            stringify!(enableExtend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jstf_prio>())).disableExtend as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(jstf_prio),
            "::",
            stringify!(disableExtend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jstf_prio>())).maxExtend as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(jstf_prio),
            "::",
            stringify!(maxExtend)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jstf_lang {
    pub lang: uint32,
    pub next: *mut jstf_lang,
    pub cnt: ::std::os::raw::c_int,
    pub prios: *mut jstf_prio,
}
#[test]
fn bindgen_test_layout_jstf_lang() {
    assert_eq!(
        ::std::mem::size_of::<jstf_lang>(),
        32usize,
        concat!("Size of: ", stringify!(jstf_lang))
    );
    assert_eq!(
        ::std::mem::align_of::<jstf_lang>(),
        8usize,
        concat!("Alignment of ", stringify!(jstf_lang))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jstf_lang>())).lang as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jstf_lang),
            "::",
            stringify!(lang)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jstf_lang>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jstf_lang),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jstf_lang>())).cnt as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(jstf_lang),
            "::",
            stringify!(cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jstf_lang>())).prios as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(jstf_lang),
            "::",
            stringify!(prios)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jstf_script {
    pub script: uint32,
    pub next: *mut jstf_script,
    pub extenders: *mut ::std::os::raw::c_char,
    pub langs: *mut jstf_lang,
}
#[test]
fn bindgen_test_layout_jstf_script() {
    assert_eq!(
        ::std::mem::size_of::<jstf_script>(),
        32usize,
        concat!("Size of: ", stringify!(jstf_script))
    );
    assert_eq!(
        ::std::mem::align_of::<jstf_script>(),
        8usize,
        concat!("Alignment of ", stringify!(jstf_script))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jstf_script>())).script as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jstf_script),
            "::",
            stringify!(script)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jstf_script>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jstf_script),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jstf_script>())).extenders as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(jstf_script),
            "::",
            stringify!(extenders)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jstf_script>())).langs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(jstf_script),
            "::",
            stringify!(langs)
        )
    );
}
pub type Justify = jstf_script;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opentype_str {
    pub sc: *mut splinechar,
    pub vr: vr,
    pub kp: *mut kernpair,
    pub kc: *mut kernclass,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub advance_width: int16,
    pub kc_index: int16,
    pub lig_pos: int16,
    pub context_pos: int16,
    pub orig_index: int32,
    pub fl: *mut ::std::os::raw::c_void,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub bsln_off: int16,
}
#[test]
fn bindgen_test_layout_opentype_str() {
    assert_eq!(
        ::std::mem::size_of::<opentype_str>(),
        72usize,
        concat!("Size of: ", stringify!(opentype_str))
    );
    assert_eq!(
        ::std::mem::align_of::<opentype_str>(),
        8usize,
        concat!("Alignment of ", stringify!(opentype_str))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opentype_str>())).sc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(opentype_str),
            "::",
            stringify!(sc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opentype_str>())).vr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(opentype_str),
            "::",
            stringify!(vr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opentype_str>())).kp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(opentype_str),
            "::",
            stringify!(kp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opentype_str>())).kc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(opentype_str),
            "::",
            stringify!(kc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opentype_str>())).advance_width as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(opentype_str),
            "::",
            stringify!(advance_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opentype_str>())).kc_index as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(opentype_str),
            "::",
            stringify!(kc_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opentype_str>())).lig_pos as *const _ as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(opentype_str),
            "::",
            stringify!(lig_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opentype_str>())).context_pos as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(opentype_str),
            "::",
            stringify!(context_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opentype_str>())).orig_index as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(opentype_str),
            "::",
            stringify!(orig_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opentype_str>())).fl as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(opentype_str),
            "::",
            stringify!(fl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opentype_str>())).bsln_off as *const _ as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(opentype_str),
            "::",
            stringify!(bsln_off)
        )
    );
}
impl opentype_str {
    #[inline]
    pub fn prev_kc0(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_prev_kc0(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn next_kc0(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_next_kc0(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        prev_kc0: ::std::os::raw::c_uint,
        next_kc0: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let prev_kc0: u32 = unsafe { ::std::mem::transmute(prev_kc0) };
            prev_kc0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let next_kc0: u32 = unsafe { ::std::mem::transmute(next_kc0) };
            next_kc0 as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn line_break_after(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_line_break_after(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn r2l(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_r2l(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        line_break_after: ::std::os::raw::c_uint,
        r2l: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let line_break_after: u32 = unsafe { ::std::mem::transmute(line_break_after) };
            line_break_after as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let r2l: u32 = unsafe { ::std::mem::transmute(r2l) };
            r2l as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct macname {
    pub next: *mut macname,
    pub enc: uint16,
    pub lang: uint16,
    pub name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_macname() {
    assert_eq!(
        ::std::mem::size_of::<macname>(),
        24usize,
        concat!("Size of: ", stringify!(macname))
    );
    assert_eq!(
        ::std::mem::align_of::<macname>(),
        8usize,
        concat!("Alignment of ", stringify!(macname))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<macname>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(macname),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<macname>())).enc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(macname),
            "::",
            stringify!(enc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<macname>())).lang as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(macname),
            "::",
            stringify!(lang)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<macname>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(macname),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otfname {
    pub next: *mut otfname,
    pub lang: uint16,
    pub name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_otfname() {
    assert_eq!(
        ::std::mem::size_of::<otfname>(),
        24usize,
        concat!("Size of: ", stringify!(otfname))
    );
    assert_eq!(
        ::std::mem::align_of::<otfname>(),
        8usize,
        concat!("Alignment of ", stringify!(otfname))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<otfname>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(otfname),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<otfname>())).lang as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(otfname),
            "::",
            stringify!(lang)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<otfname>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(otfname),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otffeatname {
    pub tag: uint32,
    pub names: *mut otfname,
    pub next: *mut otffeatname,
    pub nid: uint16,
}
#[test]
fn bindgen_test_layout_otffeatname() {
    assert_eq!(
        ::std::mem::size_of::<otffeatname>(),
        32usize,
        concat!("Size of: ", stringify!(otffeatname))
    );
    assert_eq!(
        ::std::mem::align_of::<otffeatname>(),
        8usize,
        concat!("Alignment of ", stringify!(otffeatname))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<otffeatname>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(otffeatname),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<otffeatname>())).names as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(otffeatname),
            "::",
            stringify!(names)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<otffeatname>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(otffeatname),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<otffeatname>())).nid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(otffeatname),
            "::",
            stringify!(nid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct macsetting {
    pub next: *mut macsetting,
    pub setting: uint16,
    pub strid: uint16,
    pub setname: *mut macname,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_macsetting() {
    assert_eq!(
        ::std::mem::size_of::<macsetting>(),
        32usize,
        concat!("Size of: ", stringify!(macsetting))
    );
    assert_eq!(
        ::std::mem::align_of::<macsetting>(),
        8usize,
        concat!("Alignment of ", stringify!(macsetting))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<macsetting>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(macsetting),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<macsetting>())).setting as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(macsetting),
            "::",
            stringify!(setting)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<macsetting>())).strid as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(macsetting),
            "::",
            stringify!(strid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<macsetting>())).setname as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(macsetting),
            "::",
            stringify!(setname)
        )
    );
}
impl macsetting {
    #[inline]
    pub fn initially_enabled(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_initially_enabled(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        initially_enabled: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let initially_enabled: u32 = unsafe { ::std::mem::transmute(initially_enabled) };
            initially_enabled as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct macfeat {
    pub next: *mut macfeat,
    pub feature: uint16,
    pub ismutex: uint8,
    pub default_setting: uint8,
    pub strid: uint16,
    pub featname: *mut macname,
    pub settings: *mut macsetting,
}
#[test]
fn bindgen_test_layout_macfeat() {
    assert_eq!(
        ::std::mem::size_of::<macfeat>(),
        32usize,
        concat!("Size of: ", stringify!(macfeat))
    );
    assert_eq!(
        ::std::mem::align_of::<macfeat>(),
        8usize,
        concat!("Alignment of ", stringify!(macfeat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<macfeat>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(macfeat),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<macfeat>())).feature as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(macfeat),
            "::",
            stringify!(feature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<macfeat>())).ismutex as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(macfeat),
            "::",
            stringify!(ismutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<macfeat>())).default_setting as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(macfeat),
            "::",
            stringify!(default_setting)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<macfeat>())).strid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(macfeat),
            "::",
            stringify!(strid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<macfeat>())).featname as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(macfeat),
            "::",
            stringify!(featname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<macfeat>())).settings as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(macfeat),
            "::",
            stringify!(settings)
        )
    );
}
pub type MacFeat = macfeat;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct refbdfc {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub xoff: int8,
    pub yoff: int8,
    pub gid: uint16,
    pub next: *mut refbdfc,
    pub bdfc: *mut bdfchar,
}
#[test]
fn bindgen_test_layout_refbdfc() {
    assert_eq!(
        ::std::mem::size_of::<refbdfc>(),
        24usize,
        concat!("Size of: ", stringify!(refbdfc))
    );
    assert_eq!(
        ::std::mem::align_of::<refbdfc>(),
        8usize,
        concat!("Alignment of ", stringify!(refbdfc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<refbdfc>())).xoff as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(refbdfc),
            "::",
            stringify!(xoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<refbdfc>())).yoff as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(refbdfc),
            "::",
            stringify!(yoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<refbdfc>())).gid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(refbdfc),
            "::",
            stringify!(gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<refbdfc>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(refbdfc),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<refbdfc>())).bdfc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(refbdfc),
            "::",
            stringify!(bdfc)
        )
    );
}
impl refbdfc {
    #[inline]
    pub fn checked(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_checked(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn selected(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_selected(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        checked: ::std::os::raw::c_uint,
        selected: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let checked: u32 = unsafe { ::std::mem::transmute(checked) };
            checked as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let selected: u32 = unsafe { ::std::mem::transmute(selected) };
            selected as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type BDFRefChar = refbdfc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bdfcharlist {
    pub bc: *mut bdfchar,
    pub next: *mut bdfcharlist,
}
#[test]
fn bindgen_test_layout_bdfcharlist() {
    assert_eq!(
        ::std::mem::size_of::<bdfcharlist>(),
        16usize,
        concat!("Size of: ", stringify!(bdfcharlist))
    );
    assert_eq!(
        ::std::mem::align_of::<bdfcharlist>(),
        8usize,
        concat!("Alignment of ", stringify!(bdfcharlist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdfcharlist>())).bc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bdfcharlist),
            "::",
            stringify!(bc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdfcharlist>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bdfcharlist),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bdfchar {
    pub sc: *mut splinechar,
    pub xmin: int16,
    pub xmax: int16,
    pub ymin: int16,
    pub ymax: int16,
    pub width: int16,
    pub bytes_per_line: int16,
    pub bitmap: *mut uint8,
    pub refs: *mut refbdfc,
    pub orig_pos: ::std::os::raw::c_int,
    pub pixelsize: int16,
    pub views: *mut bitmapview,
    pub undoes: *mut undoes,
    pub redoes: *mut undoes,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub depth: uint8,
    pub vwidth: uint16,
    pub selection: *mut BDFFloat,
    pub backup: *mut BDFFloat,
    pub dependents: *mut bdfcharlist,
}
#[test]
fn bindgen_test_layout_bdfchar() {
    assert_eq!(
        ::std::mem::size_of::<bdfchar>(),
        104usize,
        concat!("Size of: ", stringify!(bdfchar))
    );
    assert_eq!(
        ::std::mem::align_of::<bdfchar>(),
        8usize,
        concat!("Alignment of ", stringify!(bdfchar))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdfchar>())).sc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bdfchar),
            "::",
            stringify!(sc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdfchar>())).xmin as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bdfchar),
            "::",
            stringify!(xmin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdfchar>())).xmax as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(bdfchar),
            "::",
            stringify!(xmax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdfchar>())).ymin as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bdfchar),
            "::",
            stringify!(ymin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdfchar>())).ymax as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(bdfchar),
            "::",
            stringify!(ymax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdfchar>())).width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bdfchar),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdfchar>())).bytes_per_line as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(bdfchar),
            "::",
            stringify!(bytes_per_line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdfchar>())).bitmap as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bdfchar),
            "::",
            stringify!(bitmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdfchar>())).refs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bdfchar),
            "::",
            stringify!(refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdfchar>())).orig_pos as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bdfchar),
            "::",
            stringify!(orig_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdfchar>())).pixelsize as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(bdfchar),
            "::",
            stringify!(pixelsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdfchar>())).views as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bdfchar),
            "::",
            stringify!(views)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdfchar>())).undoes as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(bdfchar),
            "::",
            stringify!(undoes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdfchar>())).redoes as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(bdfchar),
            "::",
            stringify!(redoes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdfchar>())).depth as *const _ as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(bdfchar),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdfchar>())).vwidth as *const _ as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(bdfchar),
            "::",
            stringify!(vwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdfchar>())).selection as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(bdfchar),
            "::",
            stringify!(selection)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdfchar>())).backup as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(bdfchar),
            "::",
            stringify!(backup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdfchar>())).dependents as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(bdfchar),
            "::",
            stringify!(dependents)
        )
    );
}
impl bdfchar {
    #[inline]
    pub fn changed(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_changed(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn byte_data(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_byte_data(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn widthgroup(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_widthgroup(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isreference(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isreference(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ticked(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ticked(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        changed: ::std::os::raw::c_uint,
        byte_data: ::std::os::raw::c_uint,
        widthgroup: ::std::os::raw::c_uint,
        isreference: ::std::os::raw::c_uint,
        ticked: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let changed: u32 = unsafe { ::std::mem::transmute(changed) };
            changed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let byte_data: u32 = unsafe { ::std::mem::transmute(byte_data) };
            byte_data as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let widthgroup: u32 = unsafe { ::std::mem::transmute(widthgroup) };
            widthgroup as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let isreference: u32 = unsafe { ::std::mem::transmute(isreference) };
            isreference as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ticked: u32 = unsafe { ::std::mem::transmute(ticked) };
            ticked as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type BDFChar = bdfchar;
pub const undotype_ut_none: undotype = 0;
pub const undotype_ut_state: undotype = 1;
pub const undotype_ut_tstate: undotype = 2;
pub const undotype_ut_statehint: undotype = 3;
pub const undotype_ut_statename: undotype = 4;
pub const undotype_ut_statelookup: undotype = 5;
pub const undotype_ut_anchors: undotype = 6;
pub const undotype_ut_width: undotype = 7;
pub const undotype_ut_vwidth: undotype = 8;
pub const undotype_ut_lbearing: undotype = 9;
pub const undotype_ut_rbearing: undotype = 10;
pub const undotype_ut_possub: undotype = 11;
pub const undotype_ut_hints: undotype = 12;
pub const undotype_ut_bitmap: undotype = 13;
pub const undotype_ut_bitmapsel: undotype = 14;
pub const undotype_ut_composit: undotype = 15;
pub const undotype_ut_multiple: undotype = 16;
pub const undotype_ut_layers: undotype = 17;
pub const undotype_ut_noop: undotype = 18;
pub type undotype = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct undoes {
    pub next: *mut undoes,
    pub undotype: undotype,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub layer: ::std::os::raw::c_int,
    pub u: undoes__bindgen_ty_1,
    pub copied_from: *mut splinefont,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union undoes__bindgen_ty_1 {
    pub state: undoes__bindgen_ty_1__bindgen_ty_1,
    pub width: ::std::os::raw::c_int,
    pub lbearing: ::std::os::raw::c_int,
    pub rbearing: ::std::os::raw::c_int,
    pub bmpstate: BDFChar,
    pub composit: undoes__bindgen_ty_1__bindgen_ty_2,
    pub multiple: undoes__bindgen_ty_1__bindgen_ty_3,
    pub possub: undoes__bindgen_ty_1__bindgen_ty_4,
    pub bitmap: *mut uint8,
    _bindgen_union_align: [u64; 25usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct undoes__bindgen_ty_1__bindgen_ty_1 {
    pub width: int16,
    pub vwidth: int16,
    pub lbearingchange: int16,
    pub unicodeenc: ::std::os::raw::c_int,
    pub charname: *mut ::std::os::raw::c_char,
    pub comment: *mut ::std::os::raw::c_char,
    pub possub: *mut PST,
    pub splines: *mut splinepointlist,
    pub refs: *mut refchar,
    pub images: *mut imagelist,
    pub hints: *mut ::std::os::raw::c_void,
    pub instrs: *mut uint8,
    pub instrs_len: ::std::os::raw::c_int,
    pub anchor: *mut AnchorPoint,
    pub fill_brush: brush,
    pub stroke_pen: pen,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_undoes__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<undoes__bindgen_ty_1__bindgen_ty_1>(),
        200usize,
        concat!("Size of: ", stringify!(undoes__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<undoes__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(undoes__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<undoes__bindgen_ty_1__bindgen_ty_1>())).width as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<undoes__bindgen_ty_1__bindgen_ty_1>())).vwidth as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(vwidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<undoes__bindgen_ty_1__bindgen_ty_1>())).lbearingchange
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(lbearingchange)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<undoes__bindgen_ty_1__bindgen_ty_1>())).unicodeenc as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(unicodeenc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<undoes__bindgen_ty_1__bindgen_ty_1>())).charname as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(charname)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<undoes__bindgen_ty_1__bindgen_ty_1>())).comment as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(comment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<undoes__bindgen_ty_1__bindgen_ty_1>())).possub as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(possub)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<undoes__bindgen_ty_1__bindgen_ty_1>())).splines as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(splines)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<undoes__bindgen_ty_1__bindgen_ty_1>())).refs as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(refs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<undoes__bindgen_ty_1__bindgen_ty_1>())).images as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(images)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<undoes__bindgen_ty_1__bindgen_ty_1>())).hints as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(hints)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<undoes__bindgen_ty_1__bindgen_ty_1>())).instrs as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(instrs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<undoes__bindgen_ty_1__bindgen_ty_1>())).instrs_len as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(instrs_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<undoes__bindgen_ty_1__bindgen_ty_1>())).anchor as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(anchor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<undoes__bindgen_ty_1__bindgen_ty_1>())).fill_brush as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(fill_brush)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<undoes__bindgen_ty_1__bindgen_ty_1>())).stroke_pen as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(stroke_pen)
        )
    );
}
impl undoes__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn dofill(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dofill(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dostroke(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dostroke(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fillfirst(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fillfirst(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        dofill: ::std::os::raw::c_uint,
        dostroke: ::std::os::raw::c_uint,
        fillfirst: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let dofill: u32 = unsafe { ::std::mem::transmute(dofill) };
            dofill as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let dostroke: u32 = unsafe { ::std::mem::transmute(dostroke) };
            dostroke as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let fillfirst: u32 = unsafe { ::std::mem::transmute(fillfirst) };
            fillfirst as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct undoes__bindgen_ty_1__bindgen_ty_2 {
    pub state: *mut undoes,
    pub bitmaps: *mut undoes,
}
#[test]
fn bindgen_test_layout_undoes__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<undoes__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(undoes__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<undoes__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(undoes__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<undoes__bindgen_ty_1__bindgen_ty_2>())).state as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<undoes__bindgen_ty_1__bindgen_ty_2>())).bitmaps as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(bitmaps)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct undoes__bindgen_ty_1__bindgen_ty_3 {
    pub mult: *mut undoes,
}
#[test]
fn bindgen_test_layout_undoes__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<undoes__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(undoes__bindgen_ty_1__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<undoes__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(undoes__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<undoes__bindgen_ty_1__bindgen_ty_3>())).mult as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(mult)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct undoes__bindgen_ty_1__bindgen_ty_4 {
    pub pst: possub_type,
    pub data: *mut *mut ::std::os::raw::c_char,
    pub more_pst: *mut undoes,
    pub cnt: ::std::os::raw::c_short,
    pub max: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_undoes__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<undoes__bindgen_ty_1__bindgen_ty_4>(),
        32usize,
        concat!("Size of: ", stringify!(undoes__bindgen_ty_1__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<undoes__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(undoes__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<undoes__bindgen_ty_1__bindgen_ty_4>())).pst as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(pst)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<undoes__bindgen_ty_1__bindgen_ty_4>())).data as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<undoes__bindgen_ty_1__bindgen_ty_4>())).more_pst as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(more_pst)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<undoes__bindgen_ty_1__bindgen_ty_4>())).cnt as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(cnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<undoes__bindgen_ty_1__bindgen_ty_4>())).max as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(max)
        )
    );
}
#[test]
fn bindgen_test_layout_undoes__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<undoes__bindgen_ty_1>(),
        200usize,
        concat!("Size of: ", stringify!(undoes__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<undoes__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(undoes__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<undoes__bindgen_ty_1>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes__bindgen_ty_1),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<undoes__bindgen_ty_1>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes__bindgen_ty_1),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<undoes__bindgen_ty_1>())).lbearing as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes__bindgen_ty_1),
            "::",
            stringify!(lbearing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<undoes__bindgen_ty_1>())).rbearing as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes__bindgen_ty_1),
            "::",
            stringify!(rbearing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<undoes__bindgen_ty_1>())).bmpstate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes__bindgen_ty_1),
            "::",
            stringify!(bmpstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<undoes__bindgen_ty_1>())).composit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes__bindgen_ty_1),
            "::",
            stringify!(composit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<undoes__bindgen_ty_1>())).multiple as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes__bindgen_ty_1),
            "::",
            stringify!(multiple)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<undoes__bindgen_ty_1>())).possub as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes__bindgen_ty_1),
            "::",
            stringify!(possub)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<undoes__bindgen_ty_1>())).bitmap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes__bindgen_ty_1),
            "::",
            stringify!(bitmap)
        )
    );
}
#[test]
fn bindgen_test_layout_undoes() {
    assert_eq!(
        ::std::mem::size_of::<undoes>(),
        232usize,
        concat!("Size of: ", stringify!(undoes))
    );
    assert_eq!(
        ::std::mem::align_of::<undoes>(),
        8usize,
        concat!("Alignment of ", stringify!(undoes))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<undoes>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<undoes>())).undotype as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes),
            "::",
            stringify!(undotype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<undoes>())).layer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes),
            "::",
            stringify!(layer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<undoes>())).u as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(undoes), "::", stringify!(u))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<undoes>())).copied_from as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(undoes),
            "::",
            stringify!(copied_from)
        )
    );
}
impl undoes {
    #[inline]
    pub fn was_modified(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_was_modified(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn was_order2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_was_order2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        was_modified: ::std::os::raw::c_uint,
        was_order2: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let was_modified: u32 = unsafe { ::std::mem::transmute(was_modified) };
            was_modified as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let was_order2: u32 = unsafe { ::std::mem::transmute(was_order2) };
            was_order2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type Undoes = undoes;
pub const sfundotype_sfut_none: sfundotype = 0;
pub const sfundotype_sfut_lookups: sfundotype = 1;
pub const sfundotype_sfut_lookups_kerns: sfundotype = 2;
pub const sfundotype_sfut_fontinfo: sfundotype = 3;
pub const sfundotype_sfut_noop: sfundotype = 4;
pub type sfundotype = ::std::os::raw::c_uint;
#[doc = " A spline font level undo stack. undoes are doubly linked using the"]
#[doc = " 'ln' member and carry some user presentable description of what the"]
#[doc = " undo relates to in 'msg'."]
#[doc = ""]
#[doc = " The sfdchunk is a pointer to an SFD fragment which will apply the"]
#[doc = " undo to the current state. For example, it might contain"]
#[doc = " information about the old value of kerning pairs which can be used"]
#[doc = " to restore state to how it was. Note that the sfdchunk might only"]
#[doc = " be partial, containing only enough information to restore the state"]
#[doc = " which changed when the undo was created."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sfundoes {
    pub ln: dlistnode,
    pub msg: *mut ::std::os::raw::c_char,
    pub type_: sfundotype,
    pub u: sfundoes__bindgen_ty_1,
    pub sfdchunk: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sfundoes__bindgen_ty_1 {
    pub dummy: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_sfundoes__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sfundoes__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(sfundoes__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sfundoes__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(sfundoes__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sfundoes__bindgen_ty_1>())).dummy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sfundoes__bindgen_ty_1),
            "::",
            stringify!(dummy)
        )
    );
}
#[test]
fn bindgen_test_layout_sfundoes() {
    assert_eq!(
        ::std::mem::size_of::<sfundoes>(),
        40usize,
        concat!("Size of: ", stringify!(sfundoes))
    );
    assert_eq!(
        ::std::mem::align_of::<sfundoes>(),
        8usize,
        concat!("Alignment of ", stringify!(sfundoes))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sfundoes>())).ln as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sfundoes),
            "::",
            stringify!(ln)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sfundoes>())).msg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sfundoes),
            "::",
            stringify!(msg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sfundoes>())).type_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sfundoes),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sfundoes>())).u as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sfundoes),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sfundoes>())).sfdchunk as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sfundoes),
            "::",
            stringify!(sfdchunk)
        )
    );
}
#[doc = " A spline font level undo stack. undoes are doubly linked using the"]
#[doc = " 'ln' member and carry some user presentable description of what the"]
#[doc = " undo relates to in 'msg'."]
#[doc = ""]
#[doc = " The sfdchunk is a pointer to an SFD fragment which will apply the"]
#[doc = " undo to the current state. For example, it might contain"]
#[doc = " information about the old value of kerning pairs which can be used"]
#[doc = " to restore state to how it was. Note that the sfdchunk might only"]
#[doc = " be partial, containing only enough information to restore the state"]
#[doc = " which changed when the undo was created."]
pub type SFUndoes = sfundoes;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct enc {
    pub enc_name: *mut ::std::os::raw::c_char,
    pub char_cnt: ::std::os::raw::c_int,
    pub unicode: *mut int32,
    pub psnames: *mut *mut ::std::os::raw::c_char,
    pub next: *mut enc,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub iso_2022_escape: [::std::os::raw::c_char; 8usize],
    pub iso_2022_escape_len: ::std::os::raw::c_int,
    pub low_page: ::std::os::raw::c_int,
    pub high_page: ::std::os::raw::c_int,
    pub iconv_name: *mut ::std::os::raw::c_char,
    pub tounicode: *mut iconv_t,
    pub fromunicode: *mut iconv_t,
    pub tounicode_func: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
    >,
    pub fromunicode_func: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
    >,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub char_max: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_enc() {
    assert_eq!(
        ::std::mem::size_of::<enc>(),
        112usize,
        concat!("Size of: ", stringify!(enc))
    );
    assert_eq!(
        ::std::mem::align_of::<enc>(),
        8usize,
        concat!("Alignment of ", stringify!(enc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<enc>())).enc_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(enc),
            "::",
            stringify!(enc_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<enc>())).char_cnt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(enc),
            "::",
            stringify!(char_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<enc>())).unicode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(enc),
            "::",
            stringify!(unicode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<enc>())).psnames as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(enc),
            "::",
            stringify!(psnames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<enc>())).next as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(enc), "::", stringify!(next))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<enc>())).iso_2022_escape as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(enc),
            "::",
            stringify!(iso_2022_escape)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<enc>())).iso_2022_escape_len as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(enc),
            "::",
            stringify!(iso_2022_escape_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<enc>())).low_page as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(enc),
            "::",
            stringify!(low_page)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<enc>())).high_page as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(enc),
            "::",
            stringify!(high_page)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<enc>())).iconv_name as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(enc),
            "::",
            stringify!(iconv_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<enc>())).tounicode as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(enc),
            "::",
            stringify!(tounicode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<enc>())).fromunicode as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(enc),
            "::",
            stringify!(fromunicode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<enc>())).tounicode_func as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(enc),
            "::",
            stringify!(tounicode_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<enc>())).fromunicode_func as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(enc),
            "::",
            stringify!(fromunicode_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<enc>())).char_max as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(enc),
            "::",
            stringify!(char_max)
        )
    );
}
impl enc {
    #[inline]
    pub fn builtin(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_builtin(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hidden(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hidden(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn only_1byte(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_only_1byte(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_1byte(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_1byte(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_2byte(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_2byte(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_unicodebmp(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_unicodebmp(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_unicodefull(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_unicodefull(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_custom(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_custom(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_original(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_original(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_compact(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_compact(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_japanese(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_japanese(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_korean(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_korean(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_tradchinese(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_tradchinese(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_simplechinese(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_simplechinese(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        builtin: ::std::os::raw::c_uint,
        hidden: ::std::os::raw::c_uint,
        only_1byte: ::std::os::raw::c_uint,
        has_1byte: ::std::os::raw::c_uint,
        has_2byte: ::std::os::raw::c_uint,
        is_unicodebmp: ::std::os::raw::c_uint,
        is_unicodefull: ::std::os::raw::c_uint,
        is_custom: ::std::os::raw::c_uint,
        is_original: ::std::os::raw::c_uint,
        is_compact: ::std::os::raw::c_uint,
        is_japanese: ::std::os::raw::c_uint,
        is_korean: ::std::os::raw::c_uint,
        is_tradchinese: ::std::os::raw::c_uint,
        is_simplechinese: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let builtin: u32 = unsafe { ::std::mem::transmute(builtin) };
            builtin as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hidden: u32 = unsafe { ::std::mem::transmute(hidden) };
            hidden as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let only_1byte: u32 = unsafe { ::std::mem::transmute(only_1byte) };
            only_1byte as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let has_1byte: u32 = unsafe { ::std::mem::transmute(has_1byte) };
            has_1byte as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let has_2byte: u32 = unsafe { ::std::mem::transmute(has_2byte) };
            has_2byte as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is_unicodebmp: u32 = unsafe { ::std::mem::transmute(is_unicodebmp) };
            is_unicodebmp as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let is_unicodefull: u32 = unsafe { ::std::mem::transmute(is_unicodefull) };
            is_unicodefull as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let is_custom: u32 = unsafe { ::std::mem::transmute(is_custom) };
            is_custom as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let is_original: u32 = unsafe { ::std::mem::transmute(is_original) };
            is_original as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let is_compact: u32 = unsafe { ::std::mem::transmute(is_compact) };
            is_compact as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let is_japanese: u32 = unsafe { ::std::mem::transmute(is_japanese) };
            is_japanese as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let is_korean: u32 = unsafe { ::std::mem::transmute(is_korean) };
            is_korean as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let is_tradchinese: u32 = unsafe { ::std::mem::transmute(is_tradchinese) };
            is_tradchinese as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let is_simplechinese: u32 = unsafe { ::std::mem::transmute(is_simplechinese) };
            is_simplechinese as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn is_temporary(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_temporary(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        is_temporary: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_temporary: u32 = unsafe { ::std::mem::transmute(is_temporary) };
            is_temporary as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type Encoding = enc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct renames {
    pub from: *mut ::std::os::raw::c_char,
    pub to: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_renames() {
    assert_eq!(
        ::std::mem::size_of::<renames>(),
        16usize,
        concat!("Size of: ", stringify!(renames))
    );
    assert_eq!(
        ::std::mem::align_of::<renames>(),
        8usize,
        concat!("Alignment of ", stringify!(renames))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<renames>())).from as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(renames),
            "::",
            stringify!(from)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<renames>())).to as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(renames),
            "::",
            stringify!(to)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct namelist {
    pub basedon: *mut namelist,
    pub title: *mut ::std::os::raw::c_char,
    pub unicode: [*mut *mut *const ::std::os::raw::c_char; 17usize],
    pub next: *mut namelist,
    pub renames: *mut renames,
    pub uses_unicode: ::std::os::raw::c_int,
    pub a_utf8_name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_namelist() {
    assert_eq!(
        ::std::mem::size_of::<namelist>(),
        184usize,
        concat!("Size of: ", stringify!(namelist))
    );
    assert_eq!(
        ::std::mem::align_of::<namelist>(),
        8usize,
        concat!("Alignment of ", stringify!(namelist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<namelist>())).basedon as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(namelist),
            "::",
            stringify!(basedon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<namelist>())).title as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(namelist),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<namelist>())).unicode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(namelist),
            "::",
            stringify!(unicode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<namelist>())).next as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(namelist),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<namelist>())).renames as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(namelist),
            "::",
            stringify!(renames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<namelist>())).uses_unicode as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(namelist),
            "::",
            stringify!(uses_unicode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<namelist>())).a_utf8_name as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(namelist),
            "::",
            stringify!(a_utf8_name)
        )
    );
}
pub type NameList = namelist;
pub const uni_interp_ui_unset: uni_interp = -1;
pub const uni_interp_ui_none: uni_interp = 0;
pub const uni_interp_ui_adobe: uni_interp = 1;
pub const uni_interp_ui_greek: uni_interp = 2;
pub const uni_interp_ui_japanese: uni_interp = 3;
pub const uni_interp_ui_trad_chinese: uni_interp = 4;
pub const uni_interp_ui_simp_chinese: uni_interp = 5;
pub const uni_interp_ui_korean: uni_interp = 6;
pub const uni_interp_ui_ams: uni_interp = 7;
pub type uni_interp = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct remap {
    pub firstenc: uint32,
    pub lastenc: uint32,
    pub infont: int32,
}
#[test]
fn bindgen_test_layout_remap() {
    assert_eq!(
        ::std::mem::size_of::<remap>(),
        12usize,
        concat!("Size of: ", stringify!(remap))
    );
    assert_eq!(
        ::std::mem::align_of::<remap>(),
        4usize,
        concat!("Alignment of ", stringify!(remap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<remap>())).firstenc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(remap),
            "::",
            stringify!(firstenc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<remap>())).lastenc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(remap),
            "::",
            stringify!(lastenc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<remap>())).infont as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(remap),
            "::",
            stringify!(infont)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct encmap {
    pub map: *mut int32,
    pub backmap: *mut int32,
    pub enccount: ::std::os::raw::c_int,
    pub encmax: ::std::os::raw::c_int,
    pub backmax: ::std::os::raw::c_int,
    pub remap: *mut remap,
    pub enc: *mut Encoding,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_encmap() {
    assert_eq!(
        ::std::mem::size_of::<encmap>(),
        56usize,
        concat!("Size of: ", stringify!(encmap))
    );
    assert_eq!(
        ::std::mem::align_of::<encmap>(),
        8usize,
        concat!("Alignment of ", stringify!(encmap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<encmap>())).map as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(encmap),
            "::",
            stringify!(map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<encmap>())).backmap as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(encmap),
            "::",
            stringify!(backmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<encmap>())).enccount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(encmap),
            "::",
            stringify!(enccount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<encmap>())).encmax as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(encmap),
            "::",
            stringify!(encmax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<encmap>())).backmax as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(encmap),
            "::",
            stringify!(backmax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<encmap>())).remap as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(encmap),
            "::",
            stringify!(remap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<encmap>())).enc as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(encmap),
            "::",
            stringify!(enc)
        )
    );
}
impl encmap {
    #[inline]
    pub fn ticked(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ticked(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ticked: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ticked: u32 = unsafe { ::std::mem::transmute(ticked) };
            ticked as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type EncMap = encmap;
pub const property_type_prt_string: property_type = 0;
pub const property_type_prt_atom: property_type = 1;
pub const property_type_prt_int: property_type = 2;
pub const property_type_prt_uint: property_type = 3;
pub const property_type_prt_property: property_type = 16;
pub type property_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bdfprops {
    pub name: *mut ::std::os::raw::c_char,
    pub type_: ::std::os::raw::c_int,
    pub u: bdfprops__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bdfprops__bindgen_ty_1 {
    pub str_: *mut ::std::os::raw::c_char,
    pub atom: *mut ::std::os::raw::c_char,
    pub val: ::std::os::raw::c_int,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_bdfprops__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<bdfprops__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(bdfprops__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<bdfprops__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(bdfprops__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdfprops__bindgen_ty_1>())).str_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bdfprops__bindgen_ty_1),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdfprops__bindgen_ty_1>())).atom as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bdfprops__bindgen_ty_1),
            "::",
            stringify!(atom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdfprops__bindgen_ty_1>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bdfprops__bindgen_ty_1),
            "::",
            stringify!(val)
        )
    );
}
#[test]
fn bindgen_test_layout_bdfprops() {
    assert_eq!(
        ::std::mem::size_of::<bdfprops>(),
        24usize,
        concat!("Size of: ", stringify!(bdfprops))
    );
    assert_eq!(
        ::std::mem::align_of::<bdfprops>(),
        8usize,
        concat!("Alignment of ", stringify!(bdfprops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdfprops>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bdfprops),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdfprops>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bdfprops),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdfprops>())).u as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bdfprops),
            "::",
            stringify!(u)
        )
    );
}
pub type BDFProperties = bdfprops;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bdffont {
    pub sf: *mut splinefont,
    pub glyphcnt: ::std::os::raw::c_int,
    pub glyphmax: ::std::os::raw::c_int,
    pub glyphs: *mut *mut BDFChar,
    pub pixelsize: int16,
    pub ascent: int16,
    pub descent: int16,
    pub layer: int16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub next: *mut bdffont,
    pub clut: *mut clut,
    pub foundry: *mut ::std::os::raw::c_char,
    pub res: ::std::os::raw::c_int,
    pub freetype_context: *mut ::std::os::raw::c_void,
    pub truesize: uint16,
    pub prop_cnt: int16,
    pub prop_max: int16,
    pub props: *mut BDFProperties,
    pub ptsize: uint16,
    pub dpi: uint16,
}
#[test]
fn bindgen_test_layout_bdffont() {
    assert_eq!(
        ::std::mem::size_of::<bdffont>(),
        104usize,
        concat!("Size of: ", stringify!(bdffont))
    );
    assert_eq!(
        ::std::mem::align_of::<bdffont>(),
        8usize,
        concat!("Alignment of ", stringify!(bdffont))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdffont>())).sf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bdffont),
            "::",
            stringify!(sf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdffont>())).glyphcnt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bdffont),
            "::",
            stringify!(glyphcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdffont>())).glyphmax as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bdffont),
            "::",
            stringify!(glyphmax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdffont>())).glyphs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bdffont),
            "::",
            stringify!(glyphs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdffont>())).pixelsize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bdffont),
            "::",
            stringify!(pixelsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdffont>())).ascent as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(bdffont),
            "::",
            stringify!(ascent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdffont>())).descent as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(bdffont),
            "::",
            stringify!(descent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdffont>())).layer as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(bdffont),
            "::",
            stringify!(layer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdffont>())).next as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bdffont),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdffont>())).clut as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bdffont),
            "::",
            stringify!(clut)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdffont>())).foundry as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(bdffont),
            "::",
            stringify!(foundry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdffont>())).res as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(bdffont),
            "::",
            stringify!(res)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdffont>())).freetype_context as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(bdffont),
            "::",
            stringify!(freetype_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdffont>())).truesize as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(bdffont),
            "::",
            stringify!(truesize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdffont>())).prop_cnt as *const _ as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(bdffont),
            "::",
            stringify!(prop_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdffont>())).prop_max as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(bdffont),
            "::",
            stringify!(prop_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdffont>())).props as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(bdffont),
            "::",
            stringify!(props)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdffont>())).ptsize as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(bdffont),
            "::",
            stringify!(ptsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdffont>())).dpi as *const _ as usize },
        98usize,
        concat!(
            "Offset of field: ",
            stringify!(bdffont),
            "::",
            stringify!(dpi)
        )
    );
}
impl bdffont {
    #[inline]
    pub fn piecemeal(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_piecemeal(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bbsized(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bbsized(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ticked(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ticked(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unhinted_freetype(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_unhinted_freetype(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn recontext_freetype(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_recontext_freetype(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        piecemeal: ::std::os::raw::c_uint,
        bbsized: ::std::os::raw::c_uint,
        ticked: ::std::os::raw::c_uint,
        unhinted_freetype: ::std::os::raw::c_uint,
        recontext_freetype: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let piecemeal: u32 = unsafe { ::std::mem::transmute(piecemeal) };
            piecemeal as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bbsized: u32 = unsafe { ::std::mem::transmute(bbsized) };
            bbsized as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ticked: u32 = unsafe { ::std::mem::transmute(ticked) };
            ticked as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let unhinted_freetype: u32 = unsafe { ::std::mem::transmute(unhinted_freetype) };
            unhinted_freetype as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let recontext_freetype: u32 = unsafe { ::std::mem::transmute(recontext_freetype) };
            recontext_freetype as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type BDFFont = bdffont;
pub type HintMask = [uint8; 12usize];
pub const pointtype_pt_curve: pointtype = 0;
pub const pointtype_pt_corner: pointtype = 1;
pub const pointtype_pt_tangent: pointtype = 2;
pub const pointtype_pt_hvcurve: pointtype = 3;
pub type pointtype = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct splinepoint {
    pub me: BasePoint,
    pub nextcp: BasePoint,
    pub prevcp: BasePoint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub ptindex: uint16,
    pub ttfindex: uint16,
    pub nextcpindex: uint16,
    pub next: *mut spline,
    pub prev: *mut spline,
    pub hintmask: *mut HintMask,
    pub name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_splinepoint() {
    assert_eq!(
        ::std::mem::size_of::<splinepoint>(),
        96usize,
        concat!("Size of: ", stringify!(splinepoint))
    );
    assert_eq!(
        ::std::mem::align_of::<splinepoint>(),
        8usize,
        concat!("Alignment of ", stringify!(splinepoint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinepoint>())).me as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(splinepoint),
            "::",
            stringify!(me)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinepoint>())).nextcp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(splinepoint),
            "::",
            stringify!(nextcp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinepoint>())).prevcp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(splinepoint),
            "::",
            stringify!(prevcp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinepoint>())).ptindex as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(splinepoint),
            "::",
            stringify!(ptindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinepoint>())).ttfindex as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(splinepoint),
            "::",
            stringify!(ttfindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinepoint>())).nextcpindex as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(splinepoint),
            "::",
            stringify!(nextcpindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinepoint>())).next as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(splinepoint),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinepoint>())).prev as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(splinepoint),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinepoint>())).hintmask as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(splinepoint),
            "::",
            stringify!(hintmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinepoint>())).name as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(splinepoint),
            "::",
            stringify!(name)
        )
    );
}
impl splinepoint {
    #[inline]
    pub fn nonextcp(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nonextcp(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn noprevcp(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_noprevcp(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nextcpdef(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nextcpdef(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn prevcpdef(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_prevcpdef(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn selected(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_selected(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nextcpselected(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_nextcpselected(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn prevcpselected(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_prevcpselected(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn pointtype(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_pointtype(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn isintersection(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isintersection(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flexy(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flexy(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flexx(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flexx(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn roundx(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_roundx(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn roundy(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_roundy(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dontinterpolate(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dontinterpolate(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ticked(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ticked(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn watched(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_watched(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        nonextcp: ::std::os::raw::c_uint,
        noprevcp: ::std::os::raw::c_uint,
        nextcpdef: ::std::os::raw::c_uint,
        prevcpdef: ::std::os::raw::c_uint,
        selected: ::std::os::raw::c_uint,
        nextcpselected: ::std::os::raw::c_uint,
        prevcpselected: ::std::os::raw::c_uint,
        pointtype: ::std::os::raw::c_uint,
        isintersection: ::std::os::raw::c_uint,
        flexy: ::std::os::raw::c_uint,
        flexx: ::std::os::raw::c_uint,
        roundx: ::std::os::raw::c_uint,
        roundy: ::std::os::raw::c_uint,
        dontinterpolate: ::std::os::raw::c_uint,
        ticked: ::std::os::raw::c_uint,
        watched: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let nonextcp: u32 = unsafe { ::std::mem::transmute(nonextcp) };
            nonextcp as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let noprevcp: u32 = unsafe { ::std::mem::transmute(noprevcp) };
            noprevcp as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let nextcpdef: u32 = unsafe { ::std::mem::transmute(nextcpdef) };
            nextcpdef as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let prevcpdef: u32 = unsafe { ::std::mem::transmute(prevcpdef) };
            prevcpdef as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let selected: u32 = unsafe { ::std::mem::transmute(selected) };
            selected as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let nextcpselected: u32 = unsafe { ::std::mem::transmute(nextcpselected) };
            nextcpselected as u64
        });
        __bindgen_bitfield_unit.set(7usize, 2u8, {
            let prevcpselected: u32 = unsafe { ::std::mem::transmute(prevcpselected) };
            prevcpselected as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let pointtype: u32 = unsafe { ::std::mem::transmute(pointtype) };
            pointtype as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let isintersection: u32 = unsafe { ::std::mem::transmute(isintersection) };
            isintersection as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let flexy: u32 = unsafe { ::std::mem::transmute(flexy) };
            flexy as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let flexx: u32 = unsafe { ::std::mem::transmute(flexx) };
            flexx as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let roundx: u32 = unsafe { ::std::mem::transmute(roundx) };
            roundx as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let roundy: u32 = unsafe { ::std::mem::transmute(roundy) };
            roundy as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let dontinterpolate: u32 = unsafe { ::std::mem::transmute(dontinterpolate) };
            dontinterpolate as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let ticked: u32 = unsafe { ::std::mem::transmute(ticked) };
            ticked as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let watched: u32 = unsafe { ::std::mem::transmute(watched) };
            watched as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type SplinePoint = splinepoint;
pub const linelist_flags_cvli_onscreen: linelist_flags = 1;
pub const linelist_flags_cvli_clipped: linelist_flags = 2;
pub type linelist_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linelist {
    pub here: IPoint,
    pub next: *mut linelist,
    pub flags: linelist_flags,
    pub asend: IPoint,
    pub asstart: IPoint,
}
#[test]
fn bindgen_test_layout_linelist() {
    assert_eq!(
        ::std::mem::size_of::<linelist>(),
        40usize,
        concat!("Size of: ", stringify!(linelist))
    );
    assert_eq!(
        ::std::mem::align_of::<linelist>(),
        8usize,
        concat!("Alignment of ", stringify!(linelist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<linelist>())).here as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(linelist),
            "::",
            stringify!(here)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<linelist>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(linelist),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<linelist>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(linelist),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<linelist>())).asend as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(linelist),
            "::",
            stringify!(asend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<linelist>())).asstart as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(linelist),
            "::",
            stringify!(asstart)
        )
    );
}
pub type LineList = linelist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linearapprox {
    pub scale: f64,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub lines: *mut linelist,
    pub next: *mut linearapprox,
}
#[test]
fn bindgen_test_layout_linearapprox() {
    assert_eq!(
        ::std::mem::size_of::<linearapprox>(),
        32usize,
        concat!("Size of: ", stringify!(linearapprox))
    );
    assert_eq!(
        ::std::mem::align_of::<linearapprox>(),
        8usize,
        concat!("Alignment of ", stringify!(linearapprox))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<linearapprox>())).scale as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(linearapprox),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<linearapprox>())).lines as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(linearapprox),
            "::",
            stringify!(lines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<linearapprox>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(linearapprox),
            "::",
            stringify!(next)
        )
    );
}
impl linearapprox {
    #[inline]
    pub fn oneline(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_oneline(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn onepoint(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_onepoint(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn any(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_any(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        oneline: ::std::os::raw::c_uint,
        onepoint: ::std::os::raw::c_uint,
        any: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let oneline: u32 = unsafe { ::std::mem::transmute(oneline) };
            oneline as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let onepoint: u32 = unsafe { ::std::mem::transmute(onepoint) };
            onepoint as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let any: u32 = unsafe { ::std::mem::transmute(any) };
            any as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type LinearApprox = linearapprox;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spline1d {
    pub a: f64,
    pub b: f64,
    pub c: f64,
    pub d: f64,
}
#[test]
fn bindgen_test_layout_spline1d() {
    assert_eq!(
        ::std::mem::size_of::<spline1d>(),
        32usize,
        concat!("Size of: ", stringify!(spline1d))
    );
    assert_eq!(
        ::std::mem::align_of::<spline1d>(),
        8usize,
        concat!("Alignment of ", stringify!(spline1d))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spline1d>())).a as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spline1d),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spline1d>())).b as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spline1d),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spline1d>())).c as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spline1d),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spline1d>())).d as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spline1d),
            "::",
            stringify!(d)
        )
    );
}
pub type Spline1D = spline1d;
#[doc = " 2013Note: If you are altering from->me.x and y then you will"]
#[doc = "           probably have to modify splines[] to match your change."]
#[doc = "           eg, moving both ends of a spline up/down by changing their"]
#[doc = "           to/from will also probably need an update to splines[ 0 | 1 ].d to"]
#[doc = "           match."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spline {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub from: *mut SplinePoint,
    pub to: *mut SplinePoint,
    pub splines: [Spline1D; 2usize],
    pub approx: *mut linearapprox,
}
#[test]
fn bindgen_test_layout_spline() {
    assert_eq!(
        ::std::mem::size_of::<spline>(),
        96usize,
        concat!("Size of: ", stringify!(spline))
    );
    assert_eq!(
        ::std::mem::align_of::<spline>(),
        8usize,
        concat!("Alignment of ", stringify!(spline))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spline>())).from as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spline),
            "::",
            stringify!(from)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spline>())).to as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spline),
            "::",
            stringify!(to)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spline>())).splines as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spline),
            "::",
            stringify!(splines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spline>())).approx as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(spline),
            "::",
            stringify!(approx)
        )
    );
}
impl spline {
    #[inline]
    pub fn islinear(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_islinear(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isquadratic(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isquadratic(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isticked(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isticked(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isneeded(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isneeded(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isunneeded(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isunneeded(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclude(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_exclude(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ishorvert(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ishorvert(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn knowncurved(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_knowncurved(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn knownlinear(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_knownlinear(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn order2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_order2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn touched(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_touched(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn leftedge(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_leftedge(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rightedge(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rightedge(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn acceptableextrema(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_acceptableextrema(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        islinear: ::std::os::raw::c_uint,
        isquadratic: ::std::os::raw::c_uint,
        isticked: ::std::os::raw::c_uint,
        isneeded: ::std::os::raw::c_uint,
        isunneeded: ::std::os::raw::c_uint,
        exclude: ::std::os::raw::c_uint,
        ishorvert: ::std::os::raw::c_uint,
        knowncurved: ::std::os::raw::c_uint,
        knownlinear: ::std::os::raw::c_uint,
        order2: ::std::os::raw::c_uint,
        touched: ::std::os::raw::c_uint,
        leftedge: ::std::os::raw::c_uint,
        rightedge: ::std::os::raw::c_uint,
        acceptableextrema: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let islinear: u32 = unsafe { ::std::mem::transmute(islinear) };
            islinear as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isquadratic: u32 = unsafe { ::std::mem::transmute(isquadratic) };
            isquadratic as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let isticked: u32 = unsafe { ::std::mem::transmute(isticked) };
            isticked as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let isneeded: u32 = unsafe { ::std::mem::transmute(isneeded) };
            isneeded as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let isunneeded: u32 = unsafe { ::std::mem::transmute(isunneeded) };
            isunneeded as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let exclude: u32 = unsafe { ::std::mem::transmute(exclude) };
            exclude as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ishorvert: u32 = unsafe { ::std::mem::transmute(ishorvert) };
            ishorvert as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let knowncurved: u32 = unsafe { ::std::mem::transmute(knowncurved) };
            knowncurved as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let knownlinear: u32 = unsafe { ::std::mem::transmute(knownlinear) };
            knownlinear as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let order2: u32 = unsafe { ::std::mem::transmute(order2) };
            order2 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let touched: u32 = unsafe { ::std::mem::transmute(touched) };
            touched as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let leftedge: u32 = unsafe { ::std::mem::transmute(leftedge) };
            leftedge as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let rightedge: u32 = unsafe { ::std::mem::transmute(rightedge) };
            rightedge as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let acceptableextrema: u32 = unsafe { ::std::mem::transmute(acceptableextrema) };
            acceptableextrema as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " 2013Note: If you are altering from->me.x and y then you will"]
#[doc = "           probably have to modify splines[] to match your change."]
#[doc = "           eg, moving both ends of a spline up/down by changing their"]
#[doc = "           to/from will also probably need an update to splines[ 0 | 1 ].d to"]
#[doc = "           match."]
pub type Spline = spline;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct splinepointlist {
    pub first: *mut SplinePoint,
    pub last: *mut SplinePoint,
    pub next: *mut splinepointlist,
    pub spiros: *mut spiro_cp,
    pub spiro_cnt: uint16,
    pub spiro_max: uint16,
    pub ticked: uint8,
    pub beziers_need_optimizer: uint8,
    pub is_clip_path: uint8,
    pub start_offset: ::std::os::raw::c_int,
    pub contour_name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_splinepointlist() {
    assert_eq!(
        ::std::mem::size_of::<splinepointlist>(),
        56usize,
        concat!("Size of: ", stringify!(splinepointlist))
    );
    assert_eq!(
        ::std::mem::align_of::<splinepointlist>(),
        8usize,
        concat!("Alignment of ", stringify!(splinepointlist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinepointlist>())).first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(splinepointlist),
            "::",
            stringify!(first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinepointlist>())).last as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(splinepointlist),
            "::",
            stringify!(last)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinepointlist>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(splinepointlist),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinepointlist>())).spiros as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(splinepointlist),
            "::",
            stringify!(spiros)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinepointlist>())).spiro_cnt as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(splinepointlist),
            "::",
            stringify!(spiro_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinepointlist>())).spiro_max as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(splinepointlist),
            "::",
            stringify!(spiro_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinepointlist>())).ticked as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(splinepointlist),
            "::",
            stringify!(ticked)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<splinepointlist>())).beziers_need_optimizer as *const _ as usize
        },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(splinepointlist),
            "::",
            stringify!(beziers_need_optimizer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinepointlist>())).is_clip_path as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(splinepointlist),
            "::",
            stringify!(is_clip_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinepointlist>())).start_offset as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(splinepointlist),
            "::",
            stringify!(start_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinepointlist>())).contour_name as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(splinepointlist),
            "::",
            stringify!(contour_name)
        )
    );
}
pub type SplinePointList = splinepointlist;
pub type SplineSet = splinepointlist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imagelist {
    pub image: *mut gimage,
    pub xoff: f64,
    pub yoff: f64,
    pub xscale: f64,
    pub yscale: f64,
    pub bb: DBounds,
    pub next: *mut imagelist,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_imagelist() {
    assert_eq!(
        ::std::mem::size_of::<imagelist>(),
        88usize,
        concat!("Size of: ", stringify!(imagelist))
    );
    assert_eq!(
        ::std::mem::align_of::<imagelist>(),
        8usize,
        concat!("Alignment of ", stringify!(imagelist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imagelist>())).image as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imagelist),
            "::",
            stringify!(image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imagelist>())).xoff as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imagelist),
            "::",
            stringify!(xoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imagelist>())).yoff as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(imagelist),
            "::",
            stringify!(yoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imagelist>())).xscale as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(imagelist),
            "::",
            stringify!(xscale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imagelist>())).yscale as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(imagelist),
            "::",
            stringify!(yscale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imagelist>())).bb as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(imagelist),
            "::",
            stringify!(bb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imagelist>())).next as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(imagelist),
            "::",
            stringify!(next)
        )
    );
}
impl imagelist {
    #[inline]
    pub fn selected(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_selected(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(selected: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let selected: u32 = unsafe { ::std::mem::transmute(selected) };
            selected as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ImageList = imagelist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct guidelineset {
    pub name: *mut ::std::os::raw::c_char,
    pub identifier: *mut ::std::os::raw::c_char,
    pub point: BasePoint,
    pub angle: f64,
    pub color: uint32,
    pub flags: ::std::os::raw::c_int,
    pub next: *mut guidelineset,
}
#[test]
fn bindgen_test_layout_guidelineset() {
    assert_eq!(
        ::std::mem::size_of::<guidelineset>(),
        56usize,
        concat!("Size of: ", stringify!(guidelineset))
    );
    assert_eq!(
        ::std::mem::align_of::<guidelineset>(),
        8usize,
        concat!("Alignment of ", stringify!(guidelineset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<guidelineset>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(guidelineset),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<guidelineset>())).identifier as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(guidelineset),
            "::",
            stringify!(identifier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<guidelineset>())).point as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(guidelineset),
            "::",
            stringify!(point)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<guidelineset>())).angle as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(guidelineset),
            "::",
            stringify!(angle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<guidelineset>())).color as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(guidelineset),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<guidelineset>())).flags as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(guidelineset),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<guidelineset>())).next as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(guidelineset),
            "::",
            stringify!(next)
        )
    );
}
pub type GuidelineSet = guidelineset;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct reflayer {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub fill_brush: brush,
    pub stroke_pen: pen,
    pub splines: *mut SplinePointList,
    pub images: *mut ImageList,
}
#[test]
fn bindgen_test_layout_reflayer() {
    assert_eq!(
        ::std::mem::size_of::<reflayer>(),
        120usize,
        concat!("Size of: ", stringify!(reflayer))
    );
    assert_eq!(
        ::std::mem::align_of::<reflayer>(),
        8usize,
        concat!("Alignment of ", stringify!(reflayer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<reflayer>())).fill_brush as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(reflayer),
            "::",
            stringify!(fill_brush)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<reflayer>())).stroke_pen as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(reflayer),
            "::",
            stringify!(stroke_pen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<reflayer>())).splines as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(reflayer),
            "::",
            stringify!(splines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<reflayer>())).images as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(reflayer),
            "::",
            stringify!(images)
        )
    );
}
impl reflayer {
    #[inline]
    pub fn background(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_background(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn order2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_order2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn anyflexes(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_anyflexes(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dofill(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dofill(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dostroke(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dostroke(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fillfirst(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fillfirst(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        background: ::std::os::raw::c_uint,
        order2: ::std::os::raw::c_uint,
        anyflexes: ::std::os::raw::c_uint,
        dofill: ::std::os::raw::c_uint,
        dostroke: ::std::os::raw::c_uint,
        fillfirst: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let background: u32 = unsafe { ::std::mem::transmute(background) };
            background as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let order2: u32 = unsafe { ::std::mem::transmute(order2) };
            order2 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let anyflexes: u32 = unsafe { ::std::mem::transmute(anyflexes) };
            anyflexes as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let dofill: u32 = unsafe { ::std::mem::transmute(dofill) };
            dofill as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let dostroke: u32 = unsafe { ::std::mem::transmute(dostroke) };
            dostroke as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let fillfirst: u32 = unsafe { ::std::mem::transmute(fillfirst) };
            fillfirst as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct refchar {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub adobe_enc: int16,
    pub orig_pos: ::std::os::raw::c_int,
    pub unicode_enc: ::std::os::raw::c_int,
    pub transform: [f64; 6usize],
    pub layers: *mut reflayer,
    pub layer_cnt: ::std::os::raw::c_int,
    pub next: *mut refchar,
    pub bb: DBounds,
    pub sc: *mut splinechar,
    pub top: BasePoint,
    pub match_pt_base: uint16,
    pub match_pt_ref: uint16,
}
#[test]
fn bindgen_test_layout_refchar() {
    assert_eq!(
        ::std::mem::size_of::<refchar>(),
        152usize,
        concat!("Size of: ", stringify!(refchar))
    );
    assert_eq!(
        ::std::mem::align_of::<refchar>(),
        8usize,
        concat!("Alignment of ", stringify!(refchar))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<refchar>())).adobe_enc as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(refchar),
            "::",
            stringify!(adobe_enc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<refchar>())).orig_pos as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(refchar),
            "::",
            stringify!(orig_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<refchar>())).unicode_enc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(refchar),
            "::",
            stringify!(unicode_enc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<refchar>())).transform as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(refchar),
            "::",
            stringify!(transform)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<refchar>())).layers as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(refchar),
            "::",
            stringify!(layers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<refchar>())).layer_cnt as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(refchar),
            "::",
            stringify!(layer_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<refchar>())).next as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(refchar),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<refchar>())).bb as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(refchar),
            "::",
            stringify!(bb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<refchar>())).sc as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(refchar),
            "::",
            stringify!(sc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<refchar>())).top as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(refchar),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<refchar>())).match_pt_base as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(refchar),
            "::",
            stringify!(match_pt_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<refchar>())).match_pt_ref as *const _ as usize },
        146usize,
        concat!(
            "Offset of field: ",
            stringify!(refchar),
            "::",
            stringify!(match_pt_ref)
        )
    );
}
impl refchar {
    #[inline]
    pub fn checked(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_checked(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn selected(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_selected(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn point_match(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_point_match(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn encoded(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_encoded(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn justtranslated(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_justtranslated(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_my_metrics(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_my_metrics(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn round_translation_to_grid(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_round_translation_to_grid(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn point_match_out_of_date(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_point_match_out_of_date(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        checked: ::std::os::raw::c_uint,
        selected: ::std::os::raw::c_uint,
        point_match: ::std::os::raw::c_uint,
        encoded: ::std::os::raw::c_uint,
        justtranslated: ::std::os::raw::c_uint,
        use_my_metrics: ::std::os::raw::c_uint,
        round_translation_to_grid: ::std::os::raw::c_uint,
        point_match_out_of_date: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let checked: u32 = unsafe { ::std::mem::transmute(checked) };
            checked as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let selected: u32 = unsafe { ::std::mem::transmute(selected) };
            selected as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let point_match: u32 = unsafe { ::std::mem::transmute(point_match) };
            point_match as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let encoded: u32 = unsafe { ::std::mem::transmute(encoded) };
            encoded as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let justtranslated: u32 = unsafe { ::std::mem::transmute(justtranslated) };
            justtranslated as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let use_my_metrics: u32 = unsafe { ::std::mem::transmute(use_my_metrics) };
            use_my_metrics as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let round_translation_to_grid: u32 =
                unsafe { ::std::mem::transmute(round_translation_to_grid) };
            round_translation_to_grid as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let point_match_out_of_date: u32 =
                unsafe { ::std::mem::transmute(point_match_out_of_date) };
            point_match_out_of_date as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type RefChar = refchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hintinstance {
    pub begin: f64,
    pub end: f64,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub counternumber: ::std::os::raw::c_short,
    pub next: *mut hintinstance,
}
#[test]
fn bindgen_test_layout_hintinstance() {
    assert_eq!(
        ::std::mem::size_of::<hintinstance>(),
        32usize,
        concat!("Size of: ", stringify!(hintinstance))
    );
    assert_eq!(
        ::std::mem::align_of::<hintinstance>(),
        8usize,
        concat!("Alignment of ", stringify!(hintinstance))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hintinstance>())).begin as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hintinstance),
            "::",
            stringify!(begin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hintinstance>())).end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hintinstance),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hintinstance>())).counternumber as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(hintinstance),
            "::",
            stringify!(counternumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hintinstance>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hintinstance),
            "::",
            stringify!(next)
        )
    );
}
impl hintinstance {
    #[inline]
    pub fn closed(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_closed(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(closed: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let closed: u32 = unsafe { ::std::mem::transmute(closed) };
            closed as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type HintInstance = hintinstance;
pub const hinttypes_ht_unspecified: hinttypes = 0;
pub const hinttypes_ht_h: hinttypes = 1;
pub const hinttypes_ht_v: hinttypes = 2;
pub const hinttypes_ht_d: hinttypes = 3;
pub type hinttypes = ::std::os::raw::c_uint;
pub type _MMArray = [[f64; 16usize]; 2usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub struct steminfo {
    pub next: *mut steminfo,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub hintnumber: int16,
    pub u: steminfo__bindgen_ty_1,
    pub start: f64,
    pub width: f64,
    pub where_: *mut HintInstance,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union steminfo__bindgen_ty_1 {
    pub mask: ::std::os::raw::c_int,
    pub unblended: *mut _MMArray,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_steminfo__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<steminfo__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(steminfo__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<steminfo__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(steminfo__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<steminfo__bindgen_ty_1>())).mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(steminfo__bindgen_ty_1),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<steminfo__bindgen_ty_1>())).unblended as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(steminfo__bindgen_ty_1),
            "::",
            stringify!(unblended)
        )
    );
}
#[test]
fn bindgen_test_layout_steminfo() {
    assert_eq!(
        ::std::mem::size_of::<steminfo>(),
        48usize,
        concat!("Size of: ", stringify!(steminfo))
    );
    assert_eq!(
        ::std::mem::align_of::<steminfo>(),
        8usize,
        concat!("Alignment of ", stringify!(steminfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<steminfo>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(steminfo),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<steminfo>())).hintnumber as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(steminfo),
            "::",
            stringify!(hintnumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<steminfo>())).u as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(steminfo),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<steminfo>())).start as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(steminfo),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<steminfo>())).width as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(steminfo),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<steminfo>())).where_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(steminfo),
            "::",
            stringify!(where_)
        )
    );
}
impl steminfo {
    #[inline]
    pub fn hinttype(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_hinttype(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ghost(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ghost(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn haspointleft(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_haspointleft(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn haspointright(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_haspointright(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasconflicts(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasconflicts(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn used(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_used(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tobeused(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tobeused(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn active(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_active(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enddone(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enddone(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn startdone(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_startdone(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reordered(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reordered(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pendingpt(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pendingpt(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn linearedges(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_linearedges(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hinttype: ::std::os::raw::c_uint,
        ghost: ::std::os::raw::c_uint,
        haspointleft: ::std::os::raw::c_uint,
        haspointright: ::std::os::raw::c_uint,
        hasconflicts: ::std::os::raw::c_uint,
        used: ::std::os::raw::c_uint,
        tobeused: ::std::os::raw::c_uint,
        active: ::std::os::raw::c_uint,
        enddone: ::std::os::raw::c_uint,
        startdone: ::std::os::raw::c_uint,
        reordered: ::std::os::raw::c_uint,
        pendingpt: ::std::os::raw::c_uint,
        linearedges: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let hinttype: u32 = unsafe { ::std::mem::transmute(hinttype) };
            hinttype as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ghost: u32 = unsafe { ::std::mem::transmute(ghost) };
            ghost as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let haspointleft: u32 = unsafe { ::std::mem::transmute(haspointleft) };
            haspointleft as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let haspointright: u32 = unsafe { ::std::mem::transmute(haspointright) };
            haspointright as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let hasconflicts: u32 = unsafe { ::std::mem::transmute(hasconflicts) };
            hasconflicts as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let used: u32 = unsafe { ::std::mem::transmute(used) };
            used as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let tobeused: u32 = unsafe { ::std::mem::transmute(tobeused) };
            tobeused as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let active: u32 = unsafe { ::std::mem::transmute(active) };
            active as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let enddone: u32 = unsafe { ::std::mem::transmute(enddone) };
            enddone as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let startdone: u32 = unsafe { ::std::mem::transmute(startdone) };
            startdone as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let reordered: u32 = unsafe { ::std::mem::transmute(reordered) };
            reordered as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let pendingpt: u32 = unsafe { ::std::mem::transmute(pendingpt) };
            pendingpt as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let linearedges: u32 = unsafe { ::std::mem::transmute(linearedges) };
            linearedges as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type StemInfo = steminfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsteminfo {
    pub next: *mut dsteminfo,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub left: BasePoint,
    pub right: BasePoint,
    pub unit: BasePoint,
    pub where_: *mut HintInstance,
}
#[test]
fn bindgen_test_layout_dsteminfo() {
    assert_eq!(
        ::std::mem::size_of::<dsteminfo>(),
        72usize,
        concat!("Size of: ", stringify!(dsteminfo))
    );
    assert_eq!(
        ::std::mem::align_of::<dsteminfo>(),
        8usize,
        concat!("Alignment of ", stringify!(dsteminfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsteminfo>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dsteminfo),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsteminfo>())).left as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dsteminfo),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsteminfo>())).right as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dsteminfo),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsteminfo>())).unit as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dsteminfo),
            "::",
            stringify!(unit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsteminfo>())).where_ as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(dsteminfo),
            "::",
            stringify!(where_)
        )
    );
}
impl dsteminfo {
    #[inline]
    pub fn hinttype(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_hinttype(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn used(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_used(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hinttype: ::std::os::raw::c_uint,
        used: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let hinttype: u32 = unsafe { ::std::mem::transmute(hinttype) };
            hinttype as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let used: u32 = unsafe { ::std::mem::transmute(used) };
            used as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type DStemInfo = dsteminfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct minimumdistance {
    pub sp1: *mut SplinePoint,
    pub sp2: *mut SplinePoint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub next: *mut minimumdistance,
}
#[test]
fn bindgen_test_layout_minimumdistance() {
    assert_eq!(
        ::std::mem::size_of::<minimumdistance>(),
        32usize,
        concat!("Size of: ", stringify!(minimumdistance))
    );
    assert_eq!(
        ::std::mem::align_of::<minimumdistance>(),
        8usize,
        concat!("Alignment of ", stringify!(minimumdistance))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<minimumdistance>())).sp1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(minimumdistance),
            "::",
            stringify!(sp1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<minimumdistance>())).sp2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(minimumdistance),
            "::",
            stringify!(sp2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<minimumdistance>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(minimumdistance),
            "::",
            stringify!(next)
        )
    );
}
impl minimumdistance {
    #[inline]
    pub fn x(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn done(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_done(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        x: ::std::os::raw::c_uint,
        done: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let x: u32 = unsafe { ::std::mem::transmute(x) };
            x as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let done: u32 = unsafe { ::std::mem::transmute(done) };
            done as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type MinimumDistance = minimumdistance;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct layer {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub fill_brush: brush,
    pub stroke_pen: pen,
    pub splines: *mut SplinePointList,
    pub images: *mut ImageList,
    pub refs: *mut RefChar,
    pub guidelines: *mut GuidelineSet,
    pub undoes: *mut Undoes,
    pub redoes: *mut Undoes,
    pub validation_state: uint32,
    pub old_vs: uint32,
    pub python_persistent: *mut ::std::os::raw::c_void,
    pub python_persistent_has_lists: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_layer() {
    assert_eq!(
        ::std::mem::size_of::<layer>(),
        176usize,
        concat!("Size of: ", stringify!(layer))
    );
    assert_eq!(
        ::std::mem::align_of::<layer>(),
        8usize,
        concat!("Alignment of ", stringify!(layer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layer>())).fill_brush as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(layer),
            "::",
            stringify!(fill_brush)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layer>())).stroke_pen as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(layer),
            "::",
            stringify!(stroke_pen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layer>())).splines as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(layer),
            "::",
            stringify!(splines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layer>())).images as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(layer),
            "::",
            stringify!(images)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layer>())).refs as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(layer),
            "::",
            stringify!(refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layer>())).guidelines as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(layer),
            "::",
            stringify!(guidelines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layer>())).undoes as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(layer),
            "::",
            stringify!(undoes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layer>())).redoes as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(layer),
            "::",
            stringify!(redoes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layer>())).validation_state as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(layer),
            "::",
            stringify!(validation_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layer>())).old_vs as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(layer),
            "::",
            stringify!(old_vs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layer>())).python_persistent as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(layer),
            "::",
            stringify!(python_persistent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<layer>())).python_persistent_has_lists as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(layer),
            "::",
            stringify!(python_persistent_has_lists)
        )
    );
}
impl layer {
    #[inline]
    pub fn background(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_background(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn order2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_order2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn anyflexes(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_anyflexes(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dofill(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dofill(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dostroke(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dostroke(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fillfirst(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fillfirst(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        background: ::std::os::raw::c_uint,
        order2: ::std::os::raw::c_uint,
        anyflexes: ::std::os::raw::c_uint,
        dofill: ::std::os::raw::c_uint,
        dostroke: ::std::os::raw::c_uint,
        fillfirst: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let background: u32 = unsafe { ::std::mem::transmute(background) };
            background as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let order2: u32 = unsafe { ::std::mem::transmute(order2) };
            order2 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let anyflexes: u32 = unsafe { ::std::mem::transmute(anyflexes) };
            anyflexes as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let dofill: u32 = unsafe { ::std::mem::transmute(dofill) };
            dofill as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let dostroke: u32 = unsafe { ::std::mem::transmute(dostroke) };
            dostroke as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let fillfirst: u32 = unsafe { ::std::mem::transmute(fillfirst) };
            fillfirst as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type Layer = layer;
pub const layer_type_ly_all: layer_type = -2;
pub const layer_type_ly_grid: layer_type = -1;
pub const layer_type_ly_back: layer_type = 0;
pub const layer_type_ly_fore: layer_type = 1;
pub const layer_type_ly_none: layer_type = -3;
pub type layer_type = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gv_part {
    pub component: *mut ::std::os::raw::c_char,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub startConnectorLength: uint16,
    pub endConnectorLength: uint16,
    pub fullAdvance: uint16,
}
#[test]
fn bindgen_test_layout_gv_part() {
    assert_eq!(
        ::std::mem::size_of::<gv_part>(),
        16usize,
        concat!("Size of: ", stringify!(gv_part))
    );
    assert_eq!(
        ::std::mem::align_of::<gv_part>(),
        8usize,
        concat!("Alignment of ", stringify!(gv_part))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gv_part>())).component as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gv_part),
            "::",
            stringify!(component)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gv_part>())).startConnectorLength as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(gv_part),
            "::",
            stringify!(startConnectorLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gv_part>())).endConnectorLength as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(gv_part),
            "::",
            stringify!(endConnectorLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gv_part>())).fullAdvance as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(gv_part),
            "::",
            stringify!(fullAdvance)
        )
    );
}
impl gv_part {
    #[inline]
    pub fn is_extender(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_extender(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_extender: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_extender: u32 = unsafe { ::std::mem::transmute(is_extender) };
            is_extender as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct glyphvariants {
    pub variants: *mut ::std::os::raw::c_char,
    pub italic_correction: int16,
    pub italic_adjusts: *mut DeviceTable,
    pub part_cnt: ::std::os::raw::c_int,
    pub parts: *mut gv_part,
}
#[test]
fn bindgen_test_layout_glyphvariants() {
    assert_eq!(
        ::std::mem::size_of::<glyphvariants>(),
        40usize,
        concat!("Size of: ", stringify!(glyphvariants))
    );
    assert_eq!(
        ::std::mem::align_of::<glyphvariants>(),
        8usize,
        concat!("Alignment of ", stringify!(glyphvariants))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyphvariants>())).variants as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(glyphvariants),
            "::",
            stringify!(variants)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyphvariants>())).italic_correction as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(glyphvariants),
            "::",
            stringify!(italic_correction)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyphvariants>())).italic_adjusts as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(glyphvariants),
            "::",
            stringify!(italic_adjusts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyphvariants>())).part_cnt as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(glyphvariants),
            "::",
            stringify!(part_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyphvariants>())).parts as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(glyphvariants),
            "::",
            stringify!(parts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mathkerndata {
    pub height: int16,
    pub kern: int16,
    pub height_adjusts: *mut DeviceTable,
    pub kern_adjusts: *mut DeviceTable,
}
#[test]
fn bindgen_test_layout_mathkerndata() {
    assert_eq!(
        ::std::mem::size_of::<mathkerndata>(),
        24usize,
        concat!("Size of: ", stringify!(mathkerndata))
    );
    assert_eq!(
        ::std::mem::align_of::<mathkerndata>(),
        8usize,
        concat!("Alignment of ", stringify!(mathkerndata))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mathkerndata>())).height as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mathkerndata),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mathkerndata>())).kern as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(mathkerndata),
            "::",
            stringify!(kern)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mathkerndata>())).height_adjusts as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mathkerndata),
            "::",
            stringify!(height_adjusts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mathkerndata>())).kern_adjusts as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mathkerndata),
            "::",
            stringify!(kern_adjusts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mathkernvertex {
    pub cnt: ::std::os::raw::c_int,
    pub mkd: *mut mathkerndata,
}
#[test]
fn bindgen_test_layout_mathkernvertex() {
    assert_eq!(
        ::std::mem::size_of::<mathkernvertex>(),
        16usize,
        concat!("Size of: ", stringify!(mathkernvertex))
    );
    assert_eq!(
        ::std::mem::align_of::<mathkernvertex>(),
        8usize,
        concat!("Alignment of ", stringify!(mathkernvertex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mathkernvertex>())).cnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mathkernvertex),
            "::",
            stringify!(cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mathkernvertex>())).mkd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mathkernvertex),
            "::",
            stringify!(mkd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mathkern {
    pub top_right: mathkernvertex,
    pub top_left: mathkernvertex,
    pub bottom_right: mathkernvertex,
    pub bottom_left: mathkernvertex,
}
#[test]
fn bindgen_test_layout_mathkern() {
    assert_eq!(
        ::std::mem::size_of::<mathkern>(),
        64usize,
        concat!("Size of: ", stringify!(mathkern))
    );
    assert_eq!(
        ::std::mem::align_of::<mathkern>(),
        8usize,
        concat!("Alignment of ", stringify!(mathkern))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mathkern>())).top_right as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mathkern),
            "::",
            stringify!(top_right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mathkern>())).top_left as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mathkern),
            "::",
            stringify!(top_left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mathkern>())).bottom_right as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mathkern),
            "::",
            stringify!(bottom_right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mathkern>())).bottom_left as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mathkern),
            "::",
            stringify!(bottom_left)
        )
    );
}
pub const privatedict_state_pds_odd: privatedict_state = 1;
pub const privatedict_state_pds_outoforder: privatedict_state = 2;
pub const privatedict_state_pds_toomany: privatedict_state = 4;
pub const privatedict_state_pds_tooclose: privatedict_state = 8;
pub const privatedict_state_pds_notintegral: privatedict_state = 16;
pub const privatedict_state_pds_toobig: privatedict_state = 32;
pub const privatedict_state_pds_shift: privatedict_state = 8;
pub const privatedict_state_pds_missingblue: privatedict_state = 65536;
pub const privatedict_state_pds_badbluefuzz: privatedict_state = 131072;
pub const privatedict_state_pds_badbluescale: privatedict_state = 262144;
pub const privatedict_state_pds_badstdhw: privatedict_state = 524288;
pub const privatedict_state_pds_badstdvw: privatedict_state = 1048576;
pub const privatedict_state_pds_badstemsnaph: privatedict_state = 2097152;
pub const privatedict_state_pds_badstemsnapv: privatedict_state = 4194304;
pub const privatedict_state_pds_stemsnapnostdh: privatedict_state = 8388608;
pub const privatedict_state_pds_stemsnapnostdv: privatedict_state = 16777216;
pub const privatedict_state_pds_badblueshift: privatedict_state = 33554432;
pub type privatedict_state = ::std::os::raw::c_uint;
pub const validation_state_vs_unknown: validation_state = 0;
pub const validation_state_vs_known: validation_state = 1;
pub const validation_state_vs_opencontour: validation_state = 2;
pub const validation_state_vs_selfintersects: validation_state = 4;
pub const validation_state_vs_wrongdirection: validation_state = 8;
pub const validation_state_vs_flippedreferences: validation_state = 16;
pub const validation_state_vs_missingextrema: validation_state = 32;
pub const validation_state_vs_missingglyphnameingsub: validation_state = 64;
pub const validation_state_vs_toomanypoints: validation_state = 128;
pub const validation_state_vs_toomanyhints: validation_state = 256;
pub const validation_state_vs_badglyphname: validation_state = 512;
pub const validation_state_vs_maxp_toomanypoints: validation_state = 1024;
pub const validation_state_vs_maxp_toomanypaths: validation_state = 2048;
pub const validation_state_vs_maxp_toomanycomppoints: validation_state = 4096;
pub const validation_state_vs_maxp_toomanycomppaths: validation_state = 8192;
pub const validation_state_vs_maxp_instrtoolong: validation_state = 16384;
pub const validation_state_vs_maxp_toomanyrefs: validation_state = 32768;
pub const validation_state_vs_maxp_refstoodeep: validation_state = 65536;
pub const validation_state_vs_pointstoofarapart: validation_state = 262144;
pub const validation_state_vs_nonintegral: validation_state = 524288;
pub const validation_state_vs_missinganchor: validation_state = 1048576;
pub const validation_state_vs_dupname: validation_state = 2097152;
pub const validation_state_vs_dupunicode: validation_state = 4194304;
pub const validation_state_vs_overlappedhints: validation_state = 8388608;
pub const validation_state_vs_last: validation_state = 8388608;
pub const validation_state_vs_maskps: validation_state = 15991806;
pub const validation_state_vs_maskcid: validation_state = 11796990;
pub const validation_state_vs_maskttf: validation_state = 6029438;
pub const validation_state_vs_maskfindproblems: validation_state = 10224062;
pub type validation_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct splinecharlist {
    pub sc: *mut splinechar,
    pub next: *mut splinecharlist,
}
#[test]
fn bindgen_test_layout_splinecharlist() {
    assert_eq!(
        ::std::mem::size_of::<splinecharlist>(),
        16usize,
        concat!("Size of: ", stringify!(splinecharlist))
    );
    assert_eq!(
        ::std::mem::align_of::<splinecharlist>(),
        8usize,
        concat!("Alignment of ", stringify!(splinecharlist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinecharlist>())).sc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(splinecharlist),
            "::",
            stringify!(sc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinecharlist>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(splinecharlist),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct altuni {
    pub next: *mut altuni,
    pub unienc: int32,
    pub vs: int32,
    pub fid: uint32,
}
#[test]
fn bindgen_test_layout_altuni() {
    assert_eq!(
        ::std::mem::size_of::<altuni>(),
        24usize,
        concat!("Size of: ", stringify!(altuni))
    );
    assert_eq!(
        ::std::mem::align_of::<altuni>(),
        8usize,
        concat!("Alignment of ", stringify!(altuni))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<altuni>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(altuni),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<altuni>())).unienc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(altuni),
            "::",
            stringify!(unienc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<altuni>())).vs as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(altuni),
            "::",
            stringify!(vs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<altuni>())).fid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(altuni),
            "::",
            stringify!(fid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct splinechar {
    pub name: *mut ::std::os::raw::c_char,
    pub unicodeenc: ::std::os::raw::c_int,
    pub orig_pos: ::std::os::raw::c_int,
    pub width: int16,
    pub vwidth: int16,
    pub lsidebearing: int16,
    pub ttf_glyph: ::std::os::raw::c_int,
    pub layers: *mut Layer,
    pub layer_cnt: ::std::os::raw::c_int,
    pub hstem: *mut StemInfo,
    pub vstem: *mut StemInfo,
    pub dstem: *mut DStemInfo,
    pub md: *mut MinimumDistance,
    pub views: *mut charviewbase,
    pub charinfo: *mut charinfo,
    pub parent: *mut splinefont,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub dependents: *mut splinecharlist,
    pub kerns: *mut KernPair,
    pub vkerns: *mut KernPair,
    pub possub: *mut PST,
    pub ligofme: *mut LigList,
    pub comment: *mut ::std::os::raw::c_char,
    pub color: uint32,
    pub anchor: *mut AnchorPoint,
    pub ttf_instrs: *mut uint8,
    pub ttf_instrs_len: int16,
    pub countermask_cnt: int16,
    pub countermasks: *mut HintMask,
    pub altuni: *mut altuni,
    pub tex_height: int16,
    pub tex_depth: int16,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub italic_correction: int16,
    pub top_accent_horiz: int16,
    pub italic_adjusts: *mut DeviceTable,
    pub top_accent_adjusts: *mut DeviceTable,
    pub vert_variants: *mut glyphvariants,
    pub horiz_variants: *mut glyphvariants,
    pub mathkern: *mut mathkern,
    pub python_sc_object: *mut ::std::os::raw::c_void,
    pub python_temporary: *mut ::std::os::raw::c_void,
    pub tile_margin: f64,
    pub tile_bounds: DBounds,
    pub glif_name: *mut ::std::os::raw::c_char,
    pub user_decomp: *mut unichar_t,
}
#[test]
fn bindgen_test_layout_splinechar() {
    assert_eq!(
        ::std::mem::size_of::<splinechar>(),
        336usize,
        concat!("Size of: ", stringify!(splinechar))
    );
    assert_eq!(
        ::std::mem::align_of::<splinechar>(),
        8usize,
        concat!("Alignment of ", stringify!(splinechar))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).unicodeenc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(unicodeenc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).orig_pos as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(orig_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).vwidth as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(vwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).lsidebearing as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(lsidebearing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).ttf_glyph as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(ttf_glyph)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).layers as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(layers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).layer_cnt as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(layer_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).hstem as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(hstem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).vstem as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(vstem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).dstem as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(dstem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).md as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(md)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).views as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(views)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).charinfo as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(charinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).parent as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).dependents as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(dependents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).kerns as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(kerns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).vkerns as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(vkerns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).possub as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(possub)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).ligofme as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(ligofme)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).comment as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(comment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).color as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).anchor as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(anchor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).ttf_instrs as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(ttf_instrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).ttf_instrs_len as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(ttf_instrs_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).countermask_cnt as *const _ as usize },
        186usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(countermask_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).countermasks as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(countermasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).altuni as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(altuni)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).tex_height as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(tex_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).tex_depth as *const _ as usize },
        210usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(tex_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).italic_correction as *const _ as usize },
        214usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(italic_correction)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).top_accent_horiz as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(top_accent_horiz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).italic_adjusts as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(italic_adjusts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).top_accent_adjusts as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(top_accent_adjusts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).vert_variants as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(vert_variants)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).horiz_variants as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(horiz_variants)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).mathkern as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(mathkern)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).python_sc_object as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(python_sc_object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).python_temporary as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(python_temporary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).tile_margin as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(tile_margin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).tile_bounds as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(tile_bounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).glif_name as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(glif_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinechar>())).user_decomp as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(splinechar),
            "::",
            stringify!(user_decomp)
        )
    );
}
impl splinechar {
    #[inline]
    pub fn changed(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_changed(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn changedsincelasthinted(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_changedsincelasthinted(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn manualhints(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_manualhints(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ticked(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ticked(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn changed_since_autosave(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_changed_since_autosave(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn widthset(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_widthset(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vconflicts(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vconflicts(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hconflicts(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hconflicts(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn searcherdummy(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_searcherdummy(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn changed_since_search(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_changed_since_search(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wasopen(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wasopen(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn namechanged(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_namechanged(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn blended(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_blended(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ticked2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ticked2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn glyph_class(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_glyph_class(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn numberpointsbackards(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_numberpointsbackards(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn instructions_out_of_date(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_instructions_out_of_date(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn complained_about_ptnums(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_complained_about_ptnums(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vs_open(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vs_open(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unlink_rm_ovrlp_save_undo(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_unlink_rm_ovrlp_save_undo(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inspiro(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inspiro(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lig_caret_cnt_fixed(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lig_caret_cnt_fixed(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn suspendMetricsViewEventPropagation(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_suspendMetricsViewEventPropagation(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        changed: ::std::os::raw::c_uint,
        changedsincelasthinted: ::std::os::raw::c_uint,
        manualhints: ::std::os::raw::c_uint,
        ticked: ::std::os::raw::c_uint,
        changed_since_autosave: ::std::os::raw::c_uint,
        widthset: ::std::os::raw::c_uint,
        vconflicts: ::std::os::raw::c_uint,
        hconflicts: ::std::os::raw::c_uint,
        searcherdummy: ::std::os::raw::c_uint,
        changed_since_search: ::std::os::raw::c_uint,
        wasopen: ::std::os::raw::c_uint,
        namechanged: ::std::os::raw::c_uint,
        blended: ::std::os::raw::c_uint,
        ticked2: ::std::os::raw::c_uint,
        glyph_class: ::std::os::raw::c_uint,
        numberpointsbackards: ::std::os::raw::c_uint,
        instructions_out_of_date: ::std::os::raw::c_uint,
        complained_about_ptnums: ::std::os::raw::c_uint,
        vs_open: ::std::os::raw::c_uint,
        unlink_rm_ovrlp_save_undo: ::std::os::raw::c_uint,
        inspiro: ::std::os::raw::c_uint,
        lig_caret_cnt_fixed: ::std::os::raw::c_uint,
        suspendMetricsViewEventPropagation: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let changed: u32 = unsafe { ::std::mem::transmute(changed) };
            changed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let changedsincelasthinted: u32 =
                unsafe { ::std::mem::transmute(changedsincelasthinted) };
            changedsincelasthinted as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let manualhints: u32 = unsafe { ::std::mem::transmute(manualhints) };
            manualhints as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ticked: u32 = unsafe { ::std::mem::transmute(ticked) };
            ticked as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let changed_since_autosave: u32 =
                unsafe { ::std::mem::transmute(changed_since_autosave) };
            changed_since_autosave as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let widthset: u32 = unsafe { ::std::mem::transmute(widthset) };
            widthset as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let vconflicts: u32 = unsafe { ::std::mem::transmute(vconflicts) };
            vconflicts as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let hconflicts: u32 = unsafe { ::std::mem::transmute(hconflicts) };
            hconflicts as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let searcherdummy: u32 = unsafe { ::std::mem::transmute(searcherdummy) };
            searcherdummy as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let changed_since_search: u32 = unsafe { ::std::mem::transmute(changed_since_search) };
            changed_since_search as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let wasopen: u32 = unsafe { ::std::mem::transmute(wasopen) };
            wasopen as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let namechanged: u32 = unsafe { ::std::mem::transmute(namechanged) };
            namechanged as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let blended: u32 = unsafe { ::std::mem::transmute(blended) };
            blended as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let ticked2: u32 = unsafe { ::std::mem::transmute(ticked2) };
            ticked2 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 3u8, {
            let glyph_class: u32 = unsafe { ::std::mem::transmute(glyph_class) };
            glyph_class as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let numberpointsbackards: u32 = unsafe { ::std::mem::transmute(numberpointsbackards) };
            numberpointsbackards as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let instructions_out_of_date: u32 =
                unsafe { ::std::mem::transmute(instructions_out_of_date) };
            instructions_out_of_date as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let complained_about_ptnums: u32 =
                unsafe { ::std::mem::transmute(complained_about_ptnums) };
            complained_about_ptnums as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let vs_open: u32 = unsafe { ::std::mem::transmute(vs_open) };
            vs_open as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let unlink_rm_ovrlp_save_undo: u32 =
                unsafe { ::std::mem::transmute(unlink_rm_ovrlp_save_undo) };
            unlink_rm_ovrlp_save_undo as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let inspiro: u32 = unsafe { ::std::mem::transmute(inspiro) };
            inspiro as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let lig_caret_cnt_fixed: u32 = unsafe { ::std::mem::transmute(lig_caret_cnt_fixed) };
            lig_caret_cnt_fixed as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let suspendMetricsViewEventPropagation: u32 =
                unsafe { ::std::mem::transmute(suspendMetricsViewEventPropagation) };
            suspendMetricsViewEventPropagation as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn is_extended_shape(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_extended_shape(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        is_extended_shape: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_extended_shape: u32 = unsafe { ::std::mem::transmute(is_extended_shape) };
            is_extended_shape as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type SplineChar = splinechar;
pub const ttfnames_ttf_copyright: ttfnames = 0;
pub const ttfnames_ttf_family: ttfnames = 1;
pub const ttfnames_ttf_subfamily: ttfnames = 2;
pub const ttfnames_ttf_uniqueid: ttfnames = 3;
pub const ttfnames_ttf_fullname: ttfnames = 4;
pub const ttfnames_ttf_version: ttfnames = 5;
pub const ttfnames_ttf_postscriptname: ttfnames = 6;
pub const ttfnames_ttf_trademark: ttfnames = 7;
pub const ttfnames_ttf_manufacturer: ttfnames = 8;
pub const ttfnames_ttf_designer: ttfnames = 9;
pub const ttfnames_ttf_descriptor: ttfnames = 10;
pub const ttfnames_ttf_venderurl: ttfnames = 11;
pub const ttfnames_ttf_designerurl: ttfnames = 12;
pub const ttfnames_ttf_license: ttfnames = 13;
pub const ttfnames_ttf_licenseurl: ttfnames = 14;
pub const ttfnames_ttf_idontknow: ttfnames = 15;
pub const ttfnames_ttf_preffamilyname: ttfnames = 16;
pub const ttfnames_ttf_prefmodifiers: ttfnames = 17;
pub const ttfnames_ttf_compatfull: ttfnames = 18;
pub const ttfnames_ttf_sampletext: ttfnames = 19;
pub const ttfnames_ttf_cidfindfontname: ttfnames = 20;
pub const ttfnames_ttf_wwsfamily: ttfnames = 21;
pub const ttfnames_ttf_wwssubfamily: ttfnames = 22;
pub const ttfnames_ttf_namemax: ttfnames = 23;
pub type ttfnames = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ttflangname {
    pub lang: ::std::os::raw::c_int,
    pub names: [*mut ::std::os::raw::c_char; 23usize],
    pub frommac: [::std::os::raw::c_int; 1usize],
    pub next: *mut ttflangname,
}
#[test]
fn bindgen_test_layout_ttflangname() {
    assert_eq!(
        ::std::mem::size_of::<ttflangname>(),
        208usize,
        concat!("Size of: ", stringify!(ttflangname))
    );
    assert_eq!(
        ::std::mem::align_of::<ttflangname>(),
        8usize,
        concat!("Alignment of ", stringify!(ttflangname))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ttflangname>())).lang as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ttflangname),
            "::",
            stringify!(lang)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ttflangname>())).names as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ttflangname),
            "::",
            stringify!(names)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ttflangname>())).frommac as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ttflangname),
            "::",
            stringify!(frommac)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ttflangname>())).next as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ttflangname),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MATH {
    pub ScriptPercentScaleDown: int16,
    pub ScriptScriptPercentScaleDown: int16,
    pub DelimitedSubFormulaMinHeight: uint16,
    pub DisplayOperatorMinHeight: uint16,
    pub MathLeading: int16,
    pub MathLeading_adjust: *mut DeviceTable,
    pub AxisHeight: int16,
    pub AxisHeight_adjust: *mut DeviceTable,
    pub AccentBaseHeight: int16,
    pub AccentBaseHeight_adjust: *mut DeviceTable,
    pub FlattenedAccentBaseHeight: int16,
    pub FlattenedAccentBaseHeight_adjust: *mut DeviceTable,
    pub SubscriptShiftDown: int16,
    pub SubscriptShiftDown_adjust: *mut DeviceTable,
    pub SubscriptTopMax: int16,
    pub SubscriptTopMax_adjust: *mut DeviceTable,
    pub SubscriptBaselineDropMin: int16,
    pub SubscriptBaselineDropMin_adjust: *mut DeviceTable,
    pub SuperscriptShiftUp: int16,
    pub SuperscriptShiftUp_adjust: *mut DeviceTable,
    pub SuperscriptShiftUpCramped: int16,
    pub SuperscriptShiftUpCramped_adjust: *mut DeviceTable,
    pub SuperscriptBottomMin: int16,
    pub SuperscriptBottomMin_adjust: *mut DeviceTable,
    pub SuperscriptBaselineDropMax: int16,
    pub SuperscriptBaselineDropMax_adjust: *mut DeviceTable,
    pub SubSuperscriptGapMin: int16,
    pub SubSuperscriptGapMin_adjust: *mut DeviceTable,
    pub SuperscriptBottomMaxWithSubscript: int16,
    pub SuperscriptBottomMaxWithSubscript_adjust: *mut DeviceTable,
    pub SpaceAfterScript: int16,
    pub SpaceAfterScript_adjust: *mut DeviceTable,
    pub UpperLimitGapMin: int16,
    pub UpperLimitGapMin_adjust: *mut DeviceTable,
    pub UpperLimitBaselineRiseMin: int16,
    pub UpperLimitBaselineRiseMin_adjust: *mut DeviceTable,
    pub LowerLimitGapMin: int16,
    pub LowerLimitGapMin_adjust: *mut DeviceTable,
    pub LowerLimitBaselineDropMin: int16,
    pub LowerLimitBaselineDropMin_adjust: *mut DeviceTable,
    pub StackTopShiftUp: int16,
    pub StackTopShiftUp_adjust: *mut DeviceTable,
    pub StackTopDisplayStyleShiftUp: int16,
    pub StackTopDisplayStyleShiftUp_adjust: *mut DeviceTable,
    pub StackBottomShiftDown: int16,
    pub StackBottomShiftDown_adjust: *mut DeviceTable,
    pub StackBottomDisplayStyleShiftDown: int16,
    pub StackBottomDisplayStyleShiftDown_adjust: *mut DeviceTable,
    pub StackGapMin: int16,
    pub StackGapMin_adjust: *mut DeviceTable,
    pub StackDisplayStyleGapMin: int16,
    pub StackDisplayStyleGapMin_adjust: *mut DeviceTable,
    pub StretchStackTopShiftUp: int16,
    pub StretchStackTopShiftUp_adjust: *mut DeviceTable,
    pub StretchStackBottomShiftDown: int16,
    pub StretchStackBottomShiftDown_adjust: *mut DeviceTable,
    pub StretchStackGapAboveMin: int16,
    pub StretchStackGapAboveMin_adjust: *mut DeviceTable,
    pub StretchStackGapBelowMin: int16,
    pub StretchStackGapBelowMin_adjust: *mut DeviceTable,
    pub FractionNumeratorShiftUp: int16,
    pub FractionNumeratorShiftUp_adjust: *mut DeviceTable,
    pub FractionNumeratorDisplayStyleShiftUp: int16,
    pub FractionNumeratorDisplayStyleShiftUp_adjust: *mut DeviceTable,
    pub FractionDenominatorShiftDown: int16,
    pub FractionDenominatorShiftDown_adjust: *mut DeviceTable,
    pub FractionDenominatorDisplayStyleShiftDown: int16,
    pub FractionDenominatorDisplayStyleShiftDown_adjust: *mut DeviceTable,
    pub FractionNumeratorGapMin: int16,
    pub FractionNumeratorGapMin_adjust: *mut DeviceTable,
    pub FractionNumeratorDisplayStyleGapMin: int16,
    pub FractionNumeratorDisplayStyleGapMin_adjust: *mut DeviceTable,
    pub FractionRuleThickness: int16,
    pub FractionRuleThickness_adjust: *mut DeviceTable,
    pub FractionDenominatorGapMin: int16,
    pub FractionDenominatorGapMin_adjust: *mut DeviceTable,
    pub FractionDenominatorDisplayStyleGapMin: int16,
    pub FractionDenominatorDisplayStyleGapMin_adjust: *mut DeviceTable,
    pub SkewedFractionHorizontalGap: int16,
    pub SkewedFractionHorizontalGap_adjust: *mut DeviceTable,
    pub SkewedFractionVerticalGap: int16,
    pub SkewedFractionVerticalGap_adjust: *mut DeviceTable,
    pub OverbarVerticalGap: int16,
    pub OverbarVerticalGap_adjust: *mut DeviceTable,
    pub OverbarRuleThickness: int16,
    pub OverbarRuleThickness_adjust: *mut DeviceTable,
    pub OverbarExtraAscender: int16,
    pub OverbarExtraAscender_adjust: *mut DeviceTable,
    pub UnderbarVerticalGap: int16,
    pub UnderbarVerticalGap_adjust: *mut DeviceTable,
    pub UnderbarRuleThickness: int16,
    pub UnderbarRuleThickness_adjust: *mut DeviceTable,
    pub UnderbarExtraDescender: int16,
    pub UnderbarExtraDescender_adjust: *mut DeviceTable,
    pub RadicalVerticalGap: int16,
    pub RadicalVerticalGap_adjust: *mut DeviceTable,
    pub RadicalDisplayStyleVerticalGap: int16,
    pub RadicalDisplayStyleVerticalGap_adjust: *mut DeviceTable,
    pub RadicalRuleThickness: int16,
    pub RadicalRuleThickness_adjust: *mut DeviceTable,
    pub RadicalExtraAscender: int16,
    pub RadicalExtraAscender_adjust: *mut DeviceTable,
    pub RadicalKernBeforeDegree: int16,
    pub RadicalKernBeforeDegree_adjust: *mut DeviceTable,
    pub RadicalKernAfterDegree: int16,
    pub RadicalKernAfterDegree_adjust: *mut DeviceTable,
    pub RadicalDegreeBottomRaisePercent: uint16,
    pub MinConnectorOverlap: uint16,
}
#[test]
fn bindgen_test_layout_MATH() {
    assert_eq!(
        ::std::mem::size_of::<MATH>(),
        832usize,
        concat!("Size of: ", stringify!(MATH))
    );
    assert_eq!(
        ::std::mem::align_of::<MATH>(),
        8usize,
        concat!("Alignment of ", stringify!(MATH))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).ScriptPercentScaleDown as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(ScriptPercentScaleDown)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).ScriptScriptPercentScaleDown as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(ScriptScriptPercentScaleDown)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).DelimitedSubFormulaMinHeight as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(DelimitedSubFormulaMinHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).DisplayOperatorMinHeight as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(DisplayOperatorMinHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).MathLeading as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(MathLeading)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).MathLeading_adjust as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(MathLeading_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).AxisHeight as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(AxisHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).AxisHeight_adjust as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(AxisHeight_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).AccentBaseHeight as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(AccentBaseHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).AccentBaseHeight_adjust as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(AccentBaseHeight_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).FlattenedAccentBaseHeight as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(FlattenedAccentBaseHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).FlattenedAccentBaseHeight_adjust as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(FlattenedAccentBaseHeight_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).SubscriptShiftDown as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(SubscriptShiftDown)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).SubscriptShiftDown_adjust as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(SubscriptShiftDown_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).SubscriptTopMax as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(SubscriptTopMax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).SubscriptTopMax_adjust as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(SubscriptTopMax_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).SubscriptBaselineDropMin as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(SubscriptBaselineDropMin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).SubscriptBaselineDropMin_adjust as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(SubscriptBaselineDropMin_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).SuperscriptShiftUp as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(SuperscriptShiftUp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).SuperscriptShiftUp_adjust as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(SuperscriptShiftUp_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).SuperscriptShiftUpCramped as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(SuperscriptShiftUpCramped)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).SuperscriptShiftUpCramped_adjust as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(SuperscriptShiftUpCramped_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).SuperscriptBottomMin as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(SuperscriptBottomMin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).SuperscriptBottomMin_adjust as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(SuperscriptBottomMin_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).SuperscriptBaselineDropMax as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(SuperscriptBaselineDropMax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).SuperscriptBaselineDropMax_adjust as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(SuperscriptBaselineDropMax_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).SubSuperscriptGapMin as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(SubSuperscriptGapMin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).SubSuperscriptGapMin_adjust as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(SubSuperscriptGapMin_adjust)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).SuperscriptBottomMaxWithSubscript as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(SuperscriptBottomMaxWithSubscript)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).SuperscriptBottomMaxWithSubscript_adjust as *const _
                as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(SuperscriptBottomMaxWithSubscript_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).SpaceAfterScript as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(SpaceAfterScript)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).SpaceAfterScript_adjust as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(SpaceAfterScript_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).UpperLimitGapMin as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(UpperLimitGapMin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).UpperLimitGapMin_adjust as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(UpperLimitGapMin_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).UpperLimitBaselineRiseMin as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(UpperLimitBaselineRiseMin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).UpperLimitBaselineRiseMin_adjust as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(UpperLimitBaselineRiseMin_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).LowerLimitGapMin as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(LowerLimitGapMin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).LowerLimitGapMin_adjust as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(LowerLimitGapMin_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).LowerLimitBaselineDropMin as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(LowerLimitBaselineDropMin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).LowerLimitBaselineDropMin_adjust as *const _ as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(LowerLimitBaselineDropMin_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).StackTopShiftUp as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(StackTopShiftUp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).StackTopShiftUp_adjust as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(StackTopShiftUp_adjust)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).StackTopDisplayStyleShiftUp as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(StackTopDisplayStyleShiftUp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).StackTopDisplayStyleShiftUp_adjust as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(StackTopDisplayStyleShiftUp_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).StackBottomShiftDown as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(StackBottomShiftDown)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).StackBottomShiftDown_adjust as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(StackBottomShiftDown_adjust)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).StackBottomDisplayStyleShiftDown as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(StackBottomDisplayStyleShiftDown)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).StackBottomDisplayStyleShiftDown_adjust as *const _
                as usize
        },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(StackBottomDisplayStyleShiftDown_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).StackGapMin as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(StackGapMin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).StackGapMin_adjust as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(StackGapMin_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).StackDisplayStyleGapMin as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(StackDisplayStyleGapMin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).StackDisplayStyleGapMin_adjust as *const _ as usize
        },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(StackDisplayStyleGapMin_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).StretchStackTopShiftUp as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(StretchStackTopShiftUp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).StretchStackTopShiftUp_adjust as *const _ as usize
        },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(StretchStackTopShiftUp_adjust)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).StretchStackBottomShiftDown as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(StretchStackBottomShiftDown)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).StretchStackBottomShiftDown_adjust as *const _ as usize
        },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(StretchStackBottomShiftDown_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).StretchStackGapAboveMin as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(StretchStackGapAboveMin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).StretchStackGapAboveMin_adjust as *const _ as usize
        },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(StretchStackGapAboveMin_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).StretchStackGapBelowMin as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(StretchStackGapBelowMin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).StretchStackGapBelowMin_adjust as *const _ as usize
        },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(StretchStackGapBelowMin_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).FractionNumeratorShiftUp as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(FractionNumeratorShiftUp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).FractionNumeratorShiftUp_adjust as *const _ as usize
        },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(FractionNumeratorShiftUp_adjust)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).FractionNumeratorDisplayStyleShiftUp as *const _
                as usize
        },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(FractionNumeratorDisplayStyleShiftUp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).FractionNumeratorDisplayStyleShiftUp_adjust as *const _
                as usize
        },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(FractionNumeratorDisplayStyleShiftUp_adjust)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).FractionDenominatorShiftDown as *const _ as usize
        },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(FractionDenominatorShiftDown)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).FractionDenominatorShiftDown_adjust as *const _
                as usize
        },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(FractionDenominatorShiftDown_adjust)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).FractionDenominatorDisplayStyleShiftDown as *const _
                as usize
        },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(FractionDenominatorDisplayStyleShiftDown)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).FractionDenominatorDisplayStyleShiftDown_adjust
                as *const _ as usize
        },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(FractionDenominatorDisplayStyleShiftDown_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).FractionNumeratorGapMin as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(FractionNumeratorGapMin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).FractionNumeratorGapMin_adjust as *const _ as usize
        },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(FractionNumeratorGapMin_adjust)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).FractionNumeratorDisplayStyleGapMin as *const _
                as usize
        },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(FractionNumeratorDisplayStyleGapMin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).FractionNumeratorDisplayStyleGapMin_adjust as *const _
                as usize
        },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(FractionNumeratorDisplayStyleGapMin_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).FractionRuleThickness as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(FractionRuleThickness)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).FractionRuleThickness_adjust as *const _ as usize
        },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(FractionRuleThickness_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).FractionDenominatorGapMin as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(FractionDenominatorGapMin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).FractionDenominatorGapMin_adjust as *const _ as usize
        },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(FractionDenominatorGapMin_adjust)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).FractionDenominatorDisplayStyleGapMin as *const _
                as usize
        },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(FractionDenominatorDisplayStyleGapMin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).FractionDenominatorDisplayStyleGapMin_adjust
                as *const _ as usize
        },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(FractionDenominatorDisplayStyleGapMin_adjust)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).SkewedFractionHorizontalGap as *const _ as usize
        },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(SkewedFractionHorizontalGap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).SkewedFractionHorizontalGap_adjust as *const _ as usize
        },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(SkewedFractionHorizontalGap_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).SkewedFractionVerticalGap as *const _ as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(SkewedFractionVerticalGap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).SkewedFractionVerticalGap_adjust as *const _ as usize
        },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(SkewedFractionVerticalGap_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).OverbarVerticalGap as *const _ as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(OverbarVerticalGap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).OverbarVerticalGap_adjust as *const _ as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(OverbarVerticalGap_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).OverbarRuleThickness as *const _ as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(OverbarRuleThickness)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).OverbarRuleThickness_adjust as *const _ as usize
        },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(OverbarRuleThickness_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).OverbarExtraAscender as *const _ as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(OverbarExtraAscender)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).OverbarExtraAscender_adjust as *const _ as usize
        },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(OverbarExtraAscender_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).UnderbarVerticalGap as *const _ as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(UnderbarVerticalGap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).UnderbarVerticalGap_adjust as *const _ as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(UnderbarVerticalGap_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).UnderbarRuleThickness as *const _ as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(UnderbarRuleThickness)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).UnderbarRuleThickness_adjust as *const _ as usize
        },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(UnderbarRuleThickness_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).UnderbarExtraDescender as *const _ as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(UnderbarExtraDescender)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).UnderbarExtraDescender_adjust as *const _ as usize
        },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(UnderbarExtraDescender_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).RadicalVerticalGap as *const _ as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(RadicalVerticalGap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).RadicalVerticalGap_adjust as *const _ as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(RadicalVerticalGap_adjust)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).RadicalDisplayStyleVerticalGap as *const _ as usize
        },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(RadicalDisplayStyleVerticalGap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).RadicalDisplayStyleVerticalGap_adjust as *const _
                as usize
        },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(RadicalDisplayStyleVerticalGap_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).RadicalRuleThickness as *const _ as usize },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(RadicalRuleThickness)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).RadicalRuleThickness_adjust as *const _ as usize
        },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(RadicalRuleThickness_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).RadicalExtraAscender as *const _ as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(RadicalExtraAscender)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).RadicalExtraAscender_adjust as *const _ as usize
        },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(RadicalExtraAscender_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).RadicalKernBeforeDegree as *const _ as usize },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(RadicalKernBeforeDegree)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).RadicalKernBeforeDegree_adjust as *const _ as usize
        },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(RadicalKernBeforeDegree_adjust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).RadicalKernAfterDegree as *const _ as usize },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(RadicalKernAfterDegree)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).RadicalKernAfterDegree_adjust as *const _ as usize
        },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(RadicalKernAfterDegree_adjust)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MATH>())).RadicalDegreeBottomRaisePercent as *const _ as usize
        },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(RadicalDegreeBottomRaisePercent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MATH>())).MinConnectorOverlap as *const _ as usize },
        826usize,
        concat!(
            "Offset of field: ",
            stringify!(MATH),
            "::",
            stringify!(MinConnectorOverlap)
        )
    );
}
pub const backedup_state_bs_dontknow: backedup_state = 0;
pub const backedup_state_bs_not: backedup_state = 1;
pub const backedup_state_bs_backedup: backedup_state = 2;
pub type backedup_state = ::std::os::raw::c_uint;
pub const loadvalidation_state_lvs_bad_ps_fontname: loadvalidation_state = 1;
pub const loadvalidation_state_lvs_bad_glyph_table: loadvalidation_state = 2;
pub const loadvalidation_state_lvs_bad_cff_table: loadvalidation_state = 4;
pub const loadvalidation_state_lvs_bad_metrics_table: loadvalidation_state = 8;
pub const loadvalidation_state_lvs_bad_cmap_table: loadvalidation_state = 16;
pub const loadvalidation_state_lvs_bad_bitmaps_table: loadvalidation_state = 32;
pub const loadvalidation_state_lvs_bad_gx_table: loadvalidation_state = 64;
pub const loadvalidation_state_lvs_bad_ot_table: loadvalidation_state = 128;
pub const loadvalidation_state_lvs_bad_os2_version: loadvalidation_state = 256;
pub const loadvalidation_state_lvs_bad_sfnt_header: loadvalidation_state = 512;
pub type loadvalidation_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct layerinfo {
    pub name: *mut ::std::os::raw::c_char,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub ufo_path: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_layerinfo() {
    assert_eq!(
        ::std::mem::size_of::<layerinfo>(),
        24usize,
        concat!("Size of: ", stringify!(layerinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<layerinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(layerinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerinfo>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(layerinfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerinfo>())).ufo_path as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(layerinfo),
            "::",
            stringify!(ufo_path)
        )
    );
}
impl layerinfo {
    #[inline]
    pub fn background(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_background(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn order2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_order2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ticked(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ticked(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        background: ::std::os::raw::c_uint,
        order2: ::std::os::raw::c_uint,
        ticked: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let background: u32 = unsafe { ::std::mem::transmute(background) };
            background as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let order2: u32 = unsafe { ::std::mem::transmute(order2) };
            order2 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ticked: u32 = unsafe { ::std::mem::transmute(ticked) };
            ticked as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type LayerInfo = layerinfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct baselangextent {
    pub lang: uint32,
    pub next: *mut baselangextent,
    pub ascent: int16,
    pub descent: int16,
    pub features: *mut baselangextent,
}
#[test]
fn bindgen_test_layout_baselangextent() {
    assert_eq!(
        ::std::mem::size_of::<baselangextent>(),
        32usize,
        concat!("Size of: ", stringify!(baselangextent))
    );
    assert_eq!(
        ::std::mem::align_of::<baselangextent>(),
        8usize,
        concat!("Alignment of ", stringify!(baselangextent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<baselangextent>())).lang as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(baselangextent),
            "::",
            stringify!(lang)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<baselangextent>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(baselangextent),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<baselangextent>())).ascent as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(baselangextent),
            "::",
            stringify!(ascent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<baselangextent>())).descent as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(baselangextent),
            "::",
            stringify!(descent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<baselangextent>())).features as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(baselangextent),
            "::",
            stringify!(features)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct basescript {
    pub script: uint32,
    pub next: *mut basescript,
    pub def_baseline: ::std::os::raw::c_int,
    pub baseline_pos: *mut int16,
    pub langs: *mut baselangextent,
}
#[test]
fn bindgen_test_layout_basescript() {
    assert_eq!(
        ::std::mem::size_of::<basescript>(),
        40usize,
        concat!("Size of: ", stringify!(basescript))
    );
    assert_eq!(
        ::std::mem::align_of::<basescript>(),
        8usize,
        concat!("Alignment of ", stringify!(basescript))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<basescript>())).script as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(basescript),
            "::",
            stringify!(script)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<basescript>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(basescript),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<basescript>())).def_baseline as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(basescript),
            "::",
            stringify!(def_baseline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<basescript>())).baseline_pos as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(basescript),
            "::",
            stringify!(baseline_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<basescript>())).langs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(basescript),
            "::",
            stringify!(langs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Base {
    pub baseline_cnt: ::std::os::raw::c_int,
    pub baseline_tags: *mut uint32,
    pub scripts: *mut basescript,
}
#[test]
fn bindgen_test_layout_Base() {
    assert_eq!(
        ::std::mem::size_of::<Base>(),
        24usize,
        concat!("Size of: ", stringify!(Base))
    );
    assert_eq!(
        ::std::mem::align_of::<Base>(),
        8usize,
        concat!("Alignment of ", stringify!(Base))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Base>())).baseline_cnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Base),
            "::",
            stringify!(baseline_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Base>())).baseline_tags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Base),
            "::",
            stringify!(baseline_tags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Base>())).scripts as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Base),
            "::",
            stringify!(scripts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pfminfo {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub pfmfamily: ::std::os::raw::c_uchar,
    pub weight: int16,
    pub width: int16,
    pub panose: [::std::os::raw::c_char; 10usize],
    pub stylemap: int16,
    pub fstype: int16,
    pub linegap: int16,
    pub vlinegap: int16,
    pub hhead_ascent: int16,
    pub hhead_descent: int16,
    pub os2_typoascent: int16,
    pub os2_typodescent: int16,
    pub os2_typolinegap: int16,
    pub os2_winascent: int16,
    pub os2_windescent: int16,
    pub os2_subxsize: int16,
    pub os2_subysize: int16,
    pub os2_subxoff: int16,
    pub os2_subyoff: int16,
    pub os2_supxsize: int16,
    pub os2_supysize: int16,
    pub os2_supxoff: int16,
    pub os2_supyoff: int16,
    pub os2_strikeysize: int16,
    pub os2_strikeypos: int16,
    pub os2_capheight: int16,
    pub os2_xheight: int16,
    pub os2_vendor: [::std::os::raw::c_char; 4usize],
    pub os2_family_class: int16,
    pub codepages: [uint32; 2usize],
    pub unicoderanges: [uint32; 4usize],
}
#[test]
fn bindgen_test_layout_pfminfo() {
    assert_eq!(
        ::std::mem::size_of::<pfminfo>(),
        96usize,
        concat!("Size of: ", stringify!(pfminfo))
    );
    assert_eq!(
        ::std::mem::align_of::<pfminfo>(),
        4usize,
        concat!("Alignment of ", stringify!(pfminfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfminfo>())).pfmfamily as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(pfminfo),
            "::",
            stringify!(pfmfamily)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfminfo>())).weight as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pfminfo),
            "::",
            stringify!(weight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfminfo>())).width as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(pfminfo),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfminfo>())).panose as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pfminfo),
            "::",
            stringify!(panose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfminfo>())).stylemap as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(pfminfo),
            "::",
            stringify!(stylemap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfminfo>())).fstype as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pfminfo),
            "::",
            stringify!(fstype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfminfo>())).linegap as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(pfminfo),
            "::",
            stringify!(linegap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfminfo>())).vlinegap as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pfminfo),
            "::",
            stringify!(vlinegap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfminfo>())).hhead_ascent as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(pfminfo),
            "::",
            stringify!(hhead_ascent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfminfo>())).hhead_descent as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(pfminfo),
            "::",
            stringify!(hhead_descent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfminfo>())).os2_typoascent as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(pfminfo),
            "::",
            stringify!(os2_typoascent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfminfo>())).os2_typodescent as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pfminfo),
            "::",
            stringify!(os2_typodescent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfminfo>())).os2_typolinegap as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(pfminfo),
            "::",
            stringify!(os2_typolinegap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfminfo>())).os2_winascent as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(pfminfo),
            "::",
            stringify!(os2_winascent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfminfo>())).os2_windescent as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(pfminfo),
            "::",
            stringify!(os2_windescent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfminfo>())).os2_subxsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pfminfo),
            "::",
            stringify!(os2_subxsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfminfo>())).os2_subysize as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(pfminfo),
            "::",
            stringify!(os2_subysize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfminfo>())).os2_subxoff as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(pfminfo),
            "::",
            stringify!(os2_subxoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfminfo>())).os2_subyoff as *const _ as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(pfminfo),
            "::",
            stringify!(os2_subyoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfminfo>())).os2_supxsize as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pfminfo),
            "::",
            stringify!(os2_supxsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfminfo>())).os2_supysize as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(pfminfo),
            "::",
            stringify!(os2_supysize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfminfo>())).os2_supxoff as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(pfminfo),
            "::",
            stringify!(os2_supxoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfminfo>())).os2_supyoff as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(pfminfo),
            "::",
            stringify!(os2_supyoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfminfo>())).os2_strikeysize as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pfminfo),
            "::",
            stringify!(os2_strikeysize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfminfo>())).os2_strikeypos as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(pfminfo),
            "::",
            stringify!(os2_strikeypos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfminfo>())).os2_capheight as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(pfminfo),
            "::",
            stringify!(os2_capheight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfminfo>())).os2_xheight as *const _ as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(pfminfo),
            "::",
            stringify!(os2_xheight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfminfo>())).os2_vendor as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pfminfo),
            "::",
            stringify!(os2_vendor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfminfo>())).os2_family_class as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(pfminfo),
            "::",
            stringify!(os2_family_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfminfo>())).codepages as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(pfminfo),
            "::",
            stringify!(codepages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfminfo>())).unicoderanges as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(pfminfo),
            "::",
            stringify!(unicoderanges)
        )
    );
}
impl pfminfo {
    #[inline]
    pub fn pfmset(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pfmset(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn winascent_add(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_winascent_add(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn windescent_add(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_windescent_add(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hheadascent_add(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hheadascent_add(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hheaddescent_add(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hheaddescent_add(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn typoascent_add(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_typoascent_add(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn typodescent_add(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_typodescent_add(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn subsuper_set(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_subsuper_set(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn panose_set(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_panose_set(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hheadset(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hheadset(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vheadset(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vheadset(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hascodepages(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hascodepages(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasunicoderanges(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasunicoderanges(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pfmset: ::std::os::raw::c_uint,
        winascent_add: ::std::os::raw::c_uint,
        windescent_add: ::std::os::raw::c_uint,
        hheadascent_add: ::std::os::raw::c_uint,
        hheaddescent_add: ::std::os::raw::c_uint,
        typoascent_add: ::std::os::raw::c_uint,
        typodescent_add: ::std::os::raw::c_uint,
        subsuper_set: ::std::os::raw::c_uint,
        panose_set: ::std::os::raw::c_uint,
        hheadset: ::std::os::raw::c_uint,
        vheadset: ::std::os::raw::c_uint,
        hascodepages: ::std::os::raw::c_uint,
        hasunicoderanges: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let pfmset: u32 = unsafe { ::std::mem::transmute(pfmset) };
            pfmset as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let winascent_add: u32 = unsafe { ::std::mem::transmute(winascent_add) };
            winascent_add as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let windescent_add: u32 = unsafe { ::std::mem::transmute(windescent_add) };
            windescent_add as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let hheadascent_add: u32 = unsafe { ::std::mem::transmute(hheadascent_add) };
            hheadascent_add as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let hheaddescent_add: u32 = unsafe { ::std::mem::transmute(hheaddescent_add) };
            hheaddescent_add as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let typoascent_add: u32 = unsafe { ::std::mem::transmute(typoascent_add) };
            typoascent_add as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let typodescent_add: u32 = unsafe { ::std::mem::transmute(typodescent_add) };
            typodescent_add as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let subsuper_set: u32 = unsafe { ::std::mem::transmute(subsuper_set) };
            subsuper_set as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let panose_set: u32 = unsafe { ::std::mem::transmute(panose_set) };
            panose_set as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let hheadset: u32 = unsafe { ::std::mem::transmute(hheadset) };
            hheadset as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let vheadset: u32 = unsafe { ::std::mem::transmute(vheadset) };
            vheadset as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let hascodepages: u32 = unsafe { ::std::mem::transmute(hascodepages) };
            hascodepages as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let hasunicoderanges: u32 = unsafe { ::std::mem::transmute(hasunicoderanges) };
            hasunicoderanges as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ttf_table {
    pub tag: uint32,
    pub len: uint32,
    pub maxlen: uint32,
    pub data: *mut uint8,
    pub next: *mut ttf_table,
    pub temp: *mut FILE,
}
#[test]
fn bindgen_test_layout_ttf_table() {
    assert_eq!(
        ::std::mem::size_of::<ttf_table>(),
        40usize,
        concat!("Size of: ", stringify!(ttf_table))
    );
    assert_eq!(
        ::std::mem::align_of::<ttf_table>(),
        8usize,
        concat!("Alignment of ", stringify!(ttf_table))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ttf_table>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ttf_table),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ttf_table>())).len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ttf_table),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ttf_table>())).maxlen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ttf_table),
            "::",
            stringify!(maxlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ttf_table>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ttf_table),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ttf_table>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ttf_table),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ttf_table>())).temp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ttf_table),
            "::",
            stringify!(temp)
        )
    );
}
pub const texdata_type_tex_unset: texdata_type = 0;
pub const texdata_type_tex_text: texdata_type = 1;
pub const texdata_type_tex_math: texdata_type = 2;
pub const texdata_type_tex_mathext: texdata_type = 3;
pub type texdata_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct texdata {
    pub type_: texdata_type,
    pub params: [int32; 22usize],
}
#[test]
fn bindgen_test_layout_texdata() {
    assert_eq!(
        ::std::mem::size_of::<texdata>(),
        92usize,
        concat!("Size of: ", stringify!(texdata))
    );
    assert_eq!(
        ::std::mem::align_of::<texdata>(),
        4usize,
        concat!("Alignment of ", stringify!(texdata))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<texdata>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(texdata),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<texdata>())).params as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(texdata),
            "::",
            stringify!(params)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gasp {
    pub ppem: uint16,
    pub flags: uint16,
}
#[test]
fn bindgen_test_layout_gasp() {
    assert_eq!(
        ::std::mem::size_of::<gasp>(),
        4usize,
        concat!("Size of: ", stringify!(gasp))
    );
    assert_eq!(
        ::std::mem::align_of::<gasp>(),
        2usize,
        concat!("Alignment of ", stringify!(gasp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gasp>())).ppem as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gasp),
            "::",
            stringify!(ppem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gasp>())).flags as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(gasp),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ff_glyphclasses {
    pub classname: *mut ::std::os::raw::c_char,
    pub glyphs: *mut ::std::os::raw::c_char,
    pub next: *mut ff_glyphclasses,
}
#[test]
fn bindgen_test_layout_ff_glyphclasses() {
    assert_eq!(
        ::std::mem::size_of::<ff_glyphclasses>(),
        24usize,
        concat!("Size of: ", stringify!(ff_glyphclasses))
    );
    assert_eq!(
        ::std::mem::align_of::<ff_glyphclasses>(),
        8usize,
        concat!("Alignment of ", stringify!(ff_glyphclasses))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ff_glyphclasses>())).classname as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ff_glyphclasses),
            "::",
            stringify!(classname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ff_glyphclasses>())).glyphs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ff_glyphclasses),
            "::",
            stringify!(glyphs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ff_glyphclasses>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ff_glyphclasses),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ff_rawoffsets {
    pub left: *mut ::std::os::raw::c_char,
    pub right: *mut ::std::os::raw::c_char,
    pub offset: ::std::os::raw::c_int,
    pub next: *mut ff_rawoffsets,
}
#[test]
fn bindgen_test_layout_ff_rawoffsets() {
    assert_eq!(
        ::std::mem::size_of::<ff_rawoffsets>(),
        32usize,
        concat!("Size of: ", stringify!(ff_rawoffsets))
    );
    assert_eq!(
        ::std::mem::align_of::<ff_rawoffsets>(),
        8usize,
        concat!("Alignment of ", stringify!(ff_rawoffsets))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ff_rawoffsets>())).left as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ff_rawoffsets),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ff_rawoffsets>())).right as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ff_rawoffsets),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ff_rawoffsets>())).offset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ff_rawoffsets),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ff_rawoffsets>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ff_rawoffsets),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct splinefont {
    pub fontname: *mut ::std::os::raw::c_char,
    pub fullname: *mut ::std::os::raw::c_char,
    pub familyname: *mut ::std::os::raw::c_char,
    pub weight: *mut ::std::os::raw::c_char,
    pub familyname_with_timestamp: *mut ::std::os::raw::c_char,
    pub copyright: *mut ::std::os::raw::c_char,
    pub filename: *mut ::std::os::raw::c_char,
    pub defbasefilename: *mut ::std::os::raw::c_char,
    pub version: *mut ::std::os::raw::c_char,
    pub italicangle: f64,
    pub upos: f64,
    pub uwidth: f64,
    pub ascent: ::std::os::raw::c_int,
    pub descent: ::std::os::raw::c_int,
    pub invalidem: ::std::os::raw::c_int,
    pub uniqueid: ::std::os::raw::c_int,
    pub glyphcnt: ::std::os::raw::c_int,
    pub glyphmax: ::std::os::raw::c_int,
    pub glyphs: *mut *mut SplineChar,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub fv: *mut fontviewbase,
    pub metrics: *mut metricsview,
    pub uni_interp: uni_interp,
    pub for_new_glyphs: *mut NameList,
    pub map: *mut EncMap,
    pub grid: Layer,
    pub bitmaps: *mut BDFFont,
    pub origname: *mut ::std::os::raw::c_char,
    pub autosavename: *mut ::std::os::raw::c_char,
    pub display_size: ::std::os::raw::c_int,
    pub private: *mut psdict,
    pub xuid: *mut ::std::os::raw::c_char,
    pub pfminfo: pfminfo,
    pub names: *mut ttflangname,
    pub cidregistry: *mut ::std::os::raw::c_char,
    pub ordering: *mut ::std::os::raw::c_char,
    pub supplement: ::std::os::raw::c_int,
    pub subfontcnt: ::std::os::raw::c_int,
    pub subfonts: *mut *mut splinefont,
    pub cidmaster: *mut splinefont,
    pub cidversion: f32,
    pub comments: *mut ::std::os::raw::c_char,
    pub fontlog: *mut ::std::os::raw::c_char,
    pub tempuniqueid: ::std::os::raw::c_int,
    pub top_enc: ::std::os::raw::c_int,
    pub desired_row_cnt: uint16,
    pub desired_col_cnt: uint16,
    pub glyphnames: *mut glyphnamehash,
    pub ttf_tables: *mut ttf_table,
    pub ttf_tab_saved: *mut ttf_table,
    pub cvt_names: *mut *mut ::std::os::raw::c_char,
    pub instr_dlgs: *mut instrdata,
    pub cvt_dlg: *mut shortview,
    pub kcld: *mut kernclasslistdlg,
    pub vkcld: *mut kernclasslistdlg,
    pub kcd: *mut kernclassdlg,
    pub texdata: texdata,
    pub gsub_lookups: *mut OTLookup,
    pub gpos_lookups: *mut OTLookup,
    pub anchor: *mut AnchorClass,
    pub kerns: *mut KernClass,
    pub vkerns: *mut KernClass,
    pub possub: *mut FPST,
    pub sm: *mut ASM,
    pub features: *mut MacFeat,
    pub chosenname: *mut ::std::os::raw::c_char,
    pub mm: *mut mmset,
    pub macstyle: int16,
    pub fondname: *mut ::std::os::raw::c_char,
    pub design_size: uint16,
    pub fontstyle_id: uint16,
    pub fontstyle_name: *mut otfname,
    pub design_range_bottom: uint16,
    pub design_range_top: uint16,
    pub feat_names: *mut otffeatname,
    pub strokewidth: f64,
    pub mark_class_cnt: ::std::os::raw::c_int,
    pub mark_classes: *mut *mut ::std::os::raw::c_char,
    pub mark_class_names: *mut *mut ::std::os::raw::c_char,
    pub mark_set_cnt: ::std::os::raw::c_int,
    pub mark_sets: *mut *mut ::std::os::raw::c_char,
    pub mark_set_names: *mut *mut ::std::os::raw::c_char,
    pub groups: *mut ff_glyphclasses,
    pub groupkerns: *mut ff_rawoffsets,
    pub groupvkerns: *mut ff_rawoffsets,
    pub creationtime: ::std::os::raw::c_longlong,
    pub modificationtime: ::std::os::raw::c_longlong,
    pub os2_version: ::std::os::raw::c_short,
    pub compression: ::std::os::raw::c_short,
    pub gasp_version: ::std::os::raw::c_short,
    pub gasp_cnt: ::std::os::raw::c_short,
    pub gasp: *mut gasp,
    pub MATH: *mut MATH,
    pub sfd_version: f32,
    pub fontinfo: *mut gfi_data,
    pub valwin: *mut val_data,
    pub python_temporary: *mut ::std::os::raw::c_void,
    pub python_persistent: *mut ::std::os::raw::c_void,
    pub python_persistent_has_lists: ::std::os::raw::c_int,
    pub loadvalidation_state: loadvalidation_state,
    pub layers: *mut LayerInfo,
    pub layer_cnt: ::std::os::raw::c_int,
    pub display_layer: ::std::os::raw::c_int,
    pub horiz_base: *mut Base,
    pub vert_base: *mut Base,
    pub justify: *mut Justify,
    pub extrema_bound: ::std::os::raw::c_int,
    pub width_separation: ::std::os::raw::c_int,
    pub sfntRevision: ::std::os::raw::c_int,
    pub woffMajor: ::std::os::raw::c_int,
    pub woffMinor: ::std::os::raw::c_int,
    pub woffMetadata: *mut ::std::os::raw::c_char,
    pub ufo_ascent: f64,
    pub ufo_descent: f64,
    pub styleMapFamilyName: *mut ::std::os::raw::c_char,
    pub undoes: *mut sfundoes,
    pub preferred_kerning: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_splinefont() {
    assert_eq!(
        ::std::mem::size_of::<splinefont>(),
        1160usize,
        concat!("Size of: ", stringify!(splinefont))
    );
    assert_eq!(
        ::std::mem::align_of::<splinefont>(),
        8usize,
        concat!("Alignment of ", stringify!(splinefont))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).fontname as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(fontname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).fullname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(fullname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).familyname as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(familyname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).weight as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(weight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<splinefont>())).familyname_with_timestamp as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(familyname_with_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).copyright as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(copyright)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).filename as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).defbasefilename as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(defbasefilename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).version as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).italicangle as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(italicangle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).upos as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(upos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).uwidth as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(uwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).ascent as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(ascent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).descent as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(descent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).invalidem as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(invalidem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).uniqueid as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(uniqueid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).glyphcnt as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(glyphcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).glyphmax as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(glyphmax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).glyphs as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(glyphs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).fv as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(fv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).metrics as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(metrics)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).uni_interp as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(uni_interp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).for_new_glyphs as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(for_new_glyphs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).map as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).grid as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(grid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).bitmaps as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(bitmaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).origname as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(origname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).autosavename as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(autosavename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).display_size as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(display_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).private as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(private)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).xuid as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(xuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).pfminfo as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(pfminfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).names as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(names)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).cidregistry as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(cidregistry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).ordering as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(ordering)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).supplement as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(supplement)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).subfontcnt as *const _ as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(subfontcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).subfonts as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(subfonts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).cidmaster as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(cidmaster)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).cidversion as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(cidversion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).comments as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(comments)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).fontlog as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(fontlog)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).tempuniqueid as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(tempuniqueid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).top_enc as *const _ as usize },
        572usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(top_enc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).desired_row_cnt as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(desired_row_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).desired_col_cnt as *const _ as usize },
        578usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(desired_col_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).glyphnames as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(glyphnames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).ttf_tables as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(ttf_tables)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).ttf_tab_saved as *const _ as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(ttf_tab_saved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).cvt_names as *const _ as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(cvt_names)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).instr_dlgs as *const _ as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(instr_dlgs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).cvt_dlg as *const _ as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(cvt_dlg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).kcld as *const _ as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(kcld)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).vkcld as *const _ as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(vkcld)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).kcd as *const _ as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(kcd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).texdata as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(texdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).gsub_lookups as *const _ as usize },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(gsub_lookups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).gpos_lookups as *const _ as usize },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(gpos_lookups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).anchor as *const _ as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(anchor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).kerns as *const _ as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(kerns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).vkerns as *const _ as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(vkerns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).possub as *const _ as usize },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(possub)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).sm as *const _ as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(sm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).features as *const _ as usize },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(features)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).chosenname as *const _ as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(chosenname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).mm as *const _ as usize },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(mm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).macstyle as *const _ as usize },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(macstyle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).fondname as *const _ as usize },
        840usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(fondname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).design_size as *const _ as usize },
        848usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(design_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).fontstyle_id as *const _ as usize },
        850usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(fontstyle_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).fontstyle_name as *const _ as usize },
        856usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(fontstyle_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).design_range_bottom as *const _ as usize },
        864usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(design_range_bottom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).design_range_top as *const _ as usize },
        866usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(design_range_top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).feat_names as *const _ as usize },
        872usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(feat_names)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).strokewidth as *const _ as usize },
        880usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(strokewidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).mark_class_cnt as *const _ as usize },
        888usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(mark_class_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).mark_classes as *const _ as usize },
        896usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(mark_classes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).mark_class_names as *const _ as usize },
        904usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(mark_class_names)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).mark_set_cnt as *const _ as usize },
        912usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(mark_set_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).mark_sets as *const _ as usize },
        920usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(mark_sets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).mark_set_names as *const _ as usize },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(mark_set_names)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).groups as *const _ as usize },
        936usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(groups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).groupkerns as *const _ as usize },
        944usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(groupkerns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).groupvkerns as *const _ as usize },
        952usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(groupvkerns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).creationtime as *const _ as usize },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(creationtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).modificationtime as *const _ as usize },
        968usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(modificationtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).os2_version as *const _ as usize },
        976usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(os2_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).compression as *const _ as usize },
        978usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(compression)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).gasp_version as *const _ as usize },
        980usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(gasp_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).gasp_cnt as *const _ as usize },
        982usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(gasp_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).gasp as *const _ as usize },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(gasp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).MATH as *const _ as usize },
        992usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(MATH)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).sfd_version as *const _ as usize },
        1000usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(sfd_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).fontinfo as *const _ as usize },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(fontinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).valwin as *const _ as usize },
        1016usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(valwin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).python_temporary as *const _ as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(python_temporary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).python_persistent as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(python_persistent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<splinefont>())).python_persistent_has_lists as *const _ as usize
        },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(python_persistent_has_lists)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).loadvalidation_state as *const _ as usize },
        1044usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(loadvalidation_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).layers as *const _ as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(layers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).layer_cnt as *const _ as usize },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(layer_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).display_layer as *const _ as usize },
        1060usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(display_layer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).horiz_base as *const _ as usize },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(horiz_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).vert_base as *const _ as usize },
        1072usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(vert_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).justify as *const _ as usize },
        1080usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(justify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).extrema_bound as *const _ as usize },
        1088usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(extrema_bound)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).width_separation as *const _ as usize },
        1092usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(width_separation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).sfntRevision as *const _ as usize },
        1096usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(sfntRevision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).woffMajor as *const _ as usize },
        1100usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(woffMajor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).woffMinor as *const _ as usize },
        1104usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(woffMinor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).woffMetadata as *const _ as usize },
        1112usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(woffMetadata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).ufo_ascent as *const _ as usize },
        1120usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(ufo_ascent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).ufo_descent as *const _ as usize },
        1128usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(ufo_descent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).styleMapFamilyName as *const _ as usize },
        1136usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(styleMapFamilyName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).undoes as *const _ as usize },
        1144usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(undoes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<splinefont>())).preferred_kerning as *const _ as usize },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(splinefont),
            "::",
            stringify!(preferred_kerning)
        )
    );
}
impl splinefont {
    #[inline]
    pub fn changed(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_changed(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn changed_since_autosave(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_changed_since_autosave(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn changed_since_xuidchanged(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_changed_since_xuidchanged(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn display_antialias(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_display_antialias(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn display_bbsized(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_display_bbsized(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dotlesswarn(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dotlesswarn(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn onlybitmaps(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_onlybitmaps(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn serifcheck(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_serifcheck(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn issans(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_issans(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isserif(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isserif(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasvmetrics(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasvmetrics(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn loading_cid_map(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_loading_cid_map(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dupnamewarn(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dupnamewarn(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn encodingchanged(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_encodingchanged(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn multilayer(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_multilayer(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn strokedfont(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_strokedfont(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_new(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn compacted(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_compacted(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn backedup(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_backedup(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn use_typo_metrics(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_typo_metrics(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn weight_width_slope_only(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_weight_width_slope_only(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn save_to_dir(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_save_to_dir(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn head_optimized_for_cleartype(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_head_optimized_for_cleartype(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ticked(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ticked(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn internal_temp(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_internal_temp(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn complained_about_spiros(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_complained_about_spiros(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_xuid(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_xuid(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_uniqueid(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_uniqueid(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        changed: ::std::os::raw::c_uint,
        changed_since_autosave: ::std::os::raw::c_uint,
        changed_since_xuidchanged: ::std::os::raw::c_uint,
        display_antialias: ::std::os::raw::c_uint,
        display_bbsized: ::std::os::raw::c_uint,
        dotlesswarn: ::std::os::raw::c_uint,
        onlybitmaps: ::std::os::raw::c_uint,
        serifcheck: ::std::os::raw::c_uint,
        issans: ::std::os::raw::c_uint,
        isserif: ::std::os::raw::c_uint,
        hasvmetrics: ::std::os::raw::c_uint,
        loading_cid_map: ::std::os::raw::c_uint,
        dupnamewarn: ::std::os::raw::c_uint,
        encodingchanged: ::std::os::raw::c_uint,
        multilayer: ::std::os::raw::c_uint,
        strokedfont: ::std::os::raw::c_uint,
        new: ::std::os::raw::c_uint,
        compacted: ::std::os::raw::c_uint,
        backedup: ::std::os::raw::c_uint,
        use_typo_metrics: ::std::os::raw::c_uint,
        weight_width_slope_only: ::std::os::raw::c_uint,
        save_to_dir: ::std::os::raw::c_uint,
        head_optimized_for_cleartype: ::std::os::raw::c_uint,
        ticked: ::std::os::raw::c_uint,
        internal_temp: ::std::os::raw::c_uint,
        complained_about_spiros: ::std::os::raw::c_uint,
        use_xuid: ::std::os::raw::c_uint,
        use_uniqueid: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let changed: u32 = unsafe { ::std::mem::transmute(changed) };
            changed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let changed_since_autosave: u32 =
                unsafe { ::std::mem::transmute(changed_since_autosave) };
            changed_since_autosave as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let changed_since_xuidchanged: u32 =
                unsafe { ::std::mem::transmute(changed_since_xuidchanged) };
            changed_since_xuidchanged as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let display_antialias: u32 = unsafe { ::std::mem::transmute(display_antialias) };
            display_antialias as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let display_bbsized: u32 = unsafe { ::std::mem::transmute(display_bbsized) };
            display_bbsized as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dotlesswarn: u32 = unsafe { ::std::mem::transmute(dotlesswarn) };
            dotlesswarn as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let onlybitmaps: u32 = unsafe { ::std::mem::transmute(onlybitmaps) };
            onlybitmaps as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let serifcheck: u32 = unsafe { ::std::mem::transmute(serifcheck) };
            serifcheck as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let issans: u32 = unsafe { ::std::mem::transmute(issans) };
            issans as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let isserif: u32 = unsafe { ::std::mem::transmute(isserif) };
            isserif as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let hasvmetrics: u32 = unsafe { ::std::mem::transmute(hasvmetrics) };
            hasvmetrics as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let loading_cid_map: u32 = unsafe { ::std::mem::transmute(loading_cid_map) };
            loading_cid_map as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let dupnamewarn: u32 = unsafe { ::std::mem::transmute(dupnamewarn) };
            dupnamewarn as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let encodingchanged: u32 = unsafe { ::std::mem::transmute(encodingchanged) };
            encodingchanged as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let multilayer: u32 = unsafe { ::std::mem::transmute(multilayer) };
            multilayer as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let strokedfont: u32 = unsafe { ::std::mem::transmute(strokedfont) };
            strokedfont as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let new: u32 = unsafe { ::std::mem::transmute(new) };
            new as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let compacted: u32 = unsafe { ::std::mem::transmute(compacted) };
            compacted as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let backedup: u32 = unsafe { ::std::mem::transmute(backedup) };
            backedup as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let use_typo_metrics: u32 = unsafe { ::std::mem::transmute(use_typo_metrics) };
            use_typo_metrics as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let weight_width_slope_only: u32 =
                unsafe { ::std::mem::transmute(weight_width_slope_only) };
            weight_width_slope_only as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let save_to_dir: u32 = unsafe { ::std::mem::transmute(save_to_dir) };
            save_to_dir as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let head_optimized_for_cleartype: u32 =
                unsafe { ::std::mem::transmute(head_optimized_for_cleartype) };
            head_optimized_for_cleartype as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let ticked: u32 = unsafe { ::std::mem::transmute(ticked) };
            ticked as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let internal_temp: u32 = unsafe { ::std::mem::transmute(internal_temp) };
            internal_temp as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let complained_about_spiros: u32 =
                unsafe { ::std::mem::transmute(complained_about_spiros) };
            complained_about_spiros as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let use_xuid: u32 = unsafe { ::std::mem::transmute(use_xuid) };
            use_xuid as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let use_uniqueid: u32 = unsafe { ::std::mem::transmute(use_uniqueid) };
            use_uniqueid as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type SplineFont = splinefont;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct axismap {
    pub points: ::std::os::raw::c_int,
    pub blends: *mut f64,
    pub designs: *mut f64,
    pub min: f64,
    pub def: f64,
    pub max: f64,
    pub axisnames: *mut macname,
}
#[test]
fn bindgen_test_layout_axismap() {
    assert_eq!(
        ::std::mem::size_of::<axismap>(),
        56usize,
        concat!("Size of: ", stringify!(axismap))
    );
    assert_eq!(
        ::std::mem::align_of::<axismap>(),
        8usize,
        concat!("Alignment of ", stringify!(axismap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<axismap>())).points as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(axismap),
            "::",
            stringify!(points)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<axismap>())).blends as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(axismap),
            "::",
            stringify!(blends)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<axismap>())).designs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(axismap),
            "::",
            stringify!(designs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<axismap>())).min as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(axismap),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<axismap>())).def as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(axismap),
            "::",
            stringify!(def)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<axismap>())).max as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(axismap),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<axismap>())).axisnames as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(axismap),
            "::",
            stringify!(axisnames)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct named_instance {
    pub coords: *mut f64,
    pub names: *mut macname,
}
#[test]
fn bindgen_test_layout_named_instance() {
    assert_eq!(
        ::std::mem::size_of::<named_instance>(),
        16usize,
        concat!("Size of: ", stringify!(named_instance))
    );
    assert_eq!(
        ::std::mem::align_of::<named_instance>(),
        8usize,
        concat!("Alignment of ", stringify!(named_instance))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<named_instance>())).coords as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(named_instance),
            "::",
            stringify!(coords)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<named_instance>())).names as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(named_instance),
            "::",
            stringify!(names)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmset {
    pub axis_count: ::std::os::raw::c_int,
    pub axes: [*mut ::std::os::raw::c_char; 4usize],
    pub instance_count: ::std::os::raw::c_int,
    pub instances: *mut *mut SplineFont,
    pub normal: *mut SplineFont,
    pub positions: *mut f64,
    pub defweights: *mut f64,
    pub axismaps: *mut axismap,
    pub cdv: *mut ::std::os::raw::c_char,
    pub ndv: *mut ::std::os::raw::c_char,
    pub named_instance_count: ::std::os::raw::c_int,
    pub named_instances: *mut named_instance,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_mmset() {
    assert_eq!(
        ::std::mem::size_of::<mmset>(),
        128usize,
        concat!("Size of: ", stringify!(mmset))
    );
    assert_eq!(
        ::std::mem::align_of::<mmset>(),
        8usize,
        concat!("Alignment of ", stringify!(mmset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mmset>())).axis_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mmset),
            "::",
            stringify!(axis_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mmset>())).axes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mmset),
            "::",
            stringify!(axes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mmset>())).instance_count as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mmset),
            "::",
            stringify!(instance_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mmset>())).instances as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mmset),
            "::",
            stringify!(instances)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mmset>())).normal as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mmset),
            "::",
            stringify!(normal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mmset>())).positions as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mmset),
            "::",
            stringify!(positions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mmset>())).defweights as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(mmset),
            "::",
            stringify!(defweights)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mmset>())).axismaps as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(mmset),
            "::",
            stringify!(axismaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mmset>())).cdv as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(mmset),
            "::",
            stringify!(cdv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mmset>())).ndv as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(mmset),
            "::",
            stringify!(ndv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mmset>())).named_instance_count as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(mmset),
            "::",
            stringify!(named_instance_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mmset>())).named_instances as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(mmset),
            "::",
            stringify!(named_instances)
        )
    );
}
impl mmset {
    #[inline]
    pub fn changed(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_changed(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn apple(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_apple(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        changed: ::std::os::raw::c_uint,
        apple: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let changed: u32 = unsafe { ::std::mem::transmute(changed) };
            changed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let apple: u32 = unsafe { ::std::mem::transmute(apple) };
            apple as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type MMSet = mmset;
pub const style_flags_sf_bold: style_flags = 1;
pub const style_flags_sf_italic: style_flags = 2;
pub const style_flags_sf_underline: style_flags = 4;
pub const style_flags_sf_outline: style_flags = 8;
pub const style_flags_sf_shadow: style_flags = 16;
pub const style_flags_sf_condense: style_flags = 32;
pub const style_flags_sf_extend: style_flags = 64;
pub type style_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sflist {
    pub sf: *mut SplineFont,
    pub sizes: *mut int32,
    pub tempttf: *mut FILE,
    pub id: ::std::os::raw::c_int,
    pub ids: *mut ::std::os::raw::c_int,
    pub bdfs: *mut *mut BDFFont,
    pub map: *mut EncMap,
    pub next: *mut sflist,
    pub former_names: *mut *mut ::std::os::raw::c_char,
    pub len: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sflist() {
    assert_eq!(
        ::std::mem::size_of::<sflist>(),
        80usize,
        concat!("Size of: ", stringify!(sflist))
    );
    assert_eq!(
        ::std::mem::align_of::<sflist>(),
        8usize,
        concat!("Alignment of ", stringify!(sflist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sflist>())).sf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sflist),
            "::",
            stringify!(sf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sflist>())).sizes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sflist),
            "::",
            stringify!(sizes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sflist>())).tempttf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sflist),
            "::",
            stringify!(tempttf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sflist>())).id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sflist),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sflist>())).ids as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sflist),
            "::",
            stringify!(ids)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sflist>())).bdfs as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sflist),
            "::",
            stringify!(bdfs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sflist>())).map as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sflist),
            "::",
            stringify!(map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sflist>())).next as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sflist),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sflist>())).former_names as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sflist),
            "::",
            stringify!(former_names)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sflist>())).len as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sflist),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct anchorpos {
    pub sc: *mut SplineChar,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub apm: *mut AnchorPoint,
    pub apb: *mut AnchorPoint,
    pub base_index: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_anchorpos() {
    assert_eq!(
        ::std::mem::size_of::<anchorpos>(),
        40usize,
        concat!("Size of: ", stringify!(anchorpos))
    );
    assert_eq!(
        ::std::mem::align_of::<anchorpos>(),
        8usize,
        concat!("Alignment of ", stringify!(anchorpos))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<anchorpos>())).sc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(anchorpos),
            "::",
            stringify!(sc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<anchorpos>())).x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(anchorpos),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<anchorpos>())).y as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(anchorpos),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<anchorpos>())).apm as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(anchorpos),
            "::",
            stringify!(apm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<anchorpos>())).apb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(anchorpos),
            "::",
            stringify!(apb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<anchorpos>())).base_index as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(anchorpos),
            "::",
            stringify!(base_index)
        )
    );
}
impl anchorpos {
    #[inline]
    pub fn ticked(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ticked(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ticked: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ticked: u32 = unsafe { ::std::mem::transmute(ticked) };
            ticked as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type AnchorPos = anchorpos;
pub const ttf_flags_ttf_flag_shortps: ttf_flags = 1;
pub const ttf_flags_ttf_flag_nohints: ttf_flags = 2;
pub const ttf_flags_ttf_flag_applemode: ttf_flags = 4;
pub const ttf_flags_ttf_flag_pfed_comments: ttf_flags = 8;
pub const ttf_flags_ttf_flag_pfed_colors: ttf_flags = 16;
pub const ttf_flags_ttf_flag_otmode: ttf_flags = 32;
pub const ttf_flags_ttf_flag_glyphmap: ttf_flags = 64;
pub const ttf_flags_ttf_flag_TeXtable: ttf_flags = 128;
pub const ttf_flags_ttf_flag_ofm: ttf_flags = 256;
pub const ttf_flags_ttf_flag_oldkern: ttf_flags = 512;
pub const ttf_flags_ttf_flag_noFFTMtable: ttf_flags = 1024;
pub const ttf_flags_ttf_flag_pfed_lookupnames: ttf_flags = 2048;
pub const ttf_flags_ttf_flag_pfed_guides: ttf_flags = 4096;
pub const ttf_flags_ttf_flag_pfed_layers: ttf_flags = 8192;
pub const ttf_flags_ttf_flag_symbol: ttf_flags = 16384;
pub const ttf_flags_ttf_flag_dummyDSIG: ttf_flags = 32768;
pub const ttf_flags_ttf_native_kern: ttf_flags = 65536;
pub const ttf_flags_ttf_flag_oldkernmappedonly: ttf_flags = 536870912;
pub const ttf_flags_ttf_flag_nomacnames: ttf_flags = 1073741824;
pub type ttf_flags = ::std::os::raw::c_uint;
pub const ttc_flags_ttc_flag_trymerge: ttc_flags = 1;
pub const ttc_flags_ttc_flag_cff: ttc_flags = 2;
pub type ttc_flags = ::std::os::raw::c_uint;
pub const openflags_of_fstypepermitted: openflags = 1;
pub const openflags_of_all_glyphs_in_ttc: openflags = 4;
pub const openflags_of_fontlint: openflags = 8;
pub const openflags_of_hidewindow: openflags = 16;
pub const openflags_of_all_tables: openflags = 32;
pub type openflags = ::std::os::raw::c_uint;
pub const ps_flags_ps_flag_nohintsubs: ps_flags = 65536;
pub const ps_flags_ps_flag_noflex: ps_flags = 131072;
pub const ps_flags_ps_flag_nohints: ps_flags = 262144;
pub const ps_flags_ps_flag_restrict256: ps_flags = 524288;
pub const ps_flags_ps_flag_afm: ps_flags = 1048576;
pub const ps_flags_ps_flag_pfm: ps_flags = 2097152;
pub const ps_flags_ps_flag_tfm: ps_flags = 4194304;
pub const ps_flags_ps_flag_round: ps_flags = 8388608;
pub const ps_flags_ps_flag_nocffsugar: ps_flags = 16777216;
pub const ps_flags_ps_flag_identitycidmap: ps_flags = 33554432;
pub const ps_flags_ps_flag_afmwithmarks: ps_flags = 67108864;
pub const ps_flags_ps_flag_noseac: ps_flags = 134217728;
pub const ps_flags_ps_flag_outputfontlog: ps_flags = 268435456;
pub const ps_flags_ps_flag_mask: ps_flags = 15925248;
pub type ps_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct compressors {
    pub ext: *mut ::std::os::raw::c_char,
    pub decomp: *mut ::std::os::raw::c_char,
    pub recomp: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_compressors() {
    assert_eq!(
        ::std::mem::size_of::<compressors>(),
        24usize,
        concat!("Size of: ", stringify!(compressors))
    );
    assert_eq!(
        ::std::mem::align_of::<compressors>(),
        8usize,
        concat!("Alignment of ", stringify!(compressors))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<compressors>())).ext as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(compressors),
            "::",
            stringify!(ext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<compressors>())).decomp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(compressors),
            "::",
            stringify!(decomp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<compressors>())).recomp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(compressors),
            "::",
            stringify!(recomp)
        )
    );
}
extern "C" {
    pub static mut compressors: [compressors; 0usize];
}
pub const archive_list_style_ars_tar: archive_list_style = 0;
pub const archive_list_style_ars_zip: archive_list_style = 1;
pub type archive_list_style = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct archivers {
    pub ext: *mut ::std::os::raw::c_char,
    pub unarchive: *mut ::std::os::raw::c_char,
    pub archive: *mut ::std::os::raw::c_char,
    pub listargs: *mut ::std::os::raw::c_char,
    pub extractargs: *mut ::std::os::raw::c_char,
    pub appendargs: *mut ::std::os::raw::c_char,
    pub ars: archive_list_style,
}
#[test]
fn bindgen_test_layout_archivers() {
    assert_eq!(
        ::std::mem::size_of::<archivers>(),
        56usize,
        concat!("Size of: ", stringify!(archivers))
    );
    assert_eq!(
        ::std::mem::align_of::<archivers>(),
        8usize,
        concat!("Alignment of ", stringify!(archivers))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<archivers>())).ext as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(archivers),
            "::",
            stringify!(ext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<archivers>())).unarchive as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(archivers),
            "::",
            stringify!(unarchive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<archivers>())).archive as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(archivers),
            "::",
            stringify!(archive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<archivers>())).listargs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(archivers),
            "::",
            stringify!(listargs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<archivers>())).extractargs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(archivers),
            "::",
            stringify!(extractargs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<archivers>())).appendargs as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(archivers),
            "::",
            stringify!(appendargs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<archivers>())).ars as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(archivers),
            "::",
            stringify!(ars)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fontdict {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct findsel {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct charprocs {
    _unused: [u8; 0],
}
extern "C" {
    pub fn strconcat(
        str_: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SFApplyFeatureFile(
        sf: *mut SplineFont,
        file: *mut FILE,
        filename: *mut ::std::os::raw::c_char,
    );
}
pub const fontformat_ff_pfa: fontformat = 0;
pub const fontformat_ff_pfb: fontformat = 1;
pub const fontformat_ff_pfbmacbin: fontformat = 2;
pub const fontformat_ff_multiple: fontformat = 3;
pub const fontformat_ff_mma: fontformat = 4;
pub const fontformat_ff_mmb: fontformat = 5;
pub const fontformat_ff_ptype3: fontformat = 6;
pub const fontformat_ff_ptype0: fontformat = 7;
pub const fontformat_ff_cid: fontformat = 8;
pub const fontformat_ff_cff: fontformat = 9;
pub const fontformat_ff_cffcid: fontformat = 10;
pub const fontformat_ff_type42: fontformat = 11;
pub const fontformat_ff_type42cid: fontformat = 12;
pub const fontformat_ff_ttf: fontformat = 13;
pub const fontformat_ff_ttfsym: fontformat = 14;
pub const fontformat_ff_ttfmacbin: fontformat = 15;
pub const fontformat_ff_ttc: fontformat = 16;
pub const fontformat_ff_ttfdfont: fontformat = 17;
pub const fontformat_ff_otf: fontformat = 18;
pub const fontformat_ff_otfdfont: fontformat = 19;
pub const fontformat_ff_otfcid: fontformat = 20;
pub const fontformat_ff_otfciddfont: fontformat = 21;
pub const fontformat_ff_svg: fontformat = 22;
pub const fontformat_ff_ufo: fontformat = 23;
pub const fontformat_ff_ufo2: fontformat = 24;
pub const fontformat_ff_ufo3: fontformat = 25;
pub const fontformat_ff_woff: fontformat = 26;
pub const fontformat_ff_woff2: fontformat = 27;
pub const fontformat_ff_none: fontformat = 28;
pub type fontformat = ::std::os::raw::c_uint;
extern "C" {
    pub fn SplineFont2ChrsSubrs(
        sf: *mut SplineFont,
        iscjk: ::std::os::raw::c_int,
        subrs: *mut pschars,
        flags: ::std::os::raw::c_int,
        format: fontformat,
        layer: ::std::os::raw::c_int,
    ) -> *mut pschars;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cidbytes {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd2data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ttfinfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alltabs {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct growbuf {
    pub pt: *mut ::std::os::raw::c_uchar,
    pub base: *mut ::std::os::raw::c_uchar,
    pub end: *mut ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_growbuf() {
    assert_eq!(
        ::std::mem::size_of::<growbuf>(),
        24usize,
        concat!("Size of: ", stringify!(growbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<growbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(growbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<growbuf>())).pt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(growbuf),
            "::",
            stringify!(pt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<growbuf>())).base as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(growbuf),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<growbuf>())).end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(growbuf),
            "::",
            stringify!(end)
        )
    );
}
pub type GrowBuf = growbuf;
extern "C" {
    pub fn GrowBuffer(gb: *mut GrowBuf);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct glyphdata {
    _unused: [u8; 0],
}
extern "C" {
    pub fn CID2ChrsSubrs(
        cidmaster: *mut SplineFont,
        cidbytes: *mut cidbytes,
        flags: ::std::os::raw::c_int,
        layer: ::std::os::raw::c_int,
    ) -> *mut pschars;
}
pub const bitmapformat_bf_bdf: bitmapformat = 0;
pub const bitmapformat_bf_ttf: bitmapformat = 1;
pub const bitmapformat_bf_sfnt_dfont: bitmapformat = 2;
pub const bitmapformat_bf_sfnt_ms: bitmapformat = 3;
pub const bitmapformat_bf_otb: bitmapformat = 4;
pub const bitmapformat_bf_nfntmacbin: bitmapformat = 5;
pub const bitmapformat_bf_fon: bitmapformat = 6;
pub const bitmapformat_bf_fnt: bitmapformat = 7;
pub const bitmapformat_bf_palm: bitmapformat = 8;
pub const bitmapformat_bf_ptype3: bitmapformat = 9;
pub const bitmapformat_bf_none: bitmapformat = 10;
pub type bitmapformat = ::std::os::raw::c_uint;
extern "C" {
    pub fn GetAuthor() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn WriteUFOFont(
        fontname: *const ::std::os::raw::c_char,
        sf: *mut SplineFont,
        format: fontformat,
        flags: ::std::os::raw::c_int,
        enc: *const EncMap,
        layer: ::std::os::raw::c_int,
        version: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SLIContainsR2L(sf: *mut SplineFont, sli: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SFFindNearTop(arg1: *mut SplineFont);
}
extern "C" {
    pub fn SFRestoreNearTop(arg1: *mut SplineFont);
}
extern "C" {
    pub fn _GetModifiers(
        fontname: *const ::std::os::raw::c_char,
        familyname: *const ::std::os::raw::c_char,
        weight: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SFGetModifiers(sf: *const SplineFont) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn _uGetModifiers(
        fontname: *const unichar_t,
        familyname: *const unichar_t,
        weight: *const unichar_t,
    ) -> *const unichar_t;
}
extern "C" {
    pub fn ttfdumpbitmap(sf: *mut SplineFont, at: *mut alltabs, sizes: *mut int32);
}
extern "C" {
    pub fn SplineFontSetUnChanged(sf: *mut SplineFont);
}
extern "C" {
    pub fn RealNear(a: f64, b: f64) -> bool;
}
extern "C" {
    pub fn UndoesFree(undo: *mut Undoes);
}
extern "C" {
    pub fn StemInfosFree(h: *mut StemInfo);
}
extern "C" {
    pub fn StemInfoFree(h: *mut StemInfo);
}
extern "C" {
    pub fn SCOrderAP(sc: *mut SplineChar);
}
extern "C" {
    pub fn AnchorClassesNextMerge(ac: *mut AnchorClass) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AnchorClassMerge(sf: *mut SplineFont, into: *mut AnchorClass, from: *mut AnchorClass);
}
extern "C" {
    pub fn SCInsertPST(sc: *mut SplineChar, new_: *mut PST);
}
extern "C" {
    pub fn PSTFree(lig: *mut PST);
}
extern "C" {
    pub fn PSTDefaultFlags(type_: possub_type, sc: *mut SplineChar) -> uint16;
}
extern "C" {
    pub fn StemInfoCopy(h: *mut StemInfo) -> *mut StemInfo;
}
extern "C" {
    pub fn SPChangePointType(sp: *mut SplinePoint, pointtype: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lookup_cvt {
    pub from: *mut OTLookup,
    pub to: *mut OTLookup,
    pub old: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_lookup_cvt() {
    assert_eq!(
        ::std::mem::size_of::<lookup_cvt>(),
        24usize,
        concat!("Size of: ", stringify!(lookup_cvt))
    );
    assert_eq!(
        ::std::mem::align_of::<lookup_cvt>(),
        8usize,
        concat!("Alignment of ", stringify!(lookup_cvt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lookup_cvt>())).from as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lookup_cvt),
            "::",
            stringify!(from)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lookup_cvt>())).to as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lookup_cvt),
            "::",
            stringify!(to)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lookup_cvt>())).old as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lookup_cvt),
            "::",
            stringify!(old)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sub_cvt {
    pub from: *mut lookup_subtable,
    pub to: *mut lookup_subtable,
    pub old: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sub_cvt() {
    assert_eq!(
        ::std::mem::size_of::<sub_cvt>(),
        24usize,
        concat!("Size of: ", stringify!(sub_cvt))
    );
    assert_eq!(
        ::std::mem::align_of::<sub_cvt>(),
        8usize,
        concat!("Alignment of ", stringify!(sub_cvt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sub_cvt>())).from as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sub_cvt),
            "::",
            stringify!(from)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sub_cvt>())).to as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sub_cvt),
            "::",
            stringify!(to)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sub_cvt>())).old as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sub_cvt),
            "::",
            stringify!(old)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ac_cvt {
    pub from: *mut AnchorClass,
    pub to: *mut AnchorClass,
    pub old: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ac_cvt() {
    assert_eq!(
        ::std::mem::size_of::<ac_cvt>(),
        24usize,
        concat!("Size of: ", stringify!(ac_cvt))
    );
    assert_eq!(
        ::std::mem::align_of::<ac_cvt>(),
        8usize,
        concat!("Alignment of ", stringify!(ac_cvt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ac_cvt>())).from as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ac_cvt),
            "::",
            stringify!(from)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ac_cvt>())).to as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ac_cvt),
            "::",
            stringify!(to)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ac_cvt>())).old as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ac_cvt),
            "::",
            stringify!(old)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sfmergecontext {
    pub sf_from: *mut SplineFont,
    pub sf_to: *mut SplineFont,
    pub lcnt: ::std::os::raw::c_int,
    pub lks: *mut lookup_cvt,
    pub scnt: ::std::os::raw::c_int,
    pub subs: *mut sub_cvt,
    pub acnt: ::std::os::raw::c_int,
    pub acs: *mut ac_cvt,
    pub prefix: *mut ::std::os::raw::c_char,
    pub preserveCrossFontKerning: ::std::os::raw::c_int,
    pub lmax: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sfmergecontext() {
    assert_eq!(
        ::std::mem::size_of::<sfmergecontext>(),
        80usize,
        concat!("Size of: ", stringify!(sfmergecontext))
    );
    assert_eq!(
        ::std::mem::align_of::<sfmergecontext>(),
        8usize,
        concat!("Alignment of ", stringify!(sfmergecontext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sfmergecontext>())).sf_from as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sfmergecontext),
            "::",
            stringify!(sf_from)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sfmergecontext>())).sf_to as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sfmergecontext),
            "::",
            stringify!(sf_to)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sfmergecontext>())).lcnt as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sfmergecontext),
            "::",
            stringify!(lcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sfmergecontext>())).lks as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sfmergecontext),
            "::",
            stringify!(lks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sfmergecontext>())).scnt as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sfmergecontext),
            "::",
            stringify!(scnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sfmergecontext>())).subs as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sfmergecontext),
            "::",
            stringify!(subs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sfmergecontext>())).acnt as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sfmergecontext),
            "::",
            stringify!(acnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sfmergecontext>())).acs as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sfmergecontext),
            "::",
            stringify!(acs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sfmergecontext>())).prefix as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sfmergecontext),
            "::",
            stringify!(prefix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sfmergecontext>())).preserveCrossFontKerning as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sfmergecontext),
            "::",
            stringify!(preserveCrossFontKerning)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sfmergecontext>())).lmax as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(sfmergecontext),
            "::",
            stringify!(lmax)
        )
    );
}
extern "C" {
    pub fn AltUniRemove(sc: *mut SplineChar, uni: ::std::os::raw::c_int);
}
extern "C" {
    pub fn AltUniAdd(sc: *mut SplineChar, uni: ::std::os::raw::c_int);
}
extern "C" {
    pub fn AltUniAdd_DontCheckDups(sc: *mut SplineChar, uni: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SplineCharCreate(layer_cnt: ::std::os::raw::c_int) -> *mut SplineChar;
}
extern "C" {
    pub fn SCAddRef(
        sc: *mut SplineChar,
        rsc: *mut SplineChar,
        layer: ::std::os::raw::c_int,
        xoff: f64,
        yoff: f64,
    );
}
extern "C" {
    pub fn SplineCharFree(sc: *mut SplineChar);
}
extern "C" {
    pub fn ScriptLangListFree(sl: *mut scriptlanglist);
}
pub const pconvert_flags_pconvert_flag_none: pconvert_flags = 1;
pub const pconvert_flags_pconvert_flag_all: pconvert_flags = 2;
pub const pconvert_flags_pconvert_flag_smooth: pconvert_flags = 4;
pub const pconvert_flags_pconvert_flag_incompat: pconvert_flags = 8;
pub const pconvert_flags_pconvert_flag_by_geom: pconvert_flags = 256;
pub const pconvert_flags_pconvert_flag_force_type: pconvert_flags = 512;
pub const pconvert_flags_pconvert_flag_downgrade: pconvert_flags = 1024;
pub const pconvert_flags_pconvert_flag_check_compat: pconvert_flags = 2048;
pub const pconvert_flags_pconvert_flag_hvcurve: pconvert_flags = 16384;
pub type pconvert_flags = ::std::os::raw::c_uint;
extern "C" {
    pub fn MMSetFree(mm: *mut MMSet);
}
extern "C" {
    pub fn SFRemoveUndoes(sf: *mut SplineFont, selected: *mut uint8, map: *mut EncMap);
}
extern "C" {
    pub fn SplineRefigure(spline: *mut Spline);
}
extern "C" {
    pub fn SPLCategorizePoints(spl: *mut SplinePointList);
}
extern "C" {
    pub fn _SPLCategorizePoints(
        spl: *mut SplinePointList,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SplinePointListCopy(base: *const SplinePointList) -> *mut SplinePointList;
}
pub const transformPointType_tpt_OnlySelected: transformPointType = 0;
pub const transformPointType_tpt_AllPoints: transformPointType = 1;
pub const transformPointType_tpt_OnlySelectedInterpCPs: transformPointType = 2;
pub type transformPointType = ::std::os::raw::c_uint;
pub const transformPointMask_tpmask_dontFixControlPoints: transformPointMask = 2;
pub const transformPointMask_tpmask_operateOnSelectedBCP: transformPointMask = 4;
pub const transformPointMask_tpmask_dontTrimValues: transformPointMask = 8;
pub type transformPointMask = ::std::os::raw::c_uint;
extern "C" {
    pub fn SplinePointListTransform(
        base: *mut SplinePointList,
        transform: *mut f64,
        allpoints: transformPointType,
    ) -> *mut SplinePointList;
}
extern "C" {
    pub fn SCReinstanciateRef(
        sc: *mut SplineChar,
        rsc: *mut SplineChar,
        layer: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn MakeDupRef(
        base: *mut SplineChar,
        local_enc: ::std::os::raw::c_int,
        uni_enc: ::std::os::raw::c_int,
    ) -> *mut SplineChar;
}
extern "C" {
    pub fn BDFClut(bdf: *mut BDFFont, linear_scale: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xlfd_components {
    pub foundry: [::std::os::raw::c_char; 80usize],
    pub family: [::std::os::raw::c_char; 100usize],
    pub weight: [::std::os::raw::c_char; 80usize],
    pub slant: [::std::os::raw::c_char; 40usize],
    pub setwidth: [::std::os::raw::c_char; 50usize],
    pub add_style: [::std::os::raw::c_char; 50usize],
    pub pixel_size: ::std::os::raw::c_int,
    pub point_size: ::std::os::raw::c_int,
    pub res_x: ::std::os::raw::c_int,
    pub res_y: ::std::os::raw::c_int,
    pub spacing: [::std::os::raw::c_char; 40usize],
    pub avg_width: ::std::os::raw::c_int,
    pub cs_reg: [::std::os::raw::c_char; 80usize],
    pub cs_enc: [::std::os::raw::c_char; 80usize],
    pub char_cnt: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xlfd_components() {
    assert_eq!(
        ::std::mem::size_of::<xlfd_components>(),
        624usize,
        concat!("Size of: ", stringify!(xlfd_components))
    );
    assert_eq!(
        ::std::mem::align_of::<xlfd_components>(),
        4usize,
        concat!("Alignment of ", stringify!(xlfd_components))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xlfd_components>())).foundry as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xlfd_components),
            "::",
            stringify!(foundry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xlfd_components>())).family as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(xlfd_components),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xlfd_components>())).weight as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(xlfd_components),
            "::",
            stringify!(weight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xlfd_components>())).slant as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(xlfd_components),
            "::",
            stringify!(slant)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xlfd_components>())).setwidth as *const _ as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(xlfd_components),
            "::",
            stringify!(setwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xlfd_components>())).add_style as *const _ as usize },
        350usize,
        concat!(
            "Offset of field: ",
            stringify!(xlfd_components),
            "::",
            stringify!(add_style)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xlfd_components>())).pixel_size as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(xlfd_components),
            "::",
            stringify!(pixel_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xlfd_components>())).point_size as *const _ as usize },
        404usize,
        concat!(
            "Offset of field: ",
            stringify!(xlfd_components),
            "::",
            stringify!(point_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xlfd_components>())).res_x as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(xlfd_components),
            "::",
            stringify!(res_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xlfd_components>())).res_y as *const _ as usize },
        412usize,
        concat!(
            "Offset of field: ",
            stringify!(xlfd_components),
            "::",
            stringify!(res_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xlfd_components>())).spacing as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(xlfd_components),
            "::",
            stringify!(spacing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xlfd_components>())).avg_width as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(xlfd_components),
            "::",
            stringify!(avg_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xlfd_components>())).cs_reg as *const _ as usize },
        460usize,
        concat!(
            "Offset of field: ",
            stringify!(xlfd_components),
            "::",
            stringify!(cs_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xlfd_components>())).cs_enc as *const _ as usize },
        540usize,
        concat!(
            "Offset of field: ",
            stringify!(xlfd_components),
            "::",
            stringify!(cs_enc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xlfd_components>())).char_cnt as *const _ as usize },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(xlfd_components),
            "::",
            stringify!(char_cnt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bdf_props {
    pub name: *const ::std::os::raw::c_char,
    pub type_: ::std::os::raw::c_int,
    pub defaultable: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_std_bdf_props() {
    assert_eq!(
        ::std::mem::size_of::<std_bdf_props>(),
        16usize,
        concat!("Size of: ", stringify!(std_bdf_props))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bdf_props>(),
        8usize,
        concat!("Alignment of ", stringify!(std_bdf_props))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_bdf_props>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_bdf_props),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_bdf_props>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_bdf_props),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_bdf_props>())).defaultable as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(std_bdf_props),
            "::",
            stringify!(defaultable)
        )
    );
}
extern "C" {
    pub fn CubicSolve(sp: *const Spline1D, sought: f64, ts: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SplineSolve(sp: *const Spline1D, tmin: f64, tmax: f64, sought_y: f64) -> f64;
}
extern "C" {
    pub fn SplineSolveFixup(sp: *const Spline1D, tmin: f64, tmax: f64, sought_y: f64) -> f64;
}
extern "C" {
    pub fn SplineLength(spline: *mut Spline) -> f64;
}
extern "C" {
    pub fn SplineIsLinear(spline: *mut Spline) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SFOrderBitmapList(sf: *mut SplineFont);
}
extern "C" {
    pub fn SplineMake(
        from: *mut SplinePoint,
        to: *mut SplinePoint,
        order2: ::std::os::raw::c_int,
    ) -> *mut Spline;
}
extern "C" {
    pub fn SFSplineMake(
        sf: *mut SplineFont,
        from: *mut SplinePoint,
        to: *mut SplinePoint,
    ) -> *mut Spline;
}
extern "C" {
    pub fn BlueScaleFigure(
        private_: *mut psdict,
        bluevalues: *mut f64,
        otherblues: *mut f64,
    ) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bluezone {
    pub base: f64,
    pub cvtindex: ::std::os::raw::c_int,
    pub family_base: f64,
    pub family_cvtindex: ::std::os::raw::c_int,
    pub overshoot: f64,
    pub highest: ::std::os::raw::c_int,
    pub lowest: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_bluezone() {
    assert_eq!(
        ::std::mem::size_of::<bluezone>(),
        48usize,
        concat!("Size of: ", stringify!(bluezone))
    );
    assert_eq!(
        ::std::mem::align_of::<bluezone>(),
        8usize,
        concat!("Alignment of ", stringify!(bluezone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bluezone>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bluezone),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bluezone>())).cvtindex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bluezone),
            "::",
            stringify!(cvtindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bluezone>())).family_base as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bluezone),
            "::",
            stringify!(family_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bluezone>())).family_cvtindex as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bluezone),
            "::",
            stringify!(family_cvtindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bluezone>())).overshoot as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bluezone),
            "::",
            stringify!(overshoot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bluezone>())).highest as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bluezone),
            "::",
            stringify!(highest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bluezone>())).lowest as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(bluezone),
            "::",
            stringify!(lowest)
        )
    );
}
pub type BlueZone = bluezone;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stdstem {
    pub width: f64,
    pub cvtindex: ::std::os::raw::c_int,
    pub snapto: *mut stdstem,
    pub stopat: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_stdstem() {
    assert_eq!(
        ::std::mem::size_of::<stdstem>(),
        32usize,
        concat!("Size of: ", stringify!(stdstem))
    );
    assert_eq!(
        ::std::mem::align_of::<stdstem>(),
        8usize,
        concat!("Alignment of ", stringify!(stdstem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stdstem>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stdstem),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stdstem>())).cvtindex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stdstem),
            "::",
            stringify!(cvtindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stdstem>())).snapto as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stdstem),
            "::",
            stringify!(snapto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stdstem>())).stopat as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stdstem),
            "::",
            stringify!(stopat)
        )
    );
}
pub type StdStem = stdstem;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct globalinstrct {
    pub sf: *mut SplineFont,
    pub layer: ::std::os::raw::c_int,
    pub bd: *mut BlueData,
    pub fudge: f64,
    pub cvt_done: ::std::os::raw::c_int,
    pub fpgm_done: ::std::os::raw::c_int,
    pub prep_done: ::std::os::raw::c_int,
    pub blues: [BlueZone; 12usize],
    pub bluecnt: ::std::os::raw::c_int,
    pub stdhw: StdStem,
    pub stemsnaph: *mut StdStem,
    pub stemsnaphcnt: ::std::os::raw::c_int,
    pub stdvw: StdStem,
    pub stemsnapv: *mut StdStem,
    pub stemsnapvcnt: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_globalinstrct() {
    assert_eq!(
        ::std::mem::size_of::<globalinstrct>(),
        728usize,
        concat!("Size of: ", stringify!(globalinstrct))
    );
    assert_eq!(
        ::std::mem::align_of::<globalinstrct>(),
        8usize,
        concat!("Alignment of ", stringify!(globalinstrct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<globalinstrct>())).sf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(globalinstrct),
            "::",
            stringify!(sf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<globalinstrct>())).layer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(globalinstrct),
            "::",
            stringify!(layer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<globalinstrct>())).bd as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(globalinstrct),
            "::",
            stringify!(bd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<globalinstrct>())).fudge as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(globalinstrct),
            "::",
            stringify!(fudge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<globalinstrct>())).cvt_done as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(globalinstrct),
            "::",
            stringify!(cvt_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<globalinstrct>())).fpgm_done as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(globalinstrct),
            "::",
            stringify!(fpgm_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<globalinstrct>())).prep_done as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(globalinstrct),
            "::",
            stringify!(prep_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<globalinstrct>())).blues as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(globalinstrct),
            "::",
            stringify!(blues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<globalinstrct>())).bluecnt as *const _ as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(globalinstrct),
            "::",
            stringify!(bluecnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<globalinstrct>())).stdhw as *const _ as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(globalinstrct),
            "::",
            stringify!(stdhw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<globalinstrct>())).stemsnaph as *const _ as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(globalinstrct),
            "::",
            stringify!(stemsnaph)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<globalinstrct>())).stemsnaphcnt as *const _ as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(globalinstrct),
            "::",
            stringify!(stemsnaphcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<globalinstrct>())).stdvw as *const _ as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(globalinstrct),
            "::",
            stringify!(stdvw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<globalinstrct>())).stemsnapv as *const _ as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(globalinstrct),
            "::",
            stringify!(stemsnapv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<globalinstrct>())).stemsnapvcnt as *const _ as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(globalinstrct),
            "::",
            stringify!(stemsnapvcnt)
        )
    );
}
pub type GlobalInstrCt = globalinstrct;
extern "C" {
    pub fn InitGlobalInstrCt(
        gic: *mut GlobalInstrCt,
        sf: *mut SplineFont,
        layer: ::std::os::raw::c_int,
        bd: *mut BlueData,
    );
}
extern "C" {
    pub fn FreeGlobalInstrCt(gic: *mut GlobalInstrCt);
}
extern "C" {
    pub fn NowakowskiSCAutoInstr(gic: *mut GlobalInstrCt, sc: *mut SplineChar);
}
extern "C" {
    pub fn CVT_ImportPrivate(sf: *mut SplineFont);
}
extern "C" {
    pub fn SplineFontAutoHint(sf: *mut SplineFont, layer: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SCDrawsSomething(sc: *mut SplineChar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCSetMetaData(
        sc: *mut SplineChar,
        name: *const ::std::os::raw::c_char,
        unienc: ::std::os::raw::c_int,
        comment: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DumpSplineFontMetadata(sf: *mut SplineFont) -> *mut ::std::os::raw::c_char;
}
pub const ttfflags_ttf_onlystrikes: ttfflags = 1;
pub const ttfflags_ttf_onlyonestrike: ttfflags = 2;
pub const ttfflags_ttf_onlykerns: ttfflags = 4;
pub const ttfflags_ttf_onlynames: ttfflags = 8;
pub type ttfflags = ::std::os::raw::c_uint;
extern "C" {
    pub fn SFReadUFO(
        filename: *mut ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> *mut SplineFont;
}
extern "C" {
    pub fn LoadSplineFont(
        filename: *const ::std::os::raw::c_char,
        arg1: openflags,
    ) -> *mut SplineFont;
}
extern "C" {
    pub fn _ReadSplineFont(
        file: *mut FILE,
        filename: *const ::std::os::raw::c_char,
        openflags: openflags,
    ) -> *mut SplineFont;
}
extern "C" {
    pub fn ReadSplineFont(
        filename: *const ::std::os::raw::c_char,
        arg1: openflags,
    ) -> *mut SplineFont;
}
extern "C" {
    pub fn ArchiveCleanup(archivedir: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn Unarchive(
        name: *mut ::std::os::raw::c_char,
        _archivedir: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Decompress(
        name: *mut ::std::os::raw::c_char,
        compression: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn MacStyleCode(sf: *mut SplineFont, psstyle: *mut uint16) -> uint16;
}
extern "C" {
    pub fn NamesReadUFO(filename: *mut ::std::os::raw::c_char) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SFSubfontnameStart(fname: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn UnicodeRange(unienc: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SCBuildDummy(
        dummy: *mut SplineChar,
        sf: *mut SplineFont,
        map: *mut EncMap,
        i: ::std::os::raw::c_int,
    ) -> *mut SplineChar;
}
extern "C" {
    pub fn SFMakeChar(
        sf: *mut SplineFont,
        map: *mut EncMap,
        i: ::std::os::raw::c_int,
    ) -> *mut SplineChar;
}
extern "C" {
    pub fn AdobeLigatureFormat(name: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn LigTagFromUnicode(uni: ::std::os::raw::c_int) -> uint32;
}
extern "C" {
    pub fn SCLigCaretheck(sc: *mut SplineChar, clean: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SCUndoSetLBearingChange(sc: *mut SplineChar, lb: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SplinePointListInterpretGlif(
        sf: *mut SplineFont,
        filename: *mut ::std::os::raw::c_char,
        memory: *mut ::std::os::raw::c_char,
        memlen: ::std::os::raw::c_int,
        em_size: ::std::os::raw::c_int,
        ascent: ::std::os::raw::c_int,
        stroked: ::std::os::raw::c_int,
    ) -> *mut SplineSet;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pscontext {
    pub is_type2: ::std::os::raw::c_int,
    pub painttype: ::std::os::raw::c_int,
    pub instance_count: ::std::os::raw::c_int,
    pub blend_values: [f64; 17usize],
    pub blend_warn: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pscontext() {
    assert_eq!(
        ::std::mem::size_of::<pscontext>(),
        160usize,
        concat!("Size of: ", stringify!(pscontext))
    );
    assert_eq!(
        ::std::mem::align_of::<pscontext>(),
        8usize,
        concat!("Alignment of ", stringify!(pscontext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pscontext>())).is_type2 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pscontext),
            "::",
            stringify!(is_type2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pscontext>())).painttype as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pscontext),
            "::",
            stringify!(painttype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pscontext>())).instance_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pscontext),
            "::",
            stringify!(instance_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pscontext>())).blend_values as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pscontext),
            "::",
            stringify!(blend_values)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pscontext>())).blend_warn as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(pscontext),
            "::",
            stringify!(blend_warn)
        )
    );
}
extern "C" {
    pub fn NameToEncoding(
        sf: *mut SplineFont,
        map: *mut EncMap,
        uname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SFGetOrMakeChar(
        sf: *mut SplineFont,
        unienc: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SplineChar;
}
extern "C" {
    pub fn SFGetOrMakeCharFromUnicode(
        sf: *mut SplineFont,
        map: *mut EncMap,
        ch: ::std::os::raw::c_int,
    ) -> *mut SplineChar;
}
extern "C" {
    pub fn DoAutoRecovery(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type DoAutoRecoveryPostRecoverFunc =
    ::std::option::Option<unsafe extern "C" fn(sf: *mut SplineFont)>;
extern "C" {
    pub fn SFPrivateGuess(
        sf: *mut SplineFont,
        layer: ::std::os::raw::c_int,
        private: *mut psdict,
        name: *mut ::std::os::raw::c_char,
        onlyone: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SFRemoveLayer(sf: *mut SplineFont, l: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SFAddLayer(
        sf: *mut SplineFont,
        name: *mut ::std::os::raw::c_char,
        order2: ::std::os::raw::c_int,
        background: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SFLayerSetBackground(
        sf: *mut SplineFont,
        layer: ::std::os::raw::c_int,
        is_back: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SplineSetsRound2Int(
        spl: *mut SplineSet,
        factor: f64,
        inspiro: ::std::os::raw::c_int,
        onlysel: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SCRound2Int(sc: *mut SplineChar, layer: ::std::os::raw::c_int, factor: f64);
}
extern "C" {
    pub fn SFFlatten(cidmaster: *mut *mut SplineFont);
}
extern "C" {
    pub fn SCCopyLayerToLayer(
        sc: *mut SplineChar,
        from: ::std::os::raw::c_int,
        to: ::std::os::raw::c_int,
        doclear: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn hasFreeType() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hasFreeTypeDebugger() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hasFreeTypeByteCode() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FreeTypeAtLeast(
        major: ::std::os::raw::c_int,
        minor: ::std::os::raw::c_int,
        patch: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FreeTypeStringVersion() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn doneFreeType();
}
extern "C" {
    pub fn _FreeTypeFontContext(
        sf: *mut SplineFont,
        sc: *mut SplineChar,
        fv: *mut fontviewbase,
        layer: ::std::os::raw::c_int,
        ff: fontformat,
        flags: ::std::os::raw::c_int,
        shared_ftc: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn FreeTypeFontContext(
        sf: *mut SplineFont,
        sc: *mut SplineChar,
        fv: *mut fontviewbase,
        layer: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SplineFontFreeTypeRasterize(
        freetypecontext: *mut ::std::os::raw::c_void,
        pixelsize: ::std::os::raw::c_int,
        depth: ::std::os::raw::c_int,
    ) -> *mut BDFFont;
}
extern "C" {
    pub fn SplineCharFreeTypeRasterize(
        freetypecontext: *mut ::std::os::raw::c_void,
        gid: ::std::os::raw::c_int,
        ptsize: ::std::os::raw::c_int,
        dpi: ::std::os::raw::c_int,
        depth: ::std::os::raw::c_int,
    ) -> *mut BDFChar;
}
extern "C" {
    pub fn FreeTypeFreeContext(freetypecontext: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn FreeType_GridFitChar(
        single_glyph_context: *mut ::std::os::raw::c_void,
        enc: ::std::os::raw::c_int,
        ptsizey: f64,
        ptsizex: f64,
        dpi: ::std::os::raw::c_int,
        width: *mut uint16,
        sc: *mut SplineChar,
        depth: ::std::os::raw::c_int,
        scaled: ::std::os::raw::c_int,
    ) -> *mut SplineSet;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct freetype_raster {
    _unused: [u8; 0],
}
extern "C" {
    pub fn FreeType_GetRaster(
        single_glyph_context: *mut ::std::os::raw::c_void,
        enc: ::std::os::raw::c_int,
        ptsizey: f64,
        ptsizex: f64,
        dpi: ::std::os::raw::c_int,
        depth: ::std::os::raw::c_int,
    ) -> *mut freetype_raster;
}
extern "C" {
    pub fn SplineCharFreeTypeRasterizeNoHints(
        sc: *mut SplineChar,
        layer: ::std::os::raw::c_int,
        ptsize: ::std::os::raw::c_int,
        dpi: ::std::os::raw::c_int,
        depth: ::std::os::raw::c_int,
    ) -> *mut BDFChar;
}
extern "C" {
    pub fn SplineFontFreeTypeRasterizeNoHints(
        sf: *mut SplineFont,
        layer: ::std::os::raw::c_int,
        pixelsize: ::std::os::raw::c_int,
        depth: ::std::os::raw::c_int,
    ) -> *mut BDFFont;
}
extern "C" {
    pub fn FreeType_FreeRaster(raster: *mut freetype_raster);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TT_ExecContextRec_ {
    _unused: [u8; 0],
}
extern "C" {
    pub fn DebuggerCurrentRaster(
        exc: *mut TT_ExecContextRec_,
        depth: ::std::os::raw::c_int,
    ) -> *mut freetype_raster;
}
extern "C" {
    pub fn AnchorPositioning(
        sc: *mut SplineChar,
        ustr: *mut unichar_t,
        sstr: *mut *mut SplineChar,
    ) -> *mut AnchorPos;
}
extern "C" {
    pub fn SF_CloseAllInstrs(sf: *mut SplineFont) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSTtfNumberPoints(ss: *mut SplineSet) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCNumberPoints(
        sc: *mut SplineChar,
        layer: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCPointsNumberedProperly(
        sc: *mut SplineChar,
        layer: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SFRenameTheseFeatureTags(
        sf: *mut SplineFont,
        tag: uint32,
        sli: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        totag: uint32,
        tosli: ::std::os::raw::c_int,
        toflags: ::std::os::raw::c_int,
        ismac: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SFRemoveUnusedNestedFeatures(sf: *mut SplineFont) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FindMacSetting(
        sf: *mut SplineFont,
        feat: ::std::os::raw::c_int,
        set: ::std::os::raw::c_int,
        secondary: *mut *mut macsetting,
    ) -> *mut macsetting;
}
extern "C" {
    pub fn BpColinear(
        first: *mut BasePoint,
        mid: *mut BasePoint,
        last: *mut BasePoint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BpWithin(
        first: *mut BasePoint,
        mid: *mut BasePoint,
        last: *mut BasePoint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ToAbsolute(filename: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SFSetModTime(sf: *mut SplineFont);
}
extern "C" {
    pub fn SFFindLookupSubtable(
        sf: *mut SplineFont,
        name: *const ::std::os::raw::c_char,
    ) -> *mut lookup_subtable;
}
extern "C" {
    pub fn FeatureTagInFeatureScriptList(
        tag: uint32,
        fl: *mut FeatureScriptLangList,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SplinePointRound(arg1: *mut SplinePoint, arg2: f64);
}
extern "C" {
    pub fn SFFindKernClass(
        sf: *mut SplineFont,
        first: *mut SplineChar,
        last: *mut SplineChar,
        index: *mut ::std::os::raw::c_int,
        allow_zero: ::std::os::raw::c_int,
    ) -> *mut KernClass;
}
extern "C" {
    pub fn SFFindVKernClass(
        sf: *mut SplineFont,
        first: *mut SplineChar,
        last: *mut SplineChar,
        index: *mut ::std::os::raw::c_int,
        allow_zero: ::std::os::raw::c_int,
    ) -> *mut KernClass;
}
extern "C" {
    pub fn SCClearRounds(sc: *mut SplineChar, layer: ::std::os::raw::c_int);
}
extern "C" {
    pub fn MDReplace(md: *mut MinimumDistance, old: *mut SplineSet, rpl: *mut SplineSet);
}
extern "C" {
    pub fn SCSynchronizeWidth(
        sc: *mut SplineChar,
        newwidth: f64,
        oldwidth: f64,
        fv: *mut fontviewbase,
    );
}
extern "C" {
    pub fn HasUseMyMetrics(sc: *mut SplineChar, layer: ::std::os::raw::c_int) -> *mut RefChar;
}
extern "C" {
    pub fn SCSynchronizeLBearing(sc: *mut SplineChar, off: f64, layer: ::std::os::raw::c_int);
}
extern "C" {
    pub fn RevertedGlyphReferenceFixup(sc: *mut SplineChar, sf: *mut SplineFont);
}
extern "C" {
    pub fn SFUntickAll(sf: *mut SplineFont);
}
extern "C" {
    pub fn _ExportGlif(
        glif: *mut FILE,
        sc: *mut SplineChar,
        layer: ::std::os::raw::c_int,
        version: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCCopyWidth(sc: *mut SplineChar, arg1: undotype);
}
extern "C" {
    pub fn SCClearBackground(sc: *mut SplineChar);
}
extern "C" {
    pub fn BackgroundImageTransform(sc: *mut SplineChar, img: *mut ImageList, transform: *mut f64);
}
extern "C" {
    pub fn SFIsDuplicatable(sf: *mut SplineFont, sc: *mut SplineChar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCClearLayer(sc: *mut SplineChar, layer: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SCClearContents(sc: *mut SplineChar, layer: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SCClearAll(sc: *mut SplineChar, layer: ::std::os::raw::c_int);
}
extern "C" {
    pub fn FontForge_InitializeEmbeddedPython();
}
extern "C" {
    pub fn FontForge_FinalizeEmbeddedPython();
}
extern "C" {
    pub fn PyFF_ErrorString(
        msg: *const ::std::os::raw::c_char,
        str_: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn PyFF_ErrorF3(
        frmt: *const ::std::os::raw::c_char,
        str_: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        depth: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn PyFF_Stdin();
}
extern "C" {
    pub fn PyFF_Main(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
        start: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn PyFF_ScriptFile(
        fv: *mut fontviewbase,
        sc: *mut SplineChar,
        filename: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn PyFF_ScriptString(
        fv: *mut fontviewbase,
        sc: *mut SplineChar,
        layer: ::std::os::raw::c_int,
        str_: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn PyFF_FreeFV(fv: *mut fontviewbase);
}
extern "C" {
    pub fn PyFF_FreeSC(sc: *mut SplineChar);
}
extern "C" {
    pub fn PyFF_FreeSCLayer(sc: *mut SplineChar, layer: ::std::os::raw::c_int);
}
extern "C" {
    pub fn PyFF_FreeSF(sf: *mut SplineFont);
}
extern "C" {
    pub fn PyFF_FreePythonPersistent(python_persistent: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn PyFF_ProcessInitFiles();
}
extern "C" {
    pub fn PyFF_PickleMeToString(
        pydata: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn PyFF_UnPickleMeToObjects(
        str_: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _object {
    _unused: [u8; 0],
}
extern "C" {
    pub fn PyFF_CallDictFunc(
        dict: *mut _object,
        key: *const ::std::os::raw::c_char,
        argtypes: *const ::std::os::raw::c_char,
        ...
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct math_constants_descriptor {
    pub ui_name: *mut ::std::os::raw::c_char,
    pub script_name: *mut ::std::os::raw::c_char,
    pub offset: ::std::os::raw::c_int,
    pub devtab_offset: ::std::os::raw::c_int,
    pub message: *mut ::std::os::raw::c_char,
    pub new_page: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_math_constants_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<math_constants_descriptor>(),
        40usize,
        concat!("Size of: ", stringify!(math_constants_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<math_constants_descriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(math_constants_descriptor))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<math_constants_descriptor>())).ui_name as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(math_constants_descriptor),
            "::",
            stringify!(ui_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<math_constants_descriptor>())).script_name as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(math_constants_descriptor),
            "::",
            stringify!(script_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<math_constants_descriptor>())).offset as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(math_constants_descriptor),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<math_constants_descriptor>())).devtab_offset as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(math_constants_descriptor),
            "::",
            stringify!(devtab_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<math_constants_descriptor>())).message as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(math_constants_descriptor),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<math_constants_descriptor>())).new_page as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(math_constants_descriptor),
            "::",
            stringify!(new_page)
        )
    );
}
extern "C" {
    pub static mut math_constants_descriptor: [math_constants_descriptor; 0usize];
}
extern "C" {
    pub static mut knownweights: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut realweights: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut noticeweights: [*mut *const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn BPTooFar(bp1: *mut BasePoint, bp2: *mut BasePoint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCHintOverlapInMask(sc: *mut SplineChar, hm: *mut HintMask) -> *mut StemInfo;
}
extern "C" {
    pub fn VSErrorsFromMask(
        mask: ::std::os::raw::c_int,
        private_mask: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SCValidate(
        sc: *mut SplineChar,
        layer: ::std::os::raw::c_int,
        force: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCValidateAnchors(sc: *mut SplineChar) -> *mut AnchorClass;
}
extern "C" {
    pub fn SCTickValidationState(sc: *mut SplineChar, layer: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ValidatePrivate(sf: *mut SplineFont) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SFValidate(
        sf: *mut SplineFont,
        layer: ::std::os::raw::c_int,
        force: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSMaskFromFormat(
        sf: *mut SplineFont,
        layer: ::std::os::raw::c_int,
        format: fontformat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RandomParaFromScript(
        script: uint32,
        lang: *mut uint32,
        sf: *mut SplineFont,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn PatternSCBounds(sc: *mut SplineChar, b: *mut DBounds);
}
extern "C" {
    pub fn SFDefaultImage(
        sf: *mut SplineFont,
        filename: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SCClearInstrsOrMark(
        sc: *mut SplineChar,
        layer: ::std::os::raw::c_int,
        complain: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn instrcheck(sc: *mut SplineChar, layer: ::std::os::raw::c_int);
}
extern "C" {
    pub fn TTFPointMatches(
        sc: *mut SplineChar,
        layer: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SFCapHeight(
        sf: *mut SplineFont,
        layer: ::std::os::raw::c_int,
        return_error: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    pub fn SFXHeight(
        sf: *mut SplineFont,
        layer: ::std::os::raw::c_int,
        return_error: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    pub fn SFAscender(
        sf: *mut SplineFont,
        layer: ::std::os::raw::c_int,
        return_error: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    pub fn SFDescender(
        sf: *mut SplineFont,
        layer: ::std::os::raw::c_int,
        return_error: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    pub fn SCRemoveKern(sc: *mut SplineChar);
}
extern "C" {
    pub fn SCRemoveVKern(sc: *mut SplineChar);
}
extern "C" {
    #[doc = " Return falise if the container does not contain \"sought\""]
    #[doc = " Return true if sought is in the container."]
    pub fn SplinePointListContains(
        container: *mut SplinePointList,
        sought: *mut SplinePointList,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return falise if the container does not contain the single splint point \"sp\","]
    #[doc = " Return true if \"sp\" is in the container."]
    pub fn SplinePointListContainsPoint(
        container: *mut SplinePointList,
        sp: *mut SplinePoint,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Visitor for SPLFirstVisitSplines()"]
pub type SPLFirstVisitSplinesVisitor = ::std::option::Option<
    unsafe extern "C" fn(
        splfirst: *mut SplinePoint,
        s: *mut Spline,
        udata: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " Visitor Function: print debug information about each spline"]
    #[doc = ""]
    #[doc = " Visitor for SPLFirstVisit()"]
    pub fn SPLFirstVisitorDebug(
        splfirst: *mut SplinePoint,
        spline: *mut Spline,
        udata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Visitor Function: print debug information about the current"]
    #[doc = " selection state including the secondary BCP selection for each"]
    #[doc = " spline"]
    #[doc = ""]
    #[doc = " Visitor for SPLFirstVisit()"]
    pub fn SPLFirstVisitorDebugSelectionState(
        splfirst: *mut SplinePoint,
        spline: *mut Spline,
        udata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Given a SplinePointList* that you want to visit each spline in the"]
    #[doc = " iteration is not as simple as it could be, so you can call this"]
    #[doc = " function passing spl->first as 'splfirst' and a visitor function"]
    #[doc = " which will see each spline in the splfirst colleciton."]
    #[doc = ""]
    #[doc = " For debug, you can pass SPLFirstVisitorDebug which will print"]
    #[doc = " information for each item in the splfirst collection."]
    #[doc = ""]
    #[doc = " You can pass any arbitrary data in as udata and SPLFirstVisit()"]
    #[doc = " will pass that udata to your visitor function without change. If"]
    #[doc = " you want a return value from your visitor, pass a pointer to a"]
    #[doc = " struct as udata. eg:"]
    #[doc = ""]
    #[doc = " typedef struct SPLFirstVisitorFoundSoughtDataS"]
    #[doc = " {"]
    #[doc = "    SplinePoint* sought;"]
    #[doc = "    int found;"]
    #[doc = " } SPLFirstVisitorFoundSoughtData;"]
    #[doc = ""]
    #[doc = " // ..."]
    #[doc = ""]
    #[doc = "\tSPLFirstVisitorFoundSoughtData d;"]
    #[doc = "\td.sought = sought;"]
    #[doc = "\td.found  = 0;"]
    #[doc = "\tSPLFirstVisit( spl->first, SPLFirstVisitorFoundSought, &d );"]
    #[doc = "\tif( d.found )"]
    #[doc = "           return 1;"]
    #[doc = ""]
    pub fn SPLFirstVisitSplines(
        splfirst: *mut SplinePoint,
        f: SPLFirstVisitSplinesVisitor,
        udata: *mut ::std::os::raw::c_void,
    );
}
#[doc = " Visitor for SPLFirstVisitPoints()"]
pub type SPLFirstVisitPointsVisitor = ::std::option::Option<
    unsafe extern "C" fn(
        splfirst: *mut SplinePoint,
        s: *mut Spline,
        sp: *mut SplinePoint,
        udata: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " Visit all the SplinePoints on the spline starting at splfirst."]
    pub fn SPLFirstVisitPoints(
        splfirst: *mut SplinePoint,
        f: SPLFirstVisitPointsVisitor,
        udata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Applies a visitor to the container and returns false if no point in the SPL"]
    #[doc = " has an x coordinate of 'x'."]
    pub fn SplinePointListContainsPointAtX(
        container: *mut SplinePointList,
        x: f64,
    ) -> *mut SplinePoint;
}
extern "C" {
    pub fn SplinePointListContainsPointAtY(
        container: *mut SplinePointList,
        y: f64,
    ) -> *mut SplinePoint;
}
extern "C" {
    pub fn SplinePointListContainsPointAtXY(
        container: *mut SplinePointList,
        x: f64,
        y: f64,
    ) -> *mut SplinePoint;
}
extern "C" {
    #[doc = " True if the spline with from/to is part of the guide splines."]
    #[doc = ""]
    #[doc = " Handy for telling if the user has just clicked on a guide for example,"]
    #[doc = " you might want to also check the active layer first with cv->b.drawmode == dm_grid"]
    pub fn isSplinePointPartOfGuide(sf: *mut SplineFont, sp: *mut SplinePoint) -> bool;
}
extern "C" {
    pub fn debug_printHint(h: *mut StemInfo, msg: *mut ::std::os::raw::c_char);
}
pub const ShapeType_Shape_Convex: ShapeType = 0;
pub const ShapeType_Shape_CCWTurn: ShapeType = 1;
pub const ShapeType_Shape_CCW: ShapeType = 2;
pub const ShapeType_Shape_Quadratic: ShapeType = 3;
pub const ShapeType_Shape_PointOnEdge: ShapeType = 4;
pub const ShapeType_Shape_TooFewPoints: ShapeType = 5;
pub const ShapeType_Shape_NotClosed: ShapeType = 6;
pub const ShapeType_Shape_TinySpline: ShapeType = 7;
pub const ShapeType_Shape_HalfLinear: ShapeType = 8;
pub const ShapeType_Shape_BadCP_R1: ShapeType = 9;
pub const ShapeType_Shape_BadCP_R2: ShapeType = 10;
pub const ShapeType_Shape_BadCP_R3: ShapeType = 11;
pub const ShapeType_Shape_SelfIntersects: ShapeType = 12;
pub type ShapeType = ::std::os::raw::c_uint;
extern "C" {
    pub fn CVFreeHandInfo() -> *mut StrokeInfo;
}
extern "C" {
    pub fn CVStrokeInfo() -> *mut StrokeInfo;
}
extern "C" {
    pub fn ConvexNibID(tok: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn StrokeSetConvex(
        ss: *mut SplineSet,
        toknum: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn StrokeGetConvex(
        toknum: ::std::os::raw::c_int,
        cpy: ::std::os::raw::c_int,
    ) -> *mut SplineSet;
}
extern "C" {
    pub fn NibIsValid(arg1: *mut SplineSet) -> ShapeType;
}
extern "C" {
    pub fn SplineStrokeSimpleFixup(tailp: *mut SplinePoint, p: BasePoint);
}
extern "C" {
    pub fn NibShapeTypeMsg(st: ShapeType) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn AppendCubicSplinePortion(
        s: *mut Spline,
        t_start: f64,
        t_end: f64,
        start: *mut SplinePoint,
    ) -> *mut SplinePoint;
}
extern "C" {
    pub fn AppendCubicSplineSetPortion(
        s: *mut Spline,
        t_start: f64,
        s_end: *mut Spline,
        t_end: f64,
        dst_start: *mut SplinePoint,
        backward: ::std::os::raw::c_int,
    ) -> *mut SplinePoint;
}
extern "C" {
    pub fn SSAppendArc(
        cur: *mut SplineSet,
        major: f64,
        minor: f64,
        ang: BasePoint,
        ut_fm: BasePoint,
        ut_to: BasePoint,
        bk: ::std::os::raw::c_int,
        limit: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SplineSetStroke(
        ss: *mut SplineSet,
        si: *mut StrokeInfo,
        order2: ::std::os::raw::c_int,
    ) -> *mut SplineSet;
}
extern "C" {
    pub fn UnitShape(n: ::std::os::raw::c_int) -> *mut SplineSet;
}
extern "C" {
    pub fn FVStrokeItScript(
        _fv: *mut ::std::os::raw::c_void,
        si: *mut StrokeInfo,
        pointless_argument: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct array {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bitmapview {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clut {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gimage {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct charviewbase {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct charinfo {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fontviewbase {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct metricsview {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct glyphnamehash {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct instrdata {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shortview {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernclasslistdlg {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernclassdlg {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gfi_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct val_data {
    pub _address: u8,
}
